//
//  MockingbirdTestsHostMocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird v0.11.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import MockingbirdTestsHost
import AppKit
import CoreAudio
import CoreText
import Foundation
import MockingbirdModuleTestsHost
import ObjectiveC
import Swift

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AbstractSpecializedGenericProtocol

public final class AbstractSpecializedGenericProtocolMock<EquatableType: Swift.Equatable>: MockingbirdTestsHost.GenericBaseClass<Bool>, MockingbirdTestsHost.AbstractSpecializedGenericProtocol, Mockingbird.Mock, AbstractSpecializedGenericProtocolAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AbstractSpecializedGenericProtocolMock<EquatableType: Swift.Equatable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AbstractSpecializedGenericProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: Bool)

  public override func `baseMethod`(`param`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol AbstractSpecializedGenericProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.AbstractSpecializedGenericProtocol`.
public func mock<EquatableType: Swift.Equatable>(_ type: AbstractSpecializedGenericProtocolMock<EquatableType>.Type, file: StaticString = #file, line: UInt = #line) -> AbstractSpecializedGenericProtocolAbstractMockType {
  return AbstractSpecializedGenericProtocolMock<EquatableType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AbstractSpecializedGenericProtocol`.
public func mock<EquatableType: Swift.Equatable, __ReturnType: AbstractSpecializedGenericProtocolAbstractMockType>(_ type: AbstractSpecializedGenericProtocolMock<EquatableType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AbstractSpecializedGenericProtocolMock<EquatableType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AbstractSpecializedGenericProtocol`.
public func dummy<EquatableType: Swift.Equatable>(_ type: AbstractSpecializedGenericProtocolMock<EquatableType>.Type, file: StaticString = #file, line: UInt = #line) -> AbstractSpecializedGenericProtocolMock<EquatableType> {
  return AbstractSpecializedGenericProtocolMock<EquatableType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AbstractSpecializedGenericProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AbstractSpecializedGenericProtocolMock<EquatableType>' or use 'dummy(AbstractSpecializedGenericProtocol.self)' to create a non-mockable dummy object")
public func mock<EquatableType: Swift.Equatable, __ReturnType>(_ type: AbstractSpecializedGenericProtocolMock<EquatableType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked AnotherTopLevelType

public final class AnotherTopLevelTypeMock: MockingbirdTestsHost.AnotherTopLevelType, Mockingbird.Mock, AnotherTopLevelTypeAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AnotherTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: - Mocked SecondLevelType

  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock, AnotherTopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }
  }

  // MARK: - Mocked InitializableSecondLevelType

  public final class InitializableSecondLevelTypeMock: InitializableSecondLevelType, Mockingbird.Mock, AnotherTopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        InitializableSecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    public class InitializerProxy: Mockingbird.Initializable {
      fileprivate init() {}

      public class Dummy: Mockingbird.Initializable {
        public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableSecondLevelTypeMock {
          let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
          mock.sourceLocation = SourceLocation(__file, __line)
          return mock
        }
      }

      public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> AnotherTopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType {
        let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize<__ReturnType: AnotherTopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
        let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return (mock as! __ReturnType)
      }

      @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializableSecondLevelTypeMock' or use 'dummy(InitializableSecondLevelTypeMock.self).initialize(...)' to create a non-mockable dummy object")
      public func initialize<__ReturnType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
    }

    // MARK: Mocked init(`param`: Bool)

    public required override init(`param`: Bool) {
      super.init(param: `param`)
      Mockingbird.checkVersion(for: self)
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
    }
  }
}

public protocol AnotherTopLevelTypeAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.AnotherTopLevelType`.
public func mock(_ type: MockingbirdTestsHost.AnotherTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeAbstractMockType {
  return AnotherTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.AnotherTopLevelType`.
public func mock<__ReturnType: AnotherTopLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.AnotherTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AnotherTopLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AnotherTopLevelType`.
public func dummy(_ type: MockingbirdTestsHost.AnotherTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeMock {
  return AnotherTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.AnotherTopLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AnotherTopLevelTypeMock' or use 'dummy(AnotherTopLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.AnotherTopLevelType.Type) -> __ReturnType { fatalError() }

public protocol AnotherTopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType {}

/// Initialize a class mock of `SecondLevelType`.
public func mock(_ type: MockingbirdTestsHost.AnotherTopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType {
  return AnotherTopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `SecondLevelType`.
public func mock<__ReturnType: AnotherTopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.AnotherTopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AnotherTopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `SecondLevelType`.
public func dummy(_ type: MockingbirdTestsHost.AnotherTopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeMock.SecondLevelTypeMock {
  return AnotherTopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `SecondLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AnotherTopLevelTypeMock.SecondLevelTypeMock' or use 'dummy(AnotherTopLevelType.SecondLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.AnotherTopLevelType.SecondLevelType.Type) -> __ReturnType { fatalError() }

public protocol AnotherTopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType {}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.AnotherTopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy()
}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
public func mock<__ReturnType: AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy>(_ type: MockingbirdTestsHost.AnotherTopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `InitializableSecondLevelType`.
public func dummy(_ type: MockingbirdTestsHost.AnotherTopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.Dummy {
  return AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.AnotherTopLevelType.InitializableSecondLevelType.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ArgumentMatchingProtocol

public final class ArgumentMatchingProtocolMock: MockingbirdTestsHost.ArgumentMatchingProtocol, Mockingbird.Mock, ArgumentMatchingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArgumentMatchingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalStructType`: MockingbirdTestsHost.StructType?, `optionalClassType`: MockingbirdTestsHost.ClassType?, `optionalEnumType`: MockingbirdTestsHost.EnumType?, `optionalStringType`: String?, `optionalBoolType`: Bool?, `optionalProtocolType`: P?, `optionalMetaType`: ClassType.Type?, `optionalAnyType`: Any?, `optionalAnyObjectType`: Swift.AnyObject?)

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalStructType`: MockingbirdTestsHost.StructType?, `optionalClassType`: MockingbirdTestsHost.ClassType?, `optionalEnumType`: MockingbirdTestsHost.EnumType?, `optionalStringType`: String?, `optionalBoolType`: Bool?, `optionalProtocolType`: P?, `optionalMetaType`: ClassType.Type?, `optionalAnyType`: Any?, `optionalAnyObjectType`: Swift.AnyObject?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalStructType`: MockingbirdTestsHost.StructType?, `optionalClassType`: MockingbirdTestsHost.ClassType?, `optionalEnumType`: MockingbirdTestsHost.EnumType?, `optionalStringType`: String?, `optionalBoolType`: Bool?, `optionalProtocolType`: P?, `optionalMetaType`: ClassType.Type?, `optionalAnyType`: Any?, `optionalAnyObjectType`: Swift.AnyObject?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalStructType`), Mockingbird.ArgumentMatcher(`optionalClassType`), Mockingbird.ArgumentMatcher(`optionalEnumType`), Mockingbird.ArgumentMatcher(`optionalStringType`), Mockingbird.ArgumentMatcher(`optionalBoolType`), Mockingbird.ArgumentMatcher(`optionalProtocolType`), Mockingbird.ArgumentMatcher(`optionalMetaType`), Mockingbird.ArgumentMatcher(`optionalAnyType`), Mockingbird.ArgumentMatcher(`optionalAnyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, P?, ClassType.Type?, Any?, Swift.AnyObject?) -> Bool {
      return concreteImplementation(`optionalStructType`, `optionalClassType`, `optionalEnumType`, `optionalStringType`, `optionalBoolType`, `optionalProtocolType`, `optionalMetaType`, `optionalAnyType`, `optionalAnyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalStructType`: @escaping @autoclosure () -> MockingbirdTestsHost.StructType?, `optionalClassType`: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType?, `optionalEnumType`: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType?, `optionalStringType`: @escaping @autoclosure () -> String?, `optionalBoolType`: @escaping @autoclosure () -> Bool?, `optionalProtocolType`: @escaping @autoclosure () -> P?, `optionalMetaType`: @escaping @autoclosure () -> ClassType.Type?, `optionalAnyType`: @escaping @autoclosure () -> Any?, `optionalAnyObjectType`: @escaping @autoclosure () -> Swift.AnyObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, P?, ClassType.Type?, Any?, Swift.AnyObject?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalStructType`), Mockingbird.resolve(`optionalClassType`), Mockingbird.resolve(`optionalEnumType`), Mockingbird.resolve(`optionalStringType`), Mockingbird.resolve(`optionalBoolType`), Mockingbird.resolve(`optionalProtocolType`), Mockingbird.resolve(`optionalMetaType`), Mockingbird.resolve(`optionalAnyType`), Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalStructType`: MockingbirdTestsHost.StructType?, `optionalClassType`: MockingbirdTestsHost.ClassType?, `optionalEnumType`: MockingbirdTestsHost.EnumType?, `optionalStringType`: String?, `optionalBoolType`: Bool?, `optionalProtocolType`: P?, `optionalMetaType`: ClassType.Type?, `optionalAnyType`: Any?, `optionalAnyObjectType`: Swift.AnyObject?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, P?, ClassType.Type?, Any?, Swift.AnyObject?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`<T: FloatingPoint>(`param`: T)

  public func `method`<T: FloatingPoint>(`param`: T) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<T: FloatingPoint>(`param`: T) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`<T: FloatingPoint>(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<T: FloatingPoint>(`param`: T) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`<P: MockingbirdTestsHost.BaseProtocol>(`structType`: MockingbirdTestsHost.StructType, `classType`: MockingbirdTestsHost.ClassType, `enumType`: MockingbirdTestsHost.EnumType, `stringType`: String, `boolType`: Bool, `protocolType`: P, `metaType`: ClassType.Type, `anyType`: Any, `anyObjectType`: Swift.AnyObject)

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`structType`: MockingbirdTestsHost.StructType, `classType`: MockingbirdTestsHost.ClassType, `enumType`: MockingbirdTestsHost.EnumType, `stringType`: String, `boolType`: Bool, `protocolType`: P, `metaType`: ClassType.Type, `anyType`: Any, `anyObjectType`: Swift.AnyObject) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`structType`: MockingbirdTestsHost.StructType, `classType`: MockingbirdTestsHost.ClassType, `enumType`: MockingbirdTestsHost.EnumType, `stringType`: String, `boolType`: Bool, `protocolType`: P, `metaType`: ClassType.Type, `anyType`: Any, `anyObjectType`: Swift.AnyObject) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`structType`), Mockingbird.ArgumentMatcher(`classType`), Mockingbird.ArgumentMatcher(`enumType`), Mockingbird.ArgumentMatcher(`stringType`), Mockingbird.ArgumentMatcher(`boolType`), Mockingbird.ArgumentMatcher(`protocolType`), Mockingbird.ArgumentMatcher(`metaType`), Mockingbird.ArgumentMatcher(`anyType`), Mockingbird.ArgumentMatcher(`anyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, P, ClassType.Type, Any, Swift.AnyObject) -> Bool {
      return concreteImplementation(`structType`, `classType`, `enumType`, `stringType`, `boolType`, `protocolType`, `metaType`, `anyType`, `anyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`structType`: @escaping @autoclosure () -> MockingbirdTestsHost.StructType, `classType`: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType, `enumType`: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType, `stringType`: @escaping @autoclosure () -> String, `boolType`: @escaping @autoclosure () -> Bool, `protocolType`: @escaping @autoclosure () -> P, `metaType`: @escaping @autoclosure () -> ClassType.Type, `anyType`: @escaping @autoclosure () -> Any, `anyObjectType`: @escaping @autoclosure () -> Swift.AnyObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, P, ClassType.Type, Any, Swift.AnyObject) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`structType`), Mockingbird.resolve(`classType`), Mockingbird.resolve(`enumType`), Mockingbird.resolve(`stringType`), Mockingbird.resolve(`boolType`), Mockingbird.resolve(`protocolType`), Mockingbird.resolve(`metaType`), Mockingbird.resolve(`anyType`), Mockingbird.resolve(`anyObjectType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`structType`: MockingbirdTestsHost.StructType, `classType`: MockingbirdTestsHost.ClassType, `enumType`: MockingbirdTestsHost.EnumType, `stringType`: String, `boolType`: Bool, `protocolType`: P, `metaType`: ClassType.Type, `anyType`: Any, `anyObjectType`: Swift.AnyObject) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, P, ClassType.Type, Any, Swift.AnyObject) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol ArgumentMatchingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArgumentMatchingProtocol`.
public func mock(_ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ArgumentMatchingProtocolAbstractMockType {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArgumentMatchingProtocol`.
public func mock<__ReturnType: ArgumentMatchingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ArgumentMatchingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ArgumentMatchingProtocolMock {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArgumentMatchingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ArgumentMatchingProtocolMock' or use 'dummy(ArgumentMatchingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ArrayCollection

public final class ArrayCollectionMock: MockingbirdTestsHost.ArrayCollection, Mockingbird.Mock, ArrayCollectionAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`objects`: [String])

  public func `method`(`objects`: [String]) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String]) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([String]) -> Bool {
      return concreteImplementation(`objects`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`(`objects`: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String]) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String]) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String]) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol ArrayCollectionAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayCollection`.
public func mock(_ type: MockingbirdTestsHost.ArrayCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> ArrayCollectionAbstractMockType {
  return ArrayCollectionMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayCollection`.
public func mock<__ReturnType: ArrayCollectionAbstractMockType>(_ type: MockingbirdTestsHost.ArrayCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ArrayCollectionMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ArrayCollection`.
public func dummy(_ type: MockingbirdTestsHost.ArrayCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> ArrayCollectionMock {
  return ArrayCollectionMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayCollection`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ArrayCollectionMock' or use 'dummy(ArrayCollection.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ArrayCollection.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ArrayTypes

public final class ArrayTypesMock: MockingbirdTestsHost.ArrayTypes, Mockingbird.Mock, ArrayTypesAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherVariable

  public var `anotherVariable`: [Foundation.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.NSObject])()
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitAnotherVariable

  public var `explicitAnotherVariable`: Array<Foundation.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<Foundation.NSObject>)()
    }
  }

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitVariable

  public var `explicitVariable`: Array<MockingbirdTestsHost.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<MockingbirdTestsHost.NSObject>)()
    }
  }

  public func getExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalAnotherVariable

  public var `optionalAnotherVariable`: [Foundation.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.NSObject?])()
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject?], [Foundation.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject?], [Foundation.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitAnotherVariable

  public var `optionalExplicitAnotherVariable`: Array<Foundation.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<Foundation.NSObject?>)()
    }
  }

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitVariable

  public var `optionalExplicitVariable`: Array<MockingbirdTestsHost.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<MockingbirdTestsHost.NSObject?>)()
    }
  }

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: [MockingbirdTestsHost.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.NSObject?])()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: [MockingbirdTestsHost.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.NSObject])()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Array<Foundation.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<Foundation.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Array<Foundation.NSObject>)()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Array<MockingbirdTestsHost.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Array<MockingbirdTestsHost.NSObject>)()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>)

  public func `explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `explicitMethod`(`param1`: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>, `param2`: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethodWithParameterLabels`()

  public func `explicitMethodWithParameterLabels`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  public func `explicitMethodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [Foundation.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [Foundation.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [Foundation.NSObject])()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [MockingbirdTestsHost.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [MockingbirdTestsHost.NSObject])()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject])

  public func `method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject], `param2`: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels`()

  public func `methodWithParameterLabels`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  public func `methodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }
}

public protocol ArrayTypesAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayTypes`.
public func mock(_ type: MockingbirdTestsHost.ArrayTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> ArrayTypesAbstractMockType {
  return ArrayTypesMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayTypes`.
public func mock<__ReturnType: ArrayTypesAbstractMockType>(_ type: MockingbirdTestsHost.ArrayTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ArrayTypesMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ArrayTypes`.
public func dummy(_ type: MockingbirdTestsHost.ArrayTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> ArrayTypesMock {
  return ArrayTypesMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayTypes`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ArrayTypesMock' or use 'dummy(ArrayTypes.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ArrayTypes.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeGenericConformingConstraintsProtocol

public final class AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>: MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol, Mockingbird.Mock, AssociatedTypeGenericConformingConstraintsProtocolAbstractMockType where ConformingType.EquatableType: MockingbirdTestsHost.EquatableConformingProtocol, ConformingType.HashableType: MockingbirdTestsHost.HashableConformingProtocol {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ConformingType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericConformingConstraintsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`object`: ConformingType)

  public func `request`(`object`: ConformingType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConformingType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ConformingType) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> ConformingType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConformingType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConformingType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConformingType) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeGenericConformingConstraintsProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol`.
public func mock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>(_ type: AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericConformingConstraintsProtocolAbstractMockType {
  return AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol`.
public func mock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol, __ReturnType: AssociatedTypeGenericConformingConstraintsProtocolAbstractMockType>(_ type: AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol`.
public func dummy<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>(_ type: AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType> {
  return AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>' or use 'dummy(AssociatedTypeGenericConformingConstraintsProtocol.self)' to create a non-mockable dummy object")
public func mock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol, __ReturnType>(_ type: AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeGenericConstraintsProtocol

public final class AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>: MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol, Mockingbird.Mock, AssociatedTypeGenericConstraintsProtocolAbstractMockType where ConstrainedType.EquatableType == Int, ConstrainedType.HashableType == String {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ConstrainedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericConstraintsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`object`: ConstrainedType)

  public func `request`(`object`: ConstrainedType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConstrainedType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ConstrainedType) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> ConstrainedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConstrainedType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConstrainedType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConstrainedType) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeGenericConstraintsProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol`.
public func mock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>(_ type: AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericConstraintsProtocolAbstractMockType {
  return AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol`.
public func mock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol, __ReturnType: AssociatedTypeGenericConstraintsProtocolAbstractMockType>(_ type: AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol`.
public func dummy<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>(_ type: AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType> {
  return AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>' or use 'dummy(AssociatedTypeGenericConstraintsProtocol.self)' to create a non-mockable dummy object")
public func mock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol, __ReturnType>(_ type: AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeGenericImplementer

public final class AssociatedTypeGenericImplementerMock<EquatableType: Swift.Equatable, S: Sequence>: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, Mockingbird.Mock, AssociatedTypeGenericImplementerAbstractMockType where S.Element == EquatableType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(S.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericImplementerMock<EquatableType: Swift.Equatable, S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked equatableTypeVariable

  override public var `equatableTypeVariable`: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
  }

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodUsingEquatableType`(`equatable`: EquatableType)

  public override func `methodUsingEquatableType`(`equatable`: EquatableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodUsingEquatableType`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType)

  public override func `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  public func `methodUsingEquatableTypeWithReturn`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType)

  public override func `methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodUsingHashableType`(`hashable`: @escaping @autoclosure () -> MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hashable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeGenericImplementerAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>`.
public func mock<EquatableType: Swift.Equatable, S: Sequence>(_ type: AssociatedTypeGenericImplementerMock<EquatableType, S>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericImplementerAbstractMockType {
  return AssociatedTypeGenericImplementerMock<EquatableType, S>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>`.
public func mock<EquatableType: Swift.Equatable, S: Sequence, __ReturnType: AssociatedTypeGenericImplementerAbstractMockType>(_ type: AssociatedTypeGenericImplementerMock<EquatableType, S>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeGenericImplementerMock<EquatableType, S>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>`.
public func dummy<EquatableType: Swift.Equatable, S: Sequence>(_ type: AssociatedTypeGenericImplementerMock<EquatableType, S>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericImplementerMock<EquatableType, S> {
  return AssociatedTypeGenericImplementerMock<EquatableType, S>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeGenericImplementerMock<EquatableType, S>' or use 'dummy(AssociatedTypeGenericImplementer<EquatableType, S>.self)' to create a non-mockable dummy object")
public func mock<EquatableType: Swift.Equatable, S: Sequence, __ReturnType>(_ type: AssociatedTypeGenericImplementerMock<EquatableType, S>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeImplementerProtocol

public final class AssociatedTypeImplementerProtocolMock: MockingbirdTestsHost.AssociatedTypeImplementerProtocol, Mockingbird.Mock, AssociatedTypeImplementerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeImplementerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeImplementerProtocol`.
public func mock(_ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeImplementerProtocolAbstractMockType {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeImplementerProtocol`.
public func mock<__ReturnType: AssociatedTypeImplementerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeImplementerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeImplementerProtocolMock {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeImplementerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeImplementerProtocolMock' or use 'dummy(AssociatedTypeImplementerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeImplementer

public final class AssociatedTypeImplementerMock: MockingbirdTestsHost.AssociatedTypeImplementer, Mockingbird.Mock, AssociatedTypeImplementerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public override func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeImplementerAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeImplementer`.
public func mock(_ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeImplementerAbstractMockType {
  return AssociatedTypeImplementerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeImplementer`.
public func mock<__ReturnType: AssociatedTypeImplementerAbstractMockType>(_ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeImplementerMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeImplementer`.
public func dummy(_ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeImplementerMock {
  return AssociatedTypeImplementerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeImplementer`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeImplementerMock' or use 'dummy(AssociatedTypeImplementer.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeProtocol

public final class AssociatedTypeProtocolMock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>: MockingbirdTestsHost.AssociatedTypeProtocol, Mockingbird.Mock, AssociatedTypeProtocolAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(HashableType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeProtocolMock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked equatableTypeVariable

  public var `equatableTypeVariable`: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
  }

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked equatableTypeVariable

  public class var `equatableTypeVariable`: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
  }

  public class func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodUsingEquatableType`(`equatable`: EquatableType)

  public func `methodUsingEquatableType`(`equatable`: EquatableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodUsingEquatableType`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType)

  public func `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  public func `methodUsingEquatableTypeWithReturn`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType)

  public static func `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  public static func `methodUsingEquatableTypeWithReturn`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `methodUsingHashableType`(`hashable`: HashableType)

  public func `methodUsingHashableType`(`hashable`: HashableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: HashableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodUsingHashableType`(`hashable`: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hashable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: HashableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeProtocol`.
public func mock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>(_ type: AssociatedTypeProtocolMock<EquatableType, HashableType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeProtocolAbstractMockType {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeProtocol`.
public func mock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable, __ReturnType: AssociatedTypeProtocolAbstractMockType>(_ type: AssociatedTypeProtocolMock<EquatableType, HashableType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeProtocol`.
public func dummy<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>(_ type: AssociatedTypeProtocolMock<EquatableType, HashableType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeProtocolMock<EquatableType, HashableType> {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeProtocolMock<EquatableType, HashableType>' or use 'dummy(AssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable, __ReturnType>(_ type: AssociatedTypeProtocolMock<EquatableType, HashableType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked AssociatedTypeSelfReferencingProtocol

public final class AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, Mockingbird.Mock, AssociatedTypeSelfReferencingProtocolAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(SequenceType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeSelfReferencingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SequenceType) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: AssociatedTypeSelfReferencingProtocolMock)

  public func `request`(`object`: AssociatedTypeSelfReferencingProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: AssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AssociatedTypeSelfReferencingProtocolMock) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> AssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AssociatedTypeSelfReferencingProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: AssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AssociatedTypeSelfReferencingProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol AssociatedTypeSelfReferencingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable>(_ type: AssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeSelfReferencingProtocolAbstractMockType {
  return AssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable, __ReturnType: AssociatedTypeSelfReferencingProtocolAbstractMockType>(_ type: AssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return AssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol`.
public func dummy<SequenceType: Sequence & Swift.Hashable>(_ type: AssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeSelfReferencingProtocolMock<SequenceType> {
  return AssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'AssociatedTypeSelfReferencingProtocolMock<SequenceType>' or use 'dummy(AssociatedTypeSelfReferencingProtocol.self)' to create a non-mockable dummy object")
public func mock<SequenceType: Sequence & Swift.Hashable, __ReturnType>(_ type: AssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked BaseProtocol

public final class BaseProtocolMock: MockingbirdTestsHost.BaseProtocol, Mockingbird.Mock, BaseProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BaseProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock)

  public static func ==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (BaseProtocolMock, BaseProtocolMock) -> Bool {
      return concreteImplementation(`lhs`, `rhs`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> BaseProtocolMock, _ `rhs`: @escaping @autoclosure () -> BaseProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (BaseProtocolMock, BaseProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (BaseProtocolMock, BaseProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }
}

public protocol BaseProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.BaseProtocol`.
public func mock(_ type: BaseProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> BaseProtocolAbstractMockType {
  return BaseProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.BaseProtocol`.
public func mock<__ReturnType: BaseProtocolAbstractMockType>(_ type: BaseProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return BaseProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.BaseProtocol`.
public func dummy(_ type: BaseProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> BaseProtocolMock {
  return BaseProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.BaseProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'BaseProtocolMock' or use 'dummy(BaseProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: BaseProtocolMock.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked CascadingIncludedSource

public final class CascadingIncludedSourceMock: MockingbirdTestsHost.CascadingIncludedSource, Mockingbird.Mock, CascadingIncludedSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CascadingIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol CascadingIncludedSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.CascadingIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.CascadingIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> CascadingIncludedSourceAbstractMockType {
  return CascadingIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CascadingIncludedSource`.
public func mock<__ReturnType: CascadingIncludedSourceAbstractMockType>(_ type: MockingbirdTestsHost.CascadingIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return CascadingIncludedSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.CascadingIncludedSource`.
public func dummy(_ type: MockingbirdTestsHost.CascadingIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> CascadingIncludedSourceMock {
  return CascadingIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CascadingIncludedSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'CascadingIncludedSourceMock' or use 'dummy(CascadingIncludedSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.CascadingIncludedSource.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, Mockingbird.Mock, ChildProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

public protocol ChildProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ChildProtocol`.
public func mock(_ type: MockingbirdTestsHost.ChildProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ChildProtocolAbstractMockType {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ChildProtocol`.
public func mock<__ReturnType: ChildProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ChildProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ChildProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ChildProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ChildProtocolMock {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ChildProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ChildProtocolMock' or use 'dummy(ChildProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ChildProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, Mockingbird.Mock, ChildAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childClassVariable

  override public class var `childClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childComputedInstanceVariable

  override public var `childComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredFileprivateSetterInstanceVariable

  override public var `childStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredInstanceVariable

  override public var `childStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredPrivateSetterInstanceVariable

  override public var `childStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentClassVariable

  override public class var `parentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentComputedInstanceVariable

  override public var `parentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredFileprivateSetterInstanceVariable

  override public var `parentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredInstanceVariable

  override public var `parentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredPrivateSetterInstanceVariable

  override public var `parentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `childParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialClassMethod`()

  public override static func `childTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `childTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public override func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod`()

  public override static func `parentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public override func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol ChildAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.Child`.
public func mock(_ type: MockingbirdTestsHost.Child.Type, file: StaticString = #file, line: UInt = #line) -> ChildAbstractMockType {
  return ChildMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.Child`.
public func mock<__ReturnType: ChildAbstractMockType>(_ type: MockingbirdTestsHost.Child.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ChildMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.Child`.
public func dummy(_ type: MockingbirdTestsHost.Child.Type, file: StaticString = #file, line: UInt = #line) -> ChildMock {
  return ChildMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.Child`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ChildMock' or use 'dummy(Child.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.Child.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ClassOnlyProtocolWithInheritance

public final class ClassOnlyProtocolWithInheritanceMock: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance, Mockingbird.Mock, ClassOnlyProtocolWithInheritanceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassOnlyProtocolWithInheritanceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

public protocol ClassOnlyProtocolWithInheritanceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocolWithInheritance`.
public func mock(_ type: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> ClassOnlyProtocolWithInheritanceAbstractMockType {
  return ClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocolWithInheritance`.
public func mock<__ReturnType: ClassOnlyProtocolWithInheritanceAbstractMockType>(_ type: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ClassOnlyProtocolWithInheritance`.
public func dummy(_ type: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> ClassOnlyProtocolWithInheritanceMock {
  return ClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocolWithInheritance`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ClassOnlyProtocolWithInheritanceMock' or use 'dummy(ClassOnlyProtocolWithInheritance.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ClassOnlyProtocol

public final class ClassOnlyProtocolMock: MockingbirdTestsHost.ClassOnlyProtocol, Mockingbird.Mock, ClassOnlyProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassOnlyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ClassOnlyProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocol`.
public func mock(_ type: MockingbirdTestsHost.ClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ClassOnlyProtocolAbstractMockType {
  return ClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocol`.
public func mock<__ReturnType: ClassOnlyProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ClassOnlyProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ClassOnlyProtocolMock {
  return ClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ClassOnlyProtocolMock' or use 'dummy(ClassOnlyProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ClassOnlyProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ClassType

public final class ClassTypeMock: MockingbirdTestsHost.ClassType, Mockingbird.Mock, ClassTypeAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ClassTypeAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ClassType`.
public func mock(_ type: MockingbirdTestsHost.ClassType.Type, file: StaticString = #file, line: UInt = #line) -> ClassTypeAbstractMockType {
  return ClassTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ClassType`.
public func mock<__ReturnType: ClassTypeAbstractMockType>(_ type: MockingbirdTestsHost.ClassType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ClassTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ClassType`.
public func dummy(_ type: MockingbirdTestsHost.ClassType.Type, file: StaticString = #file, line: UInt = #line) -> ClassTypeMock {
  return ClassTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ClassType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ClassTypeMock' or use 'dummy(ClassType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ClassType.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ClassWithDesignatedInitializer

public final class ClassWithDesignatedInitializerMock: MockingbirdTestsHost.ClassWithDesignatedInitializer, Mockingbird.Mock, ClassWithDesignatedInitializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassWithDesignatedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      @available(*, deprecated, message: "This class initializer is deprecated")
      public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerMock {
        let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param1: `param1`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerMock {
        let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerMock {
        let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    @available(*, deprecated, message: "This class initializer is deprecated")
    public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerAbstractMockType {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    @available(*, deprecated, message: "This class initializer is deprecated")
    public func initialize<__ReturnType: ClassWithDesignatedInitializerAbstractMockType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ClassWithDesignatedInitializerMock' or use 'dummy(ClassWithDesignatedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    @available(*, deprecated, message: "This class initializer is deprecated")
    public func initialize<__ReturnType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerAbstractMockType {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ClassWithDesignatedInitializerAbstractMockType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ClassWithDesignatedInitializerMock' or use 'dummy(ClassWithDesignatedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerAbstractMockType {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ClassWithDesignatedInitializerAbstractMockType>(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ClassWithDesignatedInitializerMock' or use 'dummy(ClassWithDesignatedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`param1`: Bool)

  @available(*, deprecated, message: "This class initializer is deprecated")
  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: Bool)

  public required init(`param`: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: Int)

  public required override init(`param`: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ClassWithDesignatedInitializerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ClassWithDesignatedInitializer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ClassWithDesignatedInitializerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ClassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ClassWithDesignatedInitializerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ClassWithDesignatedInitializer`.
public func mock<__ReturnType: ClassWithDesignatedInitializerMock.InitializerProxy>(_ type: MockingbirdTestsHost.ClassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ClassWithDesignatedInitializerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ClassWithDesignatedInitializer`.
public func dummy(_ type: MockingbirdTestsHost.ClassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> ClassWithDesignatedInitializerMock.InitializerProxy.Dummy {
  return ClassWithDesignatedInitializerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ClassWithDesignatedInitializer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ClassWithDesignatedInitializerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ClassWithDesignatedInitializer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ClassWithoutDesignatedInitializer

public final class ClassWithoutDesignatedInitializerMock: MockingbirdTestsHost.ClassWithoutDesignatedInitializer, Mockingbird.Mock, ClassWithoutDesignatedInitializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassWithoutDesignatedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ClassWithoutDesignatedInitializerAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ClassWithoutDesignatedInitializer`.
public func mock(_ type: MockingbirdTestsHost.ClassWithoutDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> ClassWithoutDesignatedInitializerAbstractMockType {
  return ClassWithoutDesignatedInitializerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ClassWithoutDesignatedInitializer`.
public func mock<__ReturnType: ClassWithoutDesignatedInitializerAbstractMockType>(_ type: MockingbirdTestsHost.ClassWithoutDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ClassWithoutDesignatedInitializerMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ClassWithoutDesignatedInitializer`.
public func dummy(_ type: MockingbirdTestsHost.ClassWithoutDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> ClassWithoutDesignatedInitializerMock {
  return ClassWithoutDesignatedInitializerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ClassWithoutDesignatedInitializer`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ClassWithoutDesignatedInitializerMock' or use 'dummy(ClassWithoutDesignatedInitializer.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ClassWithoutDesignatedInitializer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ClosureParametersProtocol

public final class ClosureParametersProtocolMock: MockingbirdTestsHost.ClosureParametersProtocol, Mockingbird.Mock, ClosureParametersProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClosureParametersProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `autoclosureTrivialClosure`(`block`: @autoclosure () -> Void)

  public func `autoclosureTrivialClosure`(`block`: @autoclosure () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialClosure`(`block`: @autoclosure () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `autoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialClosure`(`block`: @autoclosure () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool)

  public func `autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `autoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void)

  public func `escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool)

  public func `escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void)

  public func `escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `escapingParameterizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool)

  public func `escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `escapingParameterizedReturningClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingTrivialClosure`(`block`: @escaping () -> Void)

  public func `escapingTrivialClosure`(`block`: @escaping () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialClosure`(`block`: @escaping () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `escapingTrivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialClosure`(`block`: @escaping () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingTrivialReturningClosure`(`block`: @escaping () -> Bool)

  public func `escapingTrivialReturningClosure`(`block`: @escaping () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialReturningClosure`(`block`: @escaping () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `escapingTrivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialReturningClosure`(`block`: @escaping () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool))

  public func `implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool)) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool)) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((a: () -> Void, b: (Bool) -> Bool)) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `implicitEscapingMultipleLabeledTupleClosure`(`block`: @escaping @autoclosure () -> (a: () -> Void, b: (Bool) -> Bool)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: () -> Void, b: (Bool) -> Bool)) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool)) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: () -> Void, b: (Bool) -> Bool)) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool))

  public func `implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool)) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool)) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((() -> Void, (Bool) -> Bool)) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `implicitEscapingMultipleTupleClosure`(`block`: @escaping @autoclosure () -> (() -> Void, (Bool) -> Bool)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void, (Bool) -> Bool)) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool)) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void, (Bool) -> Bool)) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?)

  public func `implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (((Bool) -> Void)?) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `implicitEscapingParameterizedClosure`(`block`: @escaping @autoclosure () -> ((Bool) -> Void)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Void)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Void)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?)

  public func `implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (((Bool) -> Bool)?) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `implicitEscapingParameterizedReturningClosure`(`block`: @escaping @autoclosure () -> ((Bool) -> Bool)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Bool)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Bool)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingTrivialClosure`(`block`: (() -> Void)?)

  public func `implicitEscapingTrivialClosure`(`block`: (() -> Void)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialClosure`(`block`: (() -> Void)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((() -> Void)?) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `implicitEscapingTrivialClosure`(`block`: @escaping @autoclosure () -> (() -> Void)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialClosure`(`block`: (() -> Void)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?)

  public func `implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((() -> Bool)?) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `implicitEscapingTrivialReturningClosure`(`block`: @escaping @autoclosure () -> (() -> Bool)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Bool)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Bool)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??)

  public func `nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((() -> Void)??) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `nestedOptionalTrivialParenthesizedClosure`(`block`: @escaping @autoclosure () -> (() -> Void)??) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)??) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)??) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool)

  public func `nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `nestedParameterizedReturningParenthesizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedClosure`(`block`: (Bool) -> Void)

  public func `parameterizedClosure`(`block`: (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parameterizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedParenthesizedClosure`(`block`: (Bool) -> Void)

  public func `parameterizedParenthesizedClosure`(`block`: (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedParenthesizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parameterizedParenthesizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedParenthesizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningClosure`(`block`: (Bool) -> Bool)

  public func `parameterizedReturningClosure`(`block`: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parameterizedReturningClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool)

  public func `parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parameterizedReturningParenthesizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialClosure`(`block`: () -> Void)

  public func `trivialClosure`(`block`: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialClosure`(`block`: () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `trivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialClosure`(`block`: () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialParenthesizedClosure`(`block`: () -> Void)

  public func `trivialParenthesizedClosure`(`block`: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `trivialParenthesizedClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialReturningClosure`(`block`: () -> Bool)

  public func `trivialReturningClosure`(`block`: () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningClosure`(`block`: () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `trivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningClosure`(`block`: () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialReturningParenthesizedClosure`(`block`: () -> Void)

  public func `trivialReturningParenthesizedClosure`(`block`: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `trivialReturningParenthesizedClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper)

  public func `wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.ClosureWrapper) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `wrappedClosureParameter`(`block`: @escaping @autoclosure () -> MockingbirdTestsHost.ClosureWrapper) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClosureWrapper) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClosureWrapper) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol ClosureParametersProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClosureParametersProtocol`.
public func mock(_ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ClosureParametersProtocolAbstractMockType {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClosureParametersProtocol`.
public func mock<__ReturnType: ClosureParametersProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ClosureParametersProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ClosureParametersProtocolMock {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClosureParametersProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ClosureParametersProtocolMock' or use 'dummy(ClosureParametersProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked CodableConformingClass

public final class CodableConformingClassMock: MockingbirdTestsHost.CodableConformingClass, Mockingbird.Mock, CodableConformingClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CodableConformingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`from` `decoder`: Decoder, __file: StaticString = #file, __line: UInt = #line) throws -> CodableConformingClassMock {
        let mock: CodableConformingClassMock = try CodableConformingClassMock(from: `decoder`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`from` `decoder`: Decoder, __file: StaticString = #file, __line: UInt = #line) throws -> CodableConformingClassAbstractMockType {
      let mock: CodableConformingClassMock = try CodableConformingClassMock(from: `decoder`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: CodableConformingClassAbstractMockType>(`from` `decoder`: Decoder, __file: StaticString = #file, __line: UInt = #line) throws -> __ReturnType {
      let mock: CodableConformingClassMock = try CodableConformingClassMock(from: `decoder`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'CodableConformingClassMock' or use 'dummy(CodableConformingClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`from` `decoder`: Decoder, __file: StaticString = #file, __line: UInt = #line) throws -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws {
    try super.init(from: `decoder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`from` `decoder`: Decoder) throws ", arguments: [Mockingbird.ArgumentMatcher(`decoder`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol CodableConformingClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.CodableConformingClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(CodableConformingClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.CodableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return CodableConformingClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.CodableConformingClass`.
public func mock<__ReturnType: CodableConformingClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.CodableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return CodableConformingClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.CodableConformingClass`.
public func dummy(_ type: MockingbirdTestsHost.CodableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> CodableConformingClassMock.InitializerProxy.Dummy {
  return CodableConformingClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.CodableConformingClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(CodableConformingClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.CodableConformingClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked CodableConformingProtocol

public final class CodableConformingProtocolMock: MockingbirdTestsHost.CodableConformingProtocol, Mockingbird.Mock, CodableConformingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CodableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `encode`(`to` `encoder`: Encoder)

  public func `encode`(`to` `encoder`: Encoder) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(`encoder`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Encoder) throws -> Void {
      try concreteImplementation(`encoder`)
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `encode`(`to` `encoder`: @escaping @autoclosure () -> Encoder) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`encoder`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`from` `decoder`: Decoder) throws ", arguments: [Mockingbird.ArgumentMatcher(`decoder`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol CodableConformingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.CodableConformingProtocol`.
public func mock(_ type: MockingbirdTestsHost.CodableConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CodableConformingProtocolAbstractMockType {
  return CodableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CodableConformingProtocol`.
public func mock<__ReturnType: CodableConformingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.CodableConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return CodableConformingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.CodableConformingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.CodableConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CodableConformingProtocolMock {
  return CodableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CodableConformingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'CodableConformingProtocolMock' or use 'dummy(CodableConformingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.CodableConformingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked CommentBlockNotDebugCompilationDirectiveProtocol

public final class CommentBlockNotDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol, Mockingbird.Mock, CommentBlockNotDebugCompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CommentBlockNotDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol CommentBlockNotDebugCompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CommentBlockNotDebugCompilationDirectiveProtocolAbstractMockType {
  return CommentBlockNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol`.
public func mock<__ReturnType: CommentBlockNotDebugCompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return CommentBlockNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CommentBlockNotDebugCompilationDirectiveProtocolMock {
  return CommentBlockNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'CommentBlockNotDebugCompilationDirectiveProtocolMock' or use 'dummy(CommentBlockNotDebugCompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked CompilationDirectiveProtocol

public final class CompilationDirectiveProtocolMock: MockingbirdTestsHost.CompilationDirectiveProtocol, Mockingbird.Mock, CompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG

  // MARK: Mocked debugVariable

  public var `debugVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "debugVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getDebugVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "debugVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if DEBUG
  #if !(!(DEBUG))

  // MARK: Mocked nestedVariable

  public var `nestedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getNestedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if !(DEBUG)

  // MARK: Mocked notDebugVariable

  public var `notDebugVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "notDebugVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getNotDebugVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "notDebugVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if DEBUG

  // MARK: Mocked onlyDebugVariable

  public var `onlyDebugVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "onlyDebugVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getOnlyDebugVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "onlyDebugVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  #if DEBUG

  // MARK: Mocked `debugMethod`()

  public func `debugMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debugMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `debugMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debugMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif

  // MARK: Mocked `method`()

  public func `method`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #if DEBUG
  #if !(!(DEBUG))

  // MARK: Mocked `nestedMethod`()

  public func `nestedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `nestedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if !(DEBUG)

  // MARK: Mocked `notDebugMethod`()

  public func `notDebugMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`notDebugMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `notDebugMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`notDebugMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif

  #if DEBUG

  // MARK: Mocked `onlyDebugMethod`()

  public func `onlyDebugMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onlyDebugMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onlyDebugMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onlyDebugMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif
}

public protocol CompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.CompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.CompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CompilationDirectiveProtocolAbstractMockType {
  return CompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CompilationDirectiveProtocol`.
public func mock<__ReturnType: CompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.CompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return CompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.CompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.CompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CompilationDirectiveProtocolMock {
  return CompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'CompilationDirectiveProtocolMock' or use 'dummy(CompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.CompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ConformingExternalClassConstrainedProtocol

public final class ConformingExternalClassConstrainedProtocolMock: AppKit.NSViewController, MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol, Mockingbird.Mock, ConformingExternalClassConstrainedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConformingExternalClassConstrainedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> ConformingExternalClassConstrainedProtocolMock? {
        let mock: ConformingExternalClassConstrainedProtocolMock? = ConformingExternalClassConstrainedProtocolMock(coder: `coder`)
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> ConformingExternalClassConstrainedProtocolMock {
        let mock: ConformingExternalClassConstrainedProtocolMock = ConformingExternalClassConstrainedProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> ConformingExternalClassConstrainedProtocolAbstractMockType? {
      let mock: ConformingExternalClassConstrainedProtocolMock? = ConformingExternalClassConstrainedProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ConformingExternalClassConstrainedProtocolAbstractMockType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: ConformingExternalClassConstrainedProtocolMock? = ConformingExternalClassConstrainedProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ConformingExternalClassConstrainedProtocolMock' or use 'dummy(ConformingExternalClassConstrainedProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }

    public func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> ConformingExternalClassConstrainedProtocolAbstractMockType {
      let mock: ConformingExternalClassConstrainedProtocolMock = ConformingExternalClassConstrainedProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ConformingExternalClassConstrainedProtocolAbstractMockType>(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ConformingExternalClassConstrainedProtocolMock = ConformingExternalClassConstrainedProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ConformingExternalClassConstrainedProtocolMock' or use 'dummy(ConformingExternalClassConstrainedProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ConformingExternalClassConstrainedProtocolAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ConformingExternalClassConstrainedProtocolMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ConformingExternalClassConstrainedProtocolMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol`.
public func mock<__ReturnType: ConformingExternalClassConstrainedProtocolMock.InitializerProxy>(_ type: MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ConformingExternalClassConstrainedProtocolMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ConformingExternalClassConstrainedProtocolMock.InitializerProxy.Dummy {
  return ConformingExternalClassConstrainedProtocolMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ConformingExternalClassConstrainedProtocolMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ConformingInitializableOpenClassConstrainedProtocol

public final class ConformingInitializableOpenClassConstrainedProtocolMock: MockingbirdModuleTestsHost.InitializableOpenClass, MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol, Mockingbird.Mock, ConformingInitializableOpenClassConstrainedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConformingInitializableOpenClassConstrainedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> ConformingInitializableOpenClassConstrainedProtocolMock {
        let mock: ConformingInitializableOpenClassConstrainedProtocolMock = ConformingInitializableOpenClassConstrainedProtocolMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> ConformingInitializableOpenClassConstrainedProtocolAbstractMockType {
      let mock: ConformingInitializableOpenClassConstrainedProtocolMock = ConformingInitializableOpenClassConstrainedProtocolMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ConformingInitializableOpenClassConstrainedProtocolAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ConformingInitializableOpenClassConstrainedProtocolMock = ConformingInitializableOpenClassConstrainedProtocolMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ConformingInitializableOpenClassConstrainedProtocolMock' or use 'dummy(ConformingInitializableOpenClassConstrainedProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ConformingInitializableOpenClassConstrainedProtocolAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ConformingInitializableOpenClassConstrainedProtocolMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol`.
public func mock<__ReturnType: ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy>(_ type: MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy.Dummy {
  return ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ConformingInitializableOpenClassConstrainedProtocolMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ConformingUninitializableOpenClassConstrainedProtocol

public final class ConformingUninitializableOpenClassConstrainedProtocolMock: MockingbirdModuleTestsHost.OpenClass, MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol, Mockingbird.Mock, ConformingUninitializableOpenClassConstrainedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConformingUninitializableOpenClassConstrainedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    public class Dummy: Mockingbird.Initializable {}
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol ConformingUninitializableOpenClassConstrainedProtocolAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ConformingUninitializableOpenClassConstrainedProtocolMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol`.
public func mock<__ReturnType: ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy>(_ type: MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy.Dummy {
  return ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ConformingUninitializableOpenClassConstrainedProtocolMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ConstrainedUnspecializedGenericSubclass

public final class ConstrainedUnspecializedGenericSubclassMock<T: Swift.Equatable>: MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>, Mockingbird.Mock, ConstrainedUnspecializedGenericSubclassAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "ConstrainedUnspecializedGenericSubclassMock<T: Swift.Equatable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConstrainedUnspecializedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> T)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

public protocol ConstrainedUnspecializedGenericSubclassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>`.
public func mock<T: Swift.Equatable>(_ type: ConstrainedUnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> ConstrainedUnspecializedGenericSubclassAbstractMockType {
  return ConstrainedUnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>`.
public func mock<T: Swift.Equatable, __ReturnType: ConstrainedUnspecializedGenericSubclassAbstractMockType>(_ type: ConstrainedUnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ConstrainedUnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>`.
public func dummy<T: Swift.Equatable>(_ type: ConstrainedUnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> ConstrainedUnspecializedGenericSubclassMock<T> {
  return ConstrainedUnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ConstrainedUnspecializedGenericSubclassMock<T>' or use 'dummy(ConstrainedUnspecializedGenericSubclass<T>.self)' to create a non-mockable dummy object")
public func mock<T: Swift.Equatable, __ReturnType>(_ type: ConstrainedUnspecializedGenericSubclassMock<T>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ConvenienceInitializerClass

public final class ConvenienceInitializerClassMock: MockingbirdTestsHost.ConvenienceInitializerClass, Mockingbird.Mock, ConvenienceInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConvenienceInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> ConvenienceInitializerClassMock {
        let mock: ConvenienceInitializerClassMock = ConvenienceInitializerClassMock(param1: `param1`, param2: `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> ConvenienceInitializerClassAbstractMockType {
      let mock: ConvenienceInitializerClassMock = ConvenienceInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ConvenienceInitializerClassAbstractMockType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ConvenienceInitializerClassMock = ConvenienceInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ConvenienceInitializerClassMock' or use 'dummy(ConvenienceInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required override init(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ConvenienceInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConvenienceInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ConvenienceInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ConvenienceInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConvenienceInitializerClass`.
public func mock<__ReturnType: ConvenienceInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ConvenienceInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ConvenienceInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> ConvenienceInitializerClassMock.InitializerProxy.Dummy {
  return ConvenienceInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConvenienceInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ConvenienceInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked DebugCompilationDirectiveProtocol

#if DEBUG

public final class DebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.DebugCompilationDirectiveProtocol, Mockingbird.Mock, DebugCompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if DEBUG

public protocol DebugCompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.DebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DebugCompilationDirectiveProtocolAbstractMockType {
  return DebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DebugCompilationDirectiveProtocol`.
public func mock<__ReturnType: DebugCompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.DebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DebugCompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.DebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DebugCompilationDirectiveProtocolMock {
  return DebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DebugCompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DebugCompilationDirectiveProtocolMock' or use 'dummy(DebugCompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DebugCompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

#endif

// MARK: - Mocked DeclarationAttributesClass

public final class DeclarationAttributesClassMock: MockingbirdTestsHost.DeclarationAttributesClass, Mockingbird.Mock, DeclarationAttributesClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeclarationAttributesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked availableVariable

  @available(iOS 10.0, *)
  override public var `availableVariable`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  @available(iOS 10.0, *)
  public func getAvailableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `availableMethod`(`param`: String)

  @available(iOS 10.0, *)
  public override func `availableMethod`(`param`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  @available(iOS 10.0, *)
  public func `availableMethod`(`param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `multipleAttributesMethod`(`param`: String)

  @available(iOS 10.0, *)
  public override func `multipleAttributesMethod`(`param`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`multipleAttributesMethod`(`param`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  @available(iOS 10.0, *)
  public func `multipleAttributesMethod`(`param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`multipleAttributesMethod`(`param`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol DeclarationAttributesClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.DeclarationAttributesClass`.
public func mock(_ type: MockingbirdTestsHost.DeclarationAttributesClass.Type, file: StaticString = #file, line: UInt = #line) -> DeclarationAttributesClassAbstractMockType {
  return DeclarationAttributesClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.DeclarationAttributesClass`.
public func mock<__ReturnType: DeclarationAttributesClassAbstractMockType>(_ type: MockingbirdTestsHost.DeclarationAttributesClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DeclarationAttributesClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DeclarationAttributesClass`.
public func dummy(_ type: MockingbirdTestsHost.DeclarationAttributesClass.Type, file: StaticString = #file, line: UInt = #line) -> DeclarationAttributesClassMock {
  return DeclarationAttributesClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.DeclarationAttributesClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DeclarationAttributesClassMock' or use 'dummy(DeclarationAttributesClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DeclarationAttributesClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked DeclarationAttributesProtocol

public final class DeclarationAttributesProtocolMock: MockingbirdTestsHost.DeclarationAttributesProtocol, Mockingbird.Mock, DeclarationAttributesProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeclarationAttributesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked availableVariable

  @available(iOS 10.0, *)
  public var `availableVariable`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  @available(iOS 10.0, *)
  public func getAvailableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `availableMethod`(`param`: String)

  @available(iOS 10.0, *)
  public func `availableMethod`(`param`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  @available(iOS 10.0, *)
  public func `availableMethod`(`param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol DeclarationAttributesProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeclarationAttributesProtocol`.
public func mock(_ type: MockingbirdTestsHost.DeclarationAttributesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DeclarationAttributesProtocolAbstractMockType {
  return DeclarationAttributesProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeclarationAttributesProtocol`.
public func mock<__ReturnType: DeclarationAttributesProtocolAbstractMockType>(_ type: MockingbirdTestsHost.DeclarationAttributesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DeclarationAttributesProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DeclarationAttributesProtocol`.
public func dummy(_ type: MockingbirdTestsHost.DeclarationAttributesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DeclarationAttributesProtocolMock {
  return DeclarationAttributesProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeclarationAttributesProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DeclarationAttributesProtocolMock' or use 'dummy(DeclarationAttributesProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DeclarationAttributesProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked DefaultArgumentValuesClass

public final class DefaultArgumentValuesClassMock: MockingbirdTestsHost.DefaultArgumentValuesClass, Mockingbird.Mock, DefaultArgumentValuesClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject])

  public override func `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> String, `param2`: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol DefaultArgumentValuesClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.DefaultArgumentValuesClass`.
public func mock(_ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type, file: StaticString = #file, line: UInt = #line) -> DefaultArgumentValuesClassAbstractMockType {
  return DefaultArgumentValuesClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.DefaultArgumentValuesClass`.
public func mock<__ReturnType: DefaultArgumentValuesClassAbstractMockType>(_ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DefaultArgumentValuesClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DefaultArgumentValuesClass`.
public func dummy(_ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type, file: StaticString = #file, line: UInt = #line) -> DefaultArgumentValuesClassMock {
  return DefaultArgumentValuesClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.DefaultArgumentValuesClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DefaultArgumentValuesClassMock' or use 'dummy(DefaultArgumentValuesClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked DefaultArgumentValuesProtocol

public final class DefaultArgumentValuesProtocolMock: MockingbirdTestsHost.DefaultArgumentValuesProtocol, Mockingbird.Mock, DefaultArgumentValuesProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject])

  public func `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> String, `param2`: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol DefaultArgumentValuesProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DefaultArgumentValuesProtocol`.
public func mock(_ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DefaultArgumentValuesProtocolAbstractMockType {
  return DefaultArgumentValuesProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DefaultArgumentValuesProtocol`.
public func mock<__ReturnType: DefaultArgumentValuesProtocolAbstractMockType>(_ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DefaultArgumentValuesProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DefaultArgumentValuesProtocol`.
public func dummy(_ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DefaultArgumentValuesProtocolMock {
  return DefaultArgumentValuesProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DefaultArgumentValuesProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DefaultArgumentValuesProtocolMock' or use 'dummy(DefaultArgumentValuesProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked DeprecatedClassOnlyProtocolWithInheritance

public final class DeprecatedClassOnlyProtocolWithInheritanceMock: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance, Mockingbird.Mock, DeprecatedClassOnlyProtocolWithInheritanceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeprecatedClassOnlyProtocolWithInheritanceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

public protocol DeprecatedClassOnlyProtocolWithInheritanceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance`.
public func mock(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> DeprecatedClassOnlyProtocolWithInheritanceAbstractMockType {
  return DeprecatedClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance`.
public func mock<__ReturnType: DeprecatedClassOnlyProtocolWithInheritanceAbstractMockType>(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DeprecatedClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance`.
public func dummy(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> DeprecatedClassOnlyProtocolWithInheritanceMock {
  return DeprecatedClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DeprecatedClassOnlyProtocolWithInheritanceMock' or use 'dummy(DeprecatedClassOnlyProtocolWithInheritance.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked DeprecatedClassOnlyProtocol

public final class DeprecatedClassOnlyProtocolMock: MockingbirdTestsHost.DeprecatedClassOnlyProtocol, Mockingbird.Mock, DeprecatedClassOnlyProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeprecatedClassOnlyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol DeprecatedClassOnlyProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocol`.
public func mock(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DeprecatedClassOnlyProtocolAbstractMockType {
  return DeprecatedClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocol`.
public func mock<__ReturnType: DeprecatedClassOnlyProtocolAbstractMockType>(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DeprecatedClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DeprecatedClassOnlyProtocol`.
public func dummy(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DeprecatedClassOnlyProtocolMock {
  return DeprecatedClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DeprecatedClassOnlyProtocolMock' or use 'dummy(DeprecatedClassOnlyProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked DictionaryCollection

public final class DictionaryCollectionMock: MockingbirdTestsHost.DictionaryCollection, Mockingbird.Mock, DictionaryCollectionAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`objects`: [String: String])

  public func `method`(`objects`: [String: String]) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String: String]) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([String: String]) -> Bool {
      return concreteImplementation(`objects`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`(`objects`: @escaping @autoclosure () -> [String: String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String: String]) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String: String]) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String: String]) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol DictionaryCollectionAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryCollection`.
public func mock(_ type: MockingbirdTestsHost.DictionaryCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> DictionaryCollectionAbstractMockType {
  return DictionaryCollectionMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryCollection`.
public func mock<__ReturnType: DictionaryCollectionAbstractMockType>(_ type: MockingbirdTestsHost.DictionaryCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DictionaryCollectionMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DictionaryCollection`.
public func dummy(_ type: MockingbirdTestsHost.DictionaryCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> DictionaryCollectionMock {
  return DictionaryCollectionMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryCollection`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DictionaryCollectionMock' or use 'dummy(DictionaryCollection.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DictionaryCollection.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked DictionaryTypes

public final class DictionaryTypesMock: MockingbirdTestsHost.DictionaryTypes, Mockingbird.Mock, DictionaryTypesAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherVariable

  public var `anotherVariable`: [Foundation.URL: Foundation.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.URL: Foundation.NSObject])()
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitAnotherVariable

  public var `explicitAnotherVariable`: Dictionary<Foundation.URL, Foundation.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<Foundation.URL, Foundation.NSObject>)()
    }
  }

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitVariable

  public var `explicitVariable`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>)()
    }
  }

  public func getExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalAnotherVariable

  public var `optionalAnotherVariable`: [Foundation.URL: Foundation.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.URL: Foundation.NSObject?])()
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitAnotherVariable

  public var `optionalExplicitAnotherVariable`: Dictionary<Foundation.URL, Foundation.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<Foundation.URL, Foundation.NSObject?>)()
    }
  }

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitVariable

  public var `optionalExplicitVariable`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>)()
    }
  }

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?])()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject])()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Dictionary<Foundation.URL, Foundation.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Dictionary<Foundation.URL, Foundation.NSObject>)()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>)()
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>)

  public func `explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `explicitMethod`(`param1`: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethodWithParameterLabels`()

  public func `explicitMethodWithParameterLabels`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  public func `explicitMethodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [Foundation.URL: Foundation.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [Foundation.URL: Foundation.NSObject])()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject])()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject])

  public func `method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels`()

  public func `methodWithParameterLabels`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  public func `methodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }
}

public protocol DictionaryTypesAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryTypes`.
public func mock(_ type: MockingbirdTestsHost.DictionaryTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> DictionaryTypesAbstractMockType {
  return DictionaryTypesMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryTypes`.
public func mock<__ReturnType: DictionaryTypesAbstractMockType>(_ type: MockingbirdTestsHost.DictionaryTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DictionaryTypesMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DictionaryTypes`.
public func dummy(_ type: MockingbirdTestsHost.DictionaryTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> DictionaryTypesMock {
  return DictionaryTypesMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryTypes`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DictionaryTypesMock' or use 'dummy(DictionaryTypes.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DictionaryTypes.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked DirectoryNonRelativeIgnoredSource

public final class DirectoryNonRelativeIgnoredSourceMock: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource, Mockingbird.Mock, DirectoryNonRelativeIgnoredSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DirectoryNonRelativeIgnoredSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol DirectoryNonRelativeIgnoredSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource`.
public func mock(_ type: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> DirectoryNonRelativeIgnoredSourceAbstractMockType {
  return DirectoryNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource`.
public func mock<__ReturnType: DirectoryNonRelativeIgnoredSourceAbstractMockType>(_ type: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return DirectoryNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource`.
public func dummy(_ type: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> DirectoryNonRelativeIgnoredSourceMock {
  return DirectoryNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'DirectoryNonRelativeIgnoredSourceMock' or use 'dummy(DirectoryNonRelativeIgnoredSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked EmptyClass

public final class EmptyClassMock: MockingbirdTestsHost.EmptyClass, Mockingbird.Mock, EmptyClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol EmptyClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyClass`.
public func mock(_ type: MockingbirdTestsHost.EmptyClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyClassAbstractMockType {
  return EmptyClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyClass`.
public func mock<__ReturnType: EmptyClassAbstractMockType>(_ type: MockingbirdTestsHost.EmptyClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EmptyClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EmptyClass`.
public func dummy(_ type: MockingbirdTestsHost.EmptyClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyClassMock {
  return EmptyClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EmptyClassMock' or use 'dummy(EmptyClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EmptyClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked EmptyInheritingClass

public final class EmptyInheritingClassMock: MockingbirdTestsHost.EmptyInheritingClass, Mockingbird.Mock, EmptyInheritingClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInheritingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childClassVariable

  override public class var `childClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childComputedInstanceVariable

  override public var `childComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredFileprivateSetterInstanceVariable

  override public var `childStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredInstanceVariable

  override public var `childStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredPrivateSetterInstanceVariable

  override public var `childStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentClassVariable

  override public class var `parentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentComputedInstanceVariable

  override public var `parentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredFileprivateSetterInstanceVariable

  override public var `parentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredInstanceVariable

  override public var `parentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredPrivateSetterInstanceVariable

  override public var `parentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `childParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialClassMethod`()

  public override static func `childTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `childTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public override func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod`()

  public override static func `parentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public override func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol EmptyInheritingClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyInheritingClass`.
public func mock(_ type: MockingbirdTestsHost.EmptyInheritingClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyInheritingClassAbstractMockType {
  return EmptyInheritingClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyInheritingClass`.
public func mock<__ReturnType: EmptyInheritingClassAbstractMockType>(_ type: MockingbirdTestsHost.EmptyInheritingClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EmptyInheritingClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EmptyInheritingClass`.
public func dummy(_ type: MockingbirdTestsHost.EmptyInheritingClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyInheritingClassMock {
  return EmptyInheritingClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyInheritingClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EmptyInheritingClassMock' or use 'dummy(EmptyInheritingClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EmptyInheritingClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked EmptyInheritingProtocol

public final class EmptyInheritingProtocolMock: MockingbirdTestsHost.EmptyInheritingProtocol, Mockingbird.Mock, EmptyInheritingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInheritingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

public protocol EmptyInheritingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInheritingProtocol`.
public func mock(_ type: MockingbirdTestsHost.EmptyInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyInheritingProtocolAbstractMockType {
  return EmptyInheritingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInheritingProtocol`.
public func mock<__ReturnType: EmptyInheritingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.EmptyInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EmptyInheritingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EmptyInheritingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.EmptyInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyInheritingProtocolMock {
  return EmptyInheritingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInheritingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EmptyInheritingProtocolMock' or use 'dummy(EmptyInheritingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EmptyInheritingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked EmptyInitializerClass

public final class EmptyInitializerClassMock: MockingbirdTestsHost.EmptyInitializerClass, Mockingbird.Mock, EmptyInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> EmptyInitializerClassMock {
        let mock: EmptyInitializerClassMock = EmptyInitializerClassMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> EmptyInitializerClassAbstractMockType {
      let mock: EmptyInitializerClassMock = EmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: EmptyInitializerClassAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: EmptyInitializerClassMock = EmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'EmptyInitializerClassMock' or use 'dummy(EmptyInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol EmptyInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.EmptyInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(EmptyInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.EmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return EmptyInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.EmptyInitializerClass`.
public func mock<__ReturnType: EmptyInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.EmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EmptyInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EmptyInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.EmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyInitializerClassMock.InitializerProxy.Dummy {
  return EmptyInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.EmptyInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(EmptyInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EmptyInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked EmptyInitializerProtocol

public final class EmptyInitializerProtocolMock: MockingbirdTestsHost.EmptyInitializerProtocol, Mockingbird.Mock, EmptyInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init()

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol EmptyInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyInitializerProtocolAbstractMockType {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInitializerProtocol`.
public func mock<__ReturnType: EmptyInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EmptyInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyInitializerProtocolMock {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EmptyInitializerProtocolMock' or use 'dummy(EmptyInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked EmptyProtocol

public final class EmptyProtocolMock: MockingbirdTestsHost.EmptyProtocol, Mockingbird.Mock, EmptyProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol EmptyProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyProtocol`.
public func mock(_ type: MockingbirdTestsHost.EmptyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyProtocolAbstractMockType {
  return EmptyProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyProtocol`.
public func mock<__ReturnType: EmptyProtocolAbstractMockType>(_ type: MockingbirdTestsHost.EmptyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EmptyProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EmptyProtocol`.
public func dummy(_ type: MockingbirdTestsHost.EmptyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyProtocolMock {
  return EmptyProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EmptyProtocolMock' or use 'dummy(EmptyProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EmptyProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked EnclosingDirectoryOverriddenIncludedSource

public final class EnclosingDirectoryOverriddenIncludedSourceMock: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource, Mockingbird.Mock, EnclosingDirectoryOverriddenIncludedSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EnclosingDirectoryOverriddenIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol EnclosingDirectoryOverriddenIncludedSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> EnclosingDirectoryOverriddenIncludedSourceAbstractMockType {
  return EnclosingDirectoryOverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource`.
public func mock<__ReturnType: EnclosingDirectoryOverriddenIncludedSourceAbstractMockType>(_ type: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EnclosingDirectoryOverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource`.
public func dummy(_ type: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> EnclosingDirectoryOverriddenIncludedSourceMock {
  return EnclosingDirectoryOverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EnclosingDirectoryOverriddenIncludedSourceMock' or use 'dummy(EnclosingDirectoryOverriddenIncludedSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked EquatableCodableConformingProtocol

public final class EquatableCodableConformingProtocolMock: MockingbirdTestsHost.EquatableCodableConformingProtocol, Mockingbird.Mock, EquatableCodableConformingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EquatableCodableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock)

  public static func ==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableCodableConformingProtocolMock, EquatableCodableConformingProtocolMock) -> Bool {
      return concreteImplementation(`lhs`, `rhs`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> EquatableCodableConformingProtocolMock, _ `rhs`: @escaping @autoclosure () -> EquatableCodableConformingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableCodableConformingProtocolMock, EquatableCodableConformingProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableCodableConformingProtocolMock, EquatableCodableConformingProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `encode`(`to` `encoder`: Encoder)

  public func `encode`(`to` `encoder`: Encoder) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(`encoder`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Encoder) throws -> Void {
      try concreteImplementation(`encoder`)
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `encode`(`to` `encoder`: @escaping @autoclosure () -> Encoder) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`encoder`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`from` `decoder`: Decoder) throws ", arguments: [Mockingbird.ArgumentMatcher(`decoder`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol EquatableCodableConformingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableCodableConformingProtocol`.
public func mock(_ type: EquatableCodableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> EquatableCodableConformingProtocolAbstractMockType {
  return EquatableCodableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableCodableConformingProtocol`.
public func mock<__ReturnType: EquatableCodableConformingProtocolAbstractMockType>(_ type: EquatableCodableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EquatableCodableConformingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EquatableCodableConformingProtocol`.
public func dummy(_ type: EquatableCodableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> EquatableCodableConformingProtocolMock {
  return EquatableCodableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableCodableConformingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EquatableCodableConformingProtocolMock' or use 'dummy(EquatableCodableConformingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: EquatableCodableConformingProtocolMock.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked EquatableConformingClass

public final class EquatableConformingClassMock: MockingbirdTestsHost.EquatableConformingClass, Mockingbird.Mock, EquatableConformingClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EquatableConformingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol EquatableConformingClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.EquatableConformingClass`.
public func mock(_ type: MockingbirdTestsHost.EquatableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> EquatableConformingClassAbstractMockType {
  return EquatableConformingClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.EquatableConformingClass`.
public func mock<__ReturnType: EquatableConformingClassAbstractMockType>(_ type: MockingbirdTestsHost.EquatableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EquatableConformingClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EquatableConformingClass`.
public func dummy(_ type: MockingbirdTestsHost.EquatableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> EquatableConformingClassMock {
  return EquatableConformingClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.EquatableConformingClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EquatableConformingClassMock' or use 'dummy(EquatableConformingClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.EquatableConformingClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked EquatableConformingProtocol

public final class EquatableConformingProtocolMock: MockingbirdTestsHost.EquatableConformingProtocol, Mockingbird.Mock, EquatableConformingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EquatableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock)

  public static func ==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableConformingProtocolMock, EquatableConformingProtocolMock) -> Bool {
      return concreteImplementation(`lhs`, `rhs`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> EquatableConformingProtocolMock, _ `rhs`: @escaping @autoclosure () -> EquatableConformingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableConformingProtocolMock, EquatableConformingProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableConformingProtocolMock, EquatableConformingProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }
}

public protocol EquatableConformingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableConformingProtocol`.
public func mock(_ type: EquatableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> EquatableConformingProtocolAbstractMockType {
  return EquatableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableConformingProtocol`.
public func mock<__ReturnType: EquatableConformingProtocolAbstractMockType>(_ type: EquatableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return EquatableConformingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.EquatableConformingProtocol`.
public func dummy(_ type: EquatableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> EquatableConformingProtocolMock {
  return EquatableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableConformingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'EquatableConformingProtocolMock' or use 'dummy(EquatableConformingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: EquatableConformingProtocolMock.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ExtendableProtocol

public final class ExtendableProtocolMock: MockingbirdTestsHost.ExtendableProtocol, Mockingbird.Mock, ExtendableProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherExtendedVariable

  public var `anotherExtendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked baseVariable

  public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedVariable

  public var `extendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `anotherTrivialExtendedMethod`()

  public func `anotherTrivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `anotherTrivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedExtendedMethod`(`param1`: Bool)

  public func `parameterizedExtendedMethod`(`param1`: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param1`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parameterizedExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningExtendedMethod`(`param1`: Bool)

  public func `parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param1`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parameterizedReturningExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialBaseMethod`()

  public func `trivialBaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `trivialBaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialExtendedMethod`()

  public func `trivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `trivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol ExtendableProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ExtendableProtocol`.
public func mock(_ type: MockingbirdTestsHost.ExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ExtendableProtocolAbstractMockType {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ExtendableProtocol`.
public func mock<__ReturnType: ExtendableProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ExtendableProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ExtendableProtocolMock {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ExtendableProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ExtendableProtocolMock' or use 'dummy(ExtendableProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ExtendableProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableEmptyInitializerClass

public final class FailableEmptyInitializerClassMock: MockingbirdTestsHost.FailableEmptyInitializerClass, Mockingbird.Mock, FailableEmptyInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableEmptyInitializerClassMock? {
        let mock: FailableEmptyInitializerClassMock? = FailableEmptyInitializerClassMock()
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableEmptyInitializerClassAbstractMockType? {
      let mock: FailableEmptyInitializerClassMock? = FailableEmptyInitializerClassMock()
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: FailableEmptyInitializerClassAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: FailableEmptyInitializerClassMock? = FailableEmptyInitializerClassMock()
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'FailableEmptyInitializerClassMock' or use 'dummy(FailableEmptyInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }
  }

  // MARK: Mocked init?()

  public required override init?() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableEmptyInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableEmptyInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(FailableEmptyInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return FailableEmptyInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableEmptyInitializerClass`.
public func mock<__ReturnType: FailableEmptyInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableEmptyInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableEmptyInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableEmptyInitializerClassMock.InitializerProxy.Dummy {
  return FailableEmptyInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableEmptyInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(FailableEmptyInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableEmptyInitializerProtocol

public final class FailableEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableEmptyInitializerProtocol, Mockingbird.Mock, FailableEmptyInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init?()

  public required init?() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableEmptyInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableEmptyInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableEmptyInitializerProtocolAbstractMockType {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableEmptyInitializerProtocol`.
public func mock<__ReturnType: FailableEmptyInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableEmptyInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableEmptyInitializerProtocolMock {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableEmptyInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'FailableEmptyInitializerProtocolMock' or use 'dummy(FailableEmptyInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableParameterizedInitializerClass

public final class FailableParameterizedInitializerClassMock: MockingbirdTestsHost.FailableParameterizedInitializerClass, Mockingbird.Mock, FailableParameterizedInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableParameterizedInitializerClassMock? {
        let mock: FailableParameterizedInitializerClassMock? = FailableParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableParameterizedInitializerClassAbstractMockType? {
      let mock: FailableParameterizedInitializerClassMock? = FailableParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: FailableParameterizedInitializerClassAbstractMockType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: FailableParameterizedInitializerClassMock? = FailableParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'FailableParameterizedInitializerClassMock' or use 'dummy(FailableParameterizedInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }
  }

  // MARK: Mocked init?(`param1`: Bool, `param2`: Int)

  public required override init?(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableParameterizedInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableParameterizedInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(FailableParameterizedInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return FailableParameterizedInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableParameterizedInitializerClass`.
public func mock<__ReturnType: FailableParameterizedInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableParameterizedInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableParameterizedInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableParameterizedInitializerClassMock.InitializerProxy.Dummy {
  return FailableParameterizedInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableParameterizedInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(FailableParameterizedInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableParameterizedInitializerProtocol

public final class FailableParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableParameterizedInitializerProtocol, Mockingbird.Mock, FailableParameterizedInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init?(`param1`: Bool, `param2`: Int)

  public required init?(`param1`: Bool, `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableParameterizedInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableParameterizedInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableParameterizedInitializerProtocolAbstractMockType {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableParameterizedInitializerProtocol`.
public func mock<__ReturnType: FailableParameterizedInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableParameterizedInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableParameterizedInitializerProtocolMock {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableParameterizedInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'FailableParameterizedInitializerProtocolMock' or use 'dummy(FailableParameterizedInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableUnwrappedEmptyInitializerClass

public final class FailableUnwrappedEmptyInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass, Mockingbird.Mock, FailableUnwrappedEmptyInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedEmptyInitializerClassMock {
        let mock: FailableUnwrappedEmptyInitializerClassMock = FailableUnwrappedEmptyInitializerClassMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedEmptyInitializerClassAbstractMockType {
      let mock: FailableUnwrappedEmptyInitializerClassMock = FailableUnwrappedEmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: FailableUnwrappedEmptyInitializerClassAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: FailableUnwrappedEmptyInitializerClassMock = FailableUnwrappedEmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'FailableUnwrappedEmptyInitializerClassMock' or use 'dummy(FailableUnwrappedEmptyInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init!()

  public required override init!() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableUnwrappedEmptyInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(FailableUnwrappedEmptyInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return FailableUnwrappedEmptyInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass`.
public func mock<__ReturnType: FailableUnwrappedEmptyInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableUnwrappedEmptyInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedEmptyInitializerClassMock.InitializerProxy.Dummy {
  return FailableUnwrappedEmptyInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(FailableUnwrappedEmptyInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableUnwrappedEmptyInitializerProtocol

public final class FailableUnwrappedEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol, Mockingbird.Mock, FailableUnwrappedEmptyInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init!()

  public required init!() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableUnwrappedEmptyInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedEmptyInitializerProtocolAbstractMockType {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol`.
public func mock<__ReturnType: FailableUnwrappedEmptyInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedEmptyInitializerProtocolMock {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'FailableUnwrappedEmptyInitializerProtocolMock' or use 'dummy(FailableUnwrappedEmptyInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableUnwrappedParameterizedInitializerClass

public final class FailableUnwrappedParameterizedInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass, Mockingbird.Mock, FailableUnwrappedParameterizedInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedParameterizedInitializerClassMock {
        let mock: FailableUnwrappedParameterizedInitializerClassMock = FailableUnwrappedParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedParameterizedInitializerClassAbstractMockType {
      let mock: FailableUnwrappedParameterizedInitializerClassMock = FailableUnwrappedParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: FailableUnwrappedParameterizedInitializerClassAbstractMockType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: FailableUnwrappedParameterizedInitializerClassMock = FailableUnwrappedParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'FailableUnwrappedParameterizedInitializerClassMock' or use 'dummy(FailableUnwrappedParameterizedInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init!(`param1`: Bool, `param2`: Int)

  public required override init!(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableUnwrappedParameterizedInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(FailableUnwrappedParameterizedInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass`.
public func mock<__ReturnType: FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy.Dummy {
  return FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(FailableUnwrappedParameterizedInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked FailableUnwrappedParameterizedInitializerProtocol

public final class FailableUnwrappedParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol, Mockingbird.Mock, FailableUnwrappedParameterizedInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init!(`param1`: Bool, `param2`: Int)

  public required init!(`param1`: Bool, `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol FailableUnwrappedParameterizedInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedParameterizedInitializerProtocolAbstractMockType {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol`.
public func mock<__ReturnType: FailableUnwrappedParameterizedInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedParameterizedInitializerProtocolMock {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'FailableUnwrappedParameterizedInitializerProtocolMock' or use 'dummy(FailableUnwrappedParameterizedInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked GenericBaseClass

public final class GenericBaseClassMock<T>: MockingbirdTestsHost.GenericBaseClass<T>, Mockingbird.Mock, GenericBaseClassAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "GenericBaseClassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GenericBaseClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> T)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

public protocol GenericBaseClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.GenericBaseClass<T>`.
public func mock<T>(_ type: GenericBaseClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> GenericBaseClassAbstractMockType {
  return GenericBaseClassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.GenericBaseClass<T>`.
public func mock<T, __ReturnType: GenericBaseClassAbstractMockType>(_ type: GenericBaseClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return GenericBaseClassMock<T>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.GenericBaseClass<T>`.
public func dummy<T>(_ type: GenericBaseClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> GenericBaseClassMock<T> {
  return GenericBaseClassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.GenericBaseClass<T>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'GenericBaseClassMock<T>' or use 'dummy(GenericBaseClass<T>.self)' to create a non-mockable dummy object")
public func mock<T, __ReturnType>(_ type: GenericBaseClassMock<T>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked GenericClassReferencer

public final class GenericClassReferencerMock: MockingbirdTestsHost.GenericClassReferencer, Mockingbird.Mock, GenericClassReferencerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GenericClassReferencerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked genericClassVariable

  public var `genericClassVariable`: MockingbirdTestsHost.ReferencedGenericClass<String> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.ReferencedGenericClass<String>)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ReferencedGenericClass<String>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGenericClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<String>, MockingbirdTestsHost.ReferencedGenericClass<String>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<String>, MockingbirdTestsHost.ReferencedGenericClass<String>>(mock: self, invocation: invocation)
  }

  public func setGenericClassVariable(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.ReferencedGenericClass<String>) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClass<String>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClass<String>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked genericClassWithConstraintsVariable

  public var `genericClassWithConstraintsVariable`: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGenericClassWithConstraintsVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>>(mock: self, invocation: invocation)
  }

  public func setGenericClassWithConstraintsVariable(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericClassMethod`<Z>()

  public func `genericClassMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClass<Z> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClass<Z>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClass<Z> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> MockingbirdTestsHost.ReferencedGenericClass<Z>)()
    }
  }

  public func `genericClassMethod`<Z>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<Z>, MockingbirdTestsHost.ReferencedGenericClass<Z>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClass<Z>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<Z>, MockingbirdTestsHost.ReferencedGenericClass<Z>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type)

  public func `genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type) -> Z.Type {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type) -> Z.Type", arguments: [Mockingbird.ArgumentMatcher(`metatype`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Z.Type) -> Z.Type {
      return concreteImplementation(`metatype`)
    } else {
      return (implementation as! () -> Z.Type)()
    }
  }

  public func `genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: @escaping @autoclosure () -> Z.Type) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metatype`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type) -> Z.Type", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericClassWithConstraintsMethod`<Z>()

  public func `genericClassWithConstraintsMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>)()
    }
  }

  public func `genericClassWithConstraintsMethod`<Z>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type)

  public func `genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type) -> Z.Type {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type) -> Z.Type", arguments: [Mockingbird.ArgumentMatcher(`metatype`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Z.Type) -> Z.Type {
      return concreteImplementation(`metatype`)
    } else {
      return (implementation as! () -> Z.Type)()
    }
  }

  public func `genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: @escaping @autoclosure () -> Z.Type) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metatype`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type) -> Z.Type", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type>(mock: self, invocation: invocation)
  }
}

public protocol GenericClassReferencerAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.GenericClassReferencer`.
public func mock(_ type: MockingbirdTestsHost.GenericClassReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> GenericClassReferencerAbstractMockType {
  return GenericClassReferencerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.GenericClassReferencer`.
public func mock<__ReturnType: GenericClassReferencerAbstractMockType>(_ type: MockingbirdTestsHost.GenericClassReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return GenericClassReferencerMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.GenericClassReferencer`.
public func dummy(_ type: MockingbirdTestsHost.GenericClassReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> GenericClassReferencerMock {
  return GenericClassReferencerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.GenericClassReferencer`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'GenericClassReferencerMock' or use 'dummy(GenericClassReferencer.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.GenericClassReferencer.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, Mockingbird.Mock, GrandparentProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

public protocol GrandparentProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.GrandparentProtocol`.
public func mock(_ type: MockingbirdTestsHost.GrandparentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> GrandparentProtocolAbstractMockType {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.GrandparentProtocol`.
public func mock<__ReturnType: GrandparentProtocolAbstractMockType>(_ type: MockingbirdTestsHost.GrandparentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.GrandparentProtocol`.
public func dummy(_ type: MockingbirdTestsHost.GrandparentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> GrandparentProtocolMock {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.GrandparentProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'GrandparentProtocolMock' or use 'dummy(GrandparentProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.GrandparentProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, Mockingbird.Mock, GrandparentAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol GrandparentAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.Grandparent`.
public func mock(_ type: MockingbirdTestsHost.Grandparent.Type, file: StaticString = #file, line: UInt = #line) -> GrandparentAbstractMockType {
  return GrandparentMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.Grandparent`.
public func mock<__ReturnType: GrandparentAbstractMockType>(_ type: MockingbirdTestsHost.Grandparent.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return GrandparentMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.Grandparent`.
public func dummy(_ type: MockingbirdTestsHost.Grandparent.Type, file: StaticString = #file, line: UInt = #line) -> GrandparentMock {
  return GrandparentMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.Grandparent`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'GrandparentMock' or use 'dummy(Grandparent.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.Grandparent.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked HashableConformingClass

public final class HashableConformingClassMock: MockingbirdTestsHost.HashableConformingClass, Mockingbird.Mock, HashableConformingClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HashableConformingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public override func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol HashableConformingClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.HashableConformingClass`.
public func mock(_ type: MockingbirdTestsHost.HashableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> HashableConformingClassAbstractMockType {
  return HashableConformingClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.HashableConformingClass`.
public func mock<__ReturnType: HashableConformingClassAbstractMockType>(_ type: MockingbirdTestsHost.HashableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return HashableConformingClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.HashableConformingClass`.
public func dummy(_ type: MockingbirdTestsHost.HashableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> HashableConformingClassMock {
  return HashableConformingClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.HashableConformingClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'HashableConformingClassMock' or use 'dummy(HashableConformingClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.HashableConformingClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked HashableConformingProtocol

public final class HashableConformingProtocolMock: MockingbirdTestsHost.HashableConformingProtocol, Mockingbird.Mock, HashableConformingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HashableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked hashValue

  public var `hashValue`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
  }

  public func getHashValue() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock)

  public static func ==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (HashableConformingProtocolMock, HashableConformingProtocolMock) -> Bool {
      return concreteImplementation(`lhs`, `rhs`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> HashableConformingProtocolMock, _ `rhs`: @escaping @autoclosure () -> HashableConformingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableConformingProtocolMock, HashableConformingProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableConformingProtocolMock, HashableConformingProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol HashableConformingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.HashableConformingProtocol`.
public func mock(_ type: HashableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> HashableConformingProtocolAbstractMockType {
  return HashableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.HashableConformingProtocol`.
public func mock<__ReturnType: HashableConformingProtocolAbstractMockType>(_ type: HashableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return HashableConformingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.HashableConformingProtocol`.
public func dummy(_ type: HashableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> HashableConformingProtocolMock {
  return HashableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.HashableConformingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'HashableConformingProtocolMock' or use 'dummy(HashableConformingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: HashableConformingProtocolMock.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ImplementingExternalModuleScopedTypealiasedProtocol

public final class ImplementingExternalModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol, Mockingbird.Mock, ImplementingExternalModuleScopedTypealiasedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImplementingExternalModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?)

  public override func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T?) -> T? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T?)()
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T)

  public override func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject?)

  public override func `request`(`object`: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject?)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject)

  public override func `request`(`object`: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject?)

  public override func `request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdModuleTestsHost.NSObject?)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject)

  public override func `request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdModuleTestsHost.NSObject)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

public protocol ImplementingExternalModuleScopedTypealiasedProtocolAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol.Type, file: StaticString = #file, line: UInt = #line) -> ImplementingExternalModuleScopedTypealiasedProtocolAbstractMockType {
  return ImplementingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol`.
public func mock<__ReturnType: ImplementingExternalModuleScopedTypealiasedProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ImplementingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol.Type, file: StaticString = #file, line: UInt = #line) -> ImplementingExternalModuleScopedTypealiasedProtocolMock {
  return ImplementingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ImplementingExternalModuleScopedTypealiasedProtocolMock' or use 'dummy(ImplementingExternalModuleScopedTypealiasedProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ImplementingExternalModuleScoping

public final class ImplementingExternalModuleScopingMock: MockingbirdTestsHost.ImplementingExternalModuleScoping, Mockingbird.Mock, ImplementingExternalModuleScopingAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImplementingExternalModuleScopingMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> ImplementingExternalModuleScopingMock {
        let mock: ImplementingExternalModuleScopingMock = ImplementingExternalModuleScopingMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> ImplementingExternalModuleScopingAbstractMockType {
      let mock: ImplementingExternalModuleScopingMock = ImplementingExternalModuleScopingMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ImplementingExternalModuleScopingAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ImplementingExternalModuleScopingMock = ImplementingExternalModuleScopingMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ImplementingExternalModuleScopingMock' or use 'dummy(ImplementingExternalModuleScopingMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked secondLevelType

  override public var `secondLevelType`: MockingbirdModuleTestsHost.TopLevelType.SecondLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSecondLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType>(mock: self, invocation: invocation)
  }

  public func setSecondLevelType(_ newValue: @escaping @autoclosure () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked thirdLevelType

  override public var `thirdLevelType`: MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getThirdLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
  }

  public func setThirdLevelType(_ newValue: @escaping @autoclosure () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked topLevelType

  override public var `topLevelType`: MockingbirdModuleTestsHost.TopLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdModuleTestsHost.TopLevelType)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.TopLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTopLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType, MockingbirdModuleTestsHost.TopLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType, MockingbirdModuleTestsHost.TopLevelType>(mock: self, invocation: invocation)
  }

  public func setTopLevelType(_ newValue: @escaping @autoclosure () -> MockingbirdModuleTestsHost.TopLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ImplementingExternalModuleScopingAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ImplementingExternalModuleScoping`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ImplementingExternalModuleScopingMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ImplementingExternalModuleScoping.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ImplementingExternalModuleScopingMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ImplementingExternalModuleScoping`.
public func mock<__ReturnType: ImplementingExternalModuleScopingMock.InitializerProxy>(_ type: MockingbirdTestsHost.ImplementingExternalModuleScoping.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ImplementingExternalModuleScopingMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ImplementingExternalModuleScoping`.
public func dummy(_ type: MockingbirdTestsHost.ImplementingExternalModuleScoping.Type, file: StaticString = #file, line: UInt = #line) -> ImplementingExternalModuleScopingMock.InitializerProxy.Dummy {
  return ImplementingExternalModuleScopingMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ImplementingExternalModuleScoping`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ImplementingExternalModuleScopingMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ImplementingExternalModuleScoping.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ImplicitlyImportedExternalObjectiveCType

public final class ImplicitlyImportedExternalObjectiveCTypeMock: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType, Mockingbird.Mock, ImplicitlyImportedExternalObjectiveCTypeAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImplicitlyImportedExternalObjectiveCTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ImplicitlyImportedExternalObjectiveCTypeAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType`.
public func mock(_ type: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType.Protocol, file: StaticString = #file, line: UInt = #line) -> ImplicitlyImportedExternalObjectiveCTypeAbstractMockType {
  return ImplicitlyImportedExternalObjectiveCTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType`.
public func mock<__ReturnType: ImplicitlyImportedExternalObjectiveCTypeAbstractMockType>(_ type: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ImplicitlyImportedExternalObjectiveCTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType`.
public func dummy(_ type: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType.Protocol, file: StaticString = #file, line: UInt = #line) -> ImplicitlyImportedExternalObjectiveCTypeMock {
  return ImplicitlyImportedExternalObjectiveCTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ImplicitlyImportedExternalObjectiveCTypeMock' or use 'dummy(ImplicitlyImportedExternalObjectiveCType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritedTypeQualificationProtocolGenericImplementer

public final class InheritedTypeQualificationProtocolGenericImplementerMock<T>: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>, Mockingbird.Mock, InheritedTypeQualificationProtocolGenericImplementerAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolGenericImplementerMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType)

  public override func `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  public func `lessQualifiedImplementation`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType)

  public override func `moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?)()
    }
  }

  public func `moreQualifiedImplementation`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?, MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?, MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?>(mock: self, invocation: invocation)
  }
}

public protocol InheritedTypeQualificationProtocolGenericImplementerAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>`.
public func mock<T>(_ type: InheritedTypeQualificationProtocolGenericImplementerMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> InheritedTypeQualificationProtocolGenericImplementerAbstractMockType {
  return InheritedTypeQualificationProtocolGenericImplementerMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>`.
public func mock<T, __ReturnType: InheritedTypeQualificationProtocolGenericImplementerAbstractMockType>(_ type: InheritedTypeQualificationProtocolGenericImplementerMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritedTypeQualificationProtocolGenericImplementerMock<T>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>`.
public func dummy<T>(_ type: InheritedTypeQualificationProtocolGenericImplementerMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> InheritedTypeQualificationProtocolGenericImplementerMock<T> {
  return InheritedTypeQualificationProtocolGenericImplementerMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritedTypeQualificationProtocolGenericImplementerMock<T>' or use 'dummy(InheritedTypeQualificationProtocolGenericImplementer<T>.self)' to create a non-mockable dummy object")
public func mock<T, __ReturnType>(_ type: InheritedTypeQualificationProtocolGenericImplementerMock<T>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritedTypeQualificationProtocol

public final class InheritedTypeQualificationProtocolMock<ScopedType>: MockingbirdTestsHost.InheritedTypeQualificationProtocol, Mockingbird.Mock, InheritedTypeQualificationProtocolAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ScopedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolMock<ScopedType>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType)

  public func `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  public func `lessQualifiedImplementation`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation`(`param`: ScopedType)

  public func `moreQualifiedImplementation`(`param`: ScopedType) -> ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: ScopedType) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  public func `moreQualifiedImplementation`(`param`: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: ScopedType) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?>(mock: self, invocation: invocation)
  }
}

public protocol InheritedTypeQualificationProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocol`.
public func mock<ScopedType>(_ type: InheritedTypeQualificationProtocolMock<ScopedType>.Type, file: StaticString = #file, line: UInt = #line) -> InheritedTypeQualificationProtocolAbstractMockType {
  return InheritedTypeQualificationProtocolMock<ScopedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocol`.
public func mock<ScopedType, __ReturnType: InheritedTypeQualificationProtocolAbstractMockType>(_ type: InheritedTypeQualificationProtocolMock<ScopedType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritedTypeQualificationProtocolMock<ScopedType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritedTypeQualificationProtocol`.
public func dummy<ScopedType>(_ type: InheritedTypeQualificationProtocolMock<ScopedType>.Type, file: StaticString = #file, line: UInt = #line) -> InheritedTypeQualificationProtocolMock<ScopedType> {
  return InheritedTypeQualificationProtocolMock<ScopedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritedTypeQualificationProtocolMock<ScopedType>' or use 'dummy(InheritedTypeQualificationProtocol.self)' to create a non-mockable dummy object")
public func mock<ScopedType, __ReturnType>(_ type: InheritedTypeQualificationProtocolMock<ScopedType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritingAssociatedTypeSelfReferencingProtocol

public final class InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol, Mockingbird.Mock, InheritingAssociatedTypeSelfReferencingProtocolAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(SequenceType.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingAssociatedTypeSelfReferencingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SequenceType) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock)

  public func `request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> InheritingAssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol InheritingAssociatedTypeSelfReferencingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable>(_ type: InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingAssociatedTypeSelfReferencingProtocolAbstractMockType {
  return InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable, __ReturnType: InheritingAssociatedTypeSelfReferencingProtocolAbstractMockType>(_ type: InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol`.
public func dummy<SequenceType: Sequence & Swift.Hashable>(_ type: InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType> {
  return InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>' or use 'dummy(InheritingAssociatedTypeSelfReferencingProtocol.self)' to create a non-mockable dummy object")
public func mock<SequenceType: Sequence & Swift.Hashable, __ReturnType>(_ type: InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritingExternalModuleScopedAssociatedTypeProtocol

public final class InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol, Mockingbird.Mock, InheritingExternalModuleScopedAssociatedTypeProtocolAbstractMockType where Data.Element == MockingbirdModuleTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(Data.self)", "\(Element.self)", "\(Subelement.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingExternalModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol InheritingExternalModuleScopedAssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>(_ type: InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingExternalModuleScopedAssociatedTypeProtocolAbstractMockType {
  return InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol, __ReturnType: InheritingExternalModuleScopedAssociatedTypeProtocolAbstractMockType>(_ type: InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol`.
public func dummy<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>(_ type: InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>' or use 'dummy(InheritingExternalModuleScopedAssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol, __ReturnType>(_ type: InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritingExternalModuleScopedTypealiasedProtocol

public final class InheritingExternalModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol, Mockingbird.Mock, InheritingExternalModuleScopedTypealiasedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingExternalModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?)

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T?) -> T? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T?)()
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T)

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject?)

  public func `request`(`object`: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject?)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject)

  public func `request`(`object`: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject?)

  public func `request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdModuleTestsHost.NSObject?)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject)

  public func `request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdModuleTestsHost.NSObject)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

public protocol InheritingExternalModuleScopedTypealiasedProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InheritingExternalModuleScopedTypealiasedProtocolAbstractMockType {
  return InheritingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol`.
public func mock<__ReturnType: InheritingExternalModuleScopedTypealiasedProtocolAbstractMockType>(_ type: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InheritingExternalModuleScopedTypealiasedProtocolMock {
  return InheritingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritingExternalModuleScopedTypealiasedProtocolMock' or use 'dummy(InheritingExternalModuleScopedTypealiasedProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritingModuleScopedAssociatedTypeProtocol

public final class InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol, Mockingbird.Mock, InheritingModuleScopedAssociatedTypeProtocolAbstractMockType where Data.Element == MockingbirdTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(Data.self)", "\(Element.self)", "\(Subelement.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol InheritingModuleScopedAssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>(_ type: InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingModuleScopedAssociatedTypeProtocolAbstractMockType {
  return InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, __ReturnType: InheritingModuleScopedAssociatedTypeProtocolAbstractMockType>(_ type: InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol`.
public func dummy<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>(_ type: InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>' or use 'dummy(InheritingModuleScopedAssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, __ReturnType>(_ type: InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InheritsExtendableProtocol

public final class InheritsExtendableProtocolMock: MockingbirdTestsHost.InheritsExtendableProtocol, Mockingbird.Mock, InheritsExtendableProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritsExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherExtendedVariable

  public var `anotherExtendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked baseVariable

  public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childVariable

  public var `childVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedVariable

  public var `extendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `anotherTrivialExtendedMethod`()

  public func `anotherTrivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `anotherTrivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedExtendedMethod`(`param1`: Bool)

  public func `parameterizedExtendedMethod`(`param1`: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param1`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parameterizedExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningExtendedMethod`(`param1`: Bool)

  public func `parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param1`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parameterizedReturningExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialBaseMethod`()

  public func `trivialBaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `trivialBaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialChildMethod`()

  public func `trivialChildMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialChildMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `trivialChildMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialChildMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialExtendedMethod`()

  public func `trivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `trivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol InheritsExtendableProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritsExtendableProtocol`.
public func mock(_ type: MockingbirdTestsHost.InheritsExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InheritsExtendableProtocolAbstractMockType {
  return InheritsExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritsExtendableProtocol`.
public func mock<__ReturnType: InheritsExtendableProtocolAbstractMockType>(_ type: MockingbirdTestsHost.InheritsExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InheritsExtendableProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InheritsExtendableProtocol`.
public func dummy(_ type: MockingbirdTestsHost.InheritsExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InheritsExtendableProtocolMock {
  return InheritsExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritsExtendableProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InheritsExtendableProtocolMock' or use 'dummy(InheritsExtendableProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InheritsExtendableProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializableClassOnlyProtocolWithInheritedInitializer

public final class InitializableClassOnlyProtocolWithInheritedInitializerMock: MockingbirdTestsHost.ClassWithDesignatedInitializer, MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer, Mockingbird.Mock, InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializableClassOnlyProtocolWithInheritedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      @available(*, deprecated, message: "This class initializer is deprecated")
      public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock {
        let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param1: `param1`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock {
        let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock {
        let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    @available(*, deprecated, message: "This class initializer is deprecated")
    public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    @available(*, deprecated, message: "This class initializer is deprecated")
    public func initialize<__ReturnType: InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializableClassOnlyProtocolWithInheritedInitializerMock' or use 'dummy(InitializableClassOnlyProtocolWithInheritedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    @available(*, deprecated, message: "This class initializer is deprecated")
    public func initialize<__ReturnType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializableClassOnlyProtocolWithInheritedInitializerMock' or use 'dummy(InitializableClassOnlyProtocolWithInheritedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType>(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializableClassOnlyProtocolWithInheritedInitializerMock' or use 'dummy(InitializableClassOnlyProtocolWithInheritedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`param1`: Bool)

  @available(*, deprecated, message: "This class initializer is deprecated")
  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  @available(*, deprecated, message: "Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  public required init(`param1`: Bool, `param2`: Int) {
    fatalError("Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int, `param3`: String)

  @available(*, deprecated, message: "Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  public required init(`param1`: Bool, `param2`: Int, `param3`: String) {
    fatalError("Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  }

  // MARK: Mocked init(`param2`: Bool, `param3`: Int)

  @available(*, deprecated, message: "This protocol initializer is deprecated")
  @available(*, deprecated, message: "Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  public required init(`param2`: Bool, `param3`: Int) {
    fatalError("Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  }

  // MARK: Mocked init(`param`: Bool)

  public required init(`param`: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: Int)

  public required override init(`param`: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializableClassOnlyProtocolWithInheritedInitializerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(InitializableClassOnlyProtocolWithInheritedInitializerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer`.
public func mock<__ReturnType: InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy>(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer`.
public func dummy(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy.Dummy {
  return InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(InitializableClassOnlyProtocolWithInheritedInitializerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializableClassOnlyProtocol

public final class InitializableClassOnlyProtocolMock: MockingbirdTestsHost.ClassWithoutDesignatedInitializer, MockingbirdTestsHost.InitializableClassOnlyProtocol, Mockingbird.Mock, InitializableClassOnlyProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializableClassOnlyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolMock {
        let mock: InitializableClassOnlyProtocolMock = InitializableClassOnlyProtocolMock(param1: `param1`, param2: `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolAbstractMockType {
      let mock: InitializableClassOnlyProtocolMock = InitializableClassOnlyProtocolMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializableClassOnlyProtocolAbstractMockType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializableClassOnlyProtocolMock = InitializableClassOnlyProtocolMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializableClassOnlyProtocolMock' or use 'dummy(InitializableClassOnlyProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required init(`param1`: Bool, `param2`: Int) {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializableClassOnlyProtocolAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocol`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(InitializableClassOnlyProtocolMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return InitializableClassOnlyProtocolMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocol`.
public func mock<__ReturnType: InitializableClassOnlyProtocolMock.InitializerProxy>(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializableClassOnlyProtocolMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializableClassOnlyProtocol`.
public func dummy(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializableClassOnlyProtocolMock.InitializerProxy.Dummy {
  return InitializableClassOnlyProtocolMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocol`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(InitializableClassOnlyProtocolMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializerClass

public final class InitializerClassMock: MockingbirdTestsHost.InitializerClass, Mockingbird.Mock, InitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
        let mock: InitializerClassMock = InitializerClassMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize<T>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
        let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize<T>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock where T: MockingbirdTestsHost.AssociatedTypeProtocol {
        let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param1`: Bool, _ `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
        let mock: InitializerClassMock = InitializerClassMock(param1: `param1`, `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize<T>(`param2`: T, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassMock where T: MockingbirdTestsHost.AssociatedTypeProtocol {
        let mock: InitializerClassMock = try InitializerClassMock(param2: `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock? {
        let mock: InitializerClassMock? = InitializerClassMock(param: `param`)
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
        let mock: InitializerClassMock = InitializerClassMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
        let mock: InitializerClassMock = InitializerClassMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: String, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassMock {
        let mock: InitializerClassMock = try InitializerClassMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType {
      let mock: InitializerClassMock = InitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerClassAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerClassMock = InitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize<T>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<T, __ReturnType: InitializerClassAbstractMockType>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<T, __ReturnType>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize<T>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType where T: MockingbirdTestsHost.AssociatedTypeProtocol {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<T, __ReturnType: InitializerClassAbstractMockType>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType where T: MockingbirdTestsHost.AssociatedTypeProtocol {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock where T: MockingbirdTestsHost.AssociatedTypeProtocol.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<T, __ReturnType>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType where T: MockingbirdTestsHost.AssociatedTypeProtocol { fatalError() }

    public func initialize(`param1`: Bool, _ `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`, `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerClassAbstractMockType>(`param1`: Bool, _ `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`, `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, _ `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize<T>(`param2`: T, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassAbstractMockType where T: MockingbirdTestsHost.AssociatedTypeProtocol {
      let mock: InitializerClassMock = try InitializerClassMock(param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<T, __ReturnType: InitializerClassAbstractMockType>(`param2`: T, __file: StaticString = #file, __line: UInt = #line) throws -> __ReturnType where T: MockingbirdTestsHost.AssociatedTypeProtocol {
      let mock: InitializerClassMock = try InitializerClassMock(param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock where T: MockingbirdTestsHost.AssociatedTypeProtocol.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<T, __ReturnType>(`param2`: T, __file: StaticString = #file, __line: UInt = #line) throws -> __ReturnType where T: MockingbirdTestsHost.AssociatedTypeProtocol { fatalError() }

    public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType? {
      let mock: InitializerClassMock? = InitializerClassMock(param: `param`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerClassAbstractMockType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: InitializerClassMock? = InitializerClassMock(param: `param`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }

    public func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerClassAbstractMockType>(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassAbstractMockType {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerClassAbstractMockType>(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: String, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassAbstractMockType {
      let mock: InitializerClassMock = try InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerClassAbstractMockType>(`param`: String, __file: StaticString = #file, __line: UInt = #line) throws -> __ReturnType {
      let mock: InitializerClassMock = try InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerClassMock' or use 'dummy(InitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: String, __file: StaticString = #file, __line: UInt = #line) throws -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!<T>(`param1`: T)

  public required override init!<T>(`param1`: T) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!<T>(`param1`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param1`: T)

  public required override init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, _ `param2`: Int)

  public required override init(`param1`: Bool, _ `param2`: Int) {
    super.init(param1: `param1`, `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, _ `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param2`: T)

  public required override init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    try super.init(param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?(`param`: Bool)

  public required override init?(`param`: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!(`param`: Int)

  public required override init!(`param`: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String?)

  public required init(`param`: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String?) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String)

  public required override init(`param`: String) throws {
    try super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) throws ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(InitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.InitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return InitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerClass`.
public func mock<__ReturnType: InitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.InitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.InitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> InitializerClassMock.InitializerProxy.Dummy {
  return InitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(InitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializerOverridingProtocol

public final class InitializerOverridingProtocolMock: MockingbirdTestsHost.InitializerOverridingProtocol, Mockingbird.Mock, InitializerOverridingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerOverridingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init()

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param123`: Bool)

  public required init(`param123`: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param123`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param123`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!<T>(`param1`: T)

  public required init!<T>(`param1`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!<T>(`param1`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param1`: T)

  public required init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, _ `param2`: Int)

  public required init(`param1`: Bool, _ `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, _ `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param2`: T)

  public required init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T)

  public required init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?<T>(`param`: T)

  public required init?<T>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?<T>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?(`param`: Bool)

  public required init?(`param`: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!(`param`: Int)

  public required init!(`param`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String)

  public required init(`param`: String) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) throws ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializerOverridingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerOverridingProtocol`.
public func mock(_ type: MockingbirdTestsHost.InitializerOverridingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializerOverridingProtocolAbstractMockType {
  return InitializerOverridingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerOverridingProtocol`.
public func mock<__ReturnType: InitializerOverridingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.InitializerOverridingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializerOverridingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializerOverridingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.InitializerOverridingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializerOverridingProtocolMock {
  return InitializerOverridingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerOverridingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InitializerOverridingProtocolMock' or use 'dummy(InitializerOverridingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializerOverridingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializerOverridingSubclass

public final class InitializerOverridingSubclassMock: MockingbirdTestsHost.InitializerOverridingSubclass, Mockingbird.Mock, InitializerOverridingSubclassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerOverridingSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerOverridingSubclassMock {
        let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerOverridingSubclassMock {
        let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerOverridingSubclassAbstractMockType {
      let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerOverridingSubclassAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerOverridingSubclassMock' or use 'dummy(InitializerOverridingSubclassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerOverridingSubclassAbstractMockType {
      let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerOverridingSubclassAbstractMockType>(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerOverridingSubclassMock' or use 'dummy(InitializerOverridingSubclassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String?)

  public required init(`param`: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String?) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializerOverridingSubclassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerOverridingSubclass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(InitializerOverridingSubclassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.InitializerOverridingSubclass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return InitializerOverridingSubclassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerOverridingSubclass`.
public func mock<__ReturnType: InitializerOverridingSubclassMock.InitializerProxy>(_ type: MockingbirdTestsHost.InitializerOverridingSubclass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializerOverridingSubclassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializerOverridingSubclass`.
public func dummy(_ type: MockingbirdTestsHost.InitializerOverridingSubclass.Type, file: StaticString = #file, line: UInt = #line) -> InitializerOverridingSubclassMock.InitializerProxy.Dummy {
  return InitializerOverridingSubclassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerOverridingSubclass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(InitializerOverridingSubclassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializerOverridingSubclass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializerProtocol

public final class InitializerProtocolMock: MockingbirdTestsHost.InitializerProtocol, Mockingbird.Mock, InitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init()

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!<T>(`param1`: T)

  public required init!<T>(`param1`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!<T>(`param1`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param1`: T)

  public required init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, _ `param2`: Int)

  public required init(`param1`: Bool, _ `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, _ `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param2`: T)

  public required init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T)

  public required init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?<T>(`param`: T)

  public required init?<T>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?<T>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?(`param`: Bool)

  public required init?(`param`: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!(`param`: Int)

  public required init!(`param`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String)

  public required init(`param`: String) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) throws ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.InitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializerProtocolAbstractMockType {
  return InitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerProtocol`.
public func mock<__ReturnType: InitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.InitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.InitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializerProtocolMock {
  return InitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InitializerProtocolMock' or use 'dummy(InitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked InitializerSubclass

public final class InitializerSubclassMock: MockingbirdTestsHost.InitializerSubclass, Mockingbird.Mock, InitializerSubclassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param99`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerSubclassMock {
        let mock: InitializerSubclassMock = InitializerSubclassMock(param99: `param99`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerSubclassMock {
        let mock: InitializerSubclassMock = InitializerSubclassMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param99`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerSubclassAbstractMockType {
      let mock: InitializerSubclassMock = InitializerSubclassMock(param99: `param99`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerSubclassAbstractMockType>(`param99`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerSubclassMock = InitializerSubclassMock(param99: `param99`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerSubclassMock' or use 'dummy(InitializerSubclassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param99`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }

    public func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerSubclassAbstractMockType {
      let mock: InitializerSubclassMock = InitializerSubclassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: InitializerSubclassAbstractMockType>(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: InitializerSubclassMock = InitializerSubclassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializerSubclassMock' or use 'dummy(InitializerSubclassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`param99`: Bool)

  public required override init(`param99`: Bool) {
    super.init(param99: `param99`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param99`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param99`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String?)

  public required init(`param`: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String?) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol InitializerSubclassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerSubclass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(InitializerSubclassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.InitializerSubclass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return InitializerSubclassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerSubclass`.
public func mock<__ReturnType: InitializerSubclassMock.InitializerProxy>(_ type: MockingbirdTestsHost.InitializerSubclass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InitializerSubclassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InitializerSubclass`.
public func dummy(_ type: MockingbirdTestsHost.InitializerSubclass.Type, file: StaticString = #file, line: UInt = #line) -> InitializerSubclassMock.InitializerProxy.Dummy {
  return InitializerSubclassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerSubclass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(InitializerSubclassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InitializerSubclass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InoutClass

public final class InoutClassMock: MockingbirdTestsHost.InoutClass, Mockingbird.Mock, InoutClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `parameterizedMethod`(`object`: inout String)

  public override func `parameterizedMethod`(`object`: inout String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parameterizedMethod`(`object`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol InoutClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.InoutClass`.
public func mock(_ type: MockingbirdTestsHost.InoutClass.Type, file: StaticString = #file, line: UInt = #line) -> InoutClassAbstractMockType {
  return InoutClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.InoutClass`.
public func mock<__ReturnType: InoutClassAbstractMockType>(_ type: MockingbirdTestsHost.InoutClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InoutClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InoutClass`.
public func dummy(_ type: MockingbirdTestsHost.InoutClass.Type, file: StaticString = #file, line: UInt = #line) -> InoutClassMock {
  return InoutClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.InoutClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InoutClassMock' or use 'dummy(InoutClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InoutClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked InoutProtocol

public final class InoutProtocolMock: MockingbirdTestsHost.InoutProtocol, Mockingbird.Mock, InoutProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `parameterizedMethod`(`object`: inout String)

  public func `parameterizedMethod`(`object`: inout String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parameterizedMethod`(`object`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol InoutProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.InoutProtocol`.
public func mock(_ type: MockingbirdTestsHost.InoutProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InoutProtocolAbstractMockType {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InoutProtocol`.
public func mock<__ReturnType: InoutProtocolAbstractMockType>(_ type: MockingbirdTestsHost.InoutProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.InoutProtocol`.
public func dummy(_ type: MockingbirdTestsHost.InoutProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InoutProtocolMock {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InoutProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'InoutProtocolMock' or use 'dummy(InoutProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.InoutProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked KeywordArgNamesClass

public final class KeywordArgNamesClassMock: MockingbirdTestsHost.KeywordArgNamesClass, Mockingbird.Mock, KeywordArgNamesClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      KeywordArgNamesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithKeywordParam`(`inout`: String)

  public override func `methodWithKeywordParam`(`inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`inout`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithKeywordParam`(`inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithNamedKeywordParam`(`with` `inout`: String)

  public override func `methodWithNamedKeywordParam`(`with` `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`inout`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithNamedKeywordParam`(`with` `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParamNamedKeyword`(`inout` `param`: String)

  public override func `methodWithParamNamedKeyword`(`inout` `param`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithParamNamedKeyword`(`inout` `param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnnamedKeywordParam`(_ `inout`: String)

  public override func `methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`inout`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithUnnamedKeywordParam`(_ `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol KeywordArgNamesClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.KeywordArgNamesClass`.
public func mock(_ type: MockingbirdTestsHost.KeywordArgNamesClass.Type, file: StaticString = #file, line: UInt = #line) -> KeywordArgNamesClassAbstractMockType {
  return KeywordArgNamesClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.KeywordArgNamesClass`.
public func mock<__ReturnType: KeywordArgNamesClassAbstractMockType>(_ type: MockingbirdTestsHost.KeywordArgNamesClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return KeywordArgNamesClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.KeywordArgNamesClass`.
public func dummy(_ type: MockingbirdTestsHost.KeywordArgNamesClass.Type, file: StaticString = #file, line: UInt = #line) -> KeywordArgNamesClassMock {
  return KeywordArgNamesClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.KeywordArgNamesClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'KeywordArgNamesClassMock' or use 'dummy(KeywordArgNamesClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.KeywordArgNamesClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked KeywordArgNamesProtocol

public final class KeywordArgNamesProtocolMock: MockingbirdTestsHost.KeywordArgNamesProtocol, Mockingbird.Mock, KeywordArgNamesProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      KeywordArgNamesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithKeywordParam`(`inout`: String)

  public func `methodWithKeywordParam`(`inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`inout`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithKeywordParam`(`inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithNamedKeywordParam`(`with` `inout`: String)

  public func `methodWithNamedKeywordParam`(`with` `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`inout`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithNamedKeywordParam`(`with` `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParamNamedKeyword`(`inout` `param`: String)

  public func `methodWithParamNamedKeyword`(`inout` `param`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithParamNamedKeyword`(`inout` `param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnnamedKeywordParam`(_ `inout`: String)

  public func `methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`inout`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithUnnamedKeywordParam`(_ `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol KeywordArgNamesProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.KeywordArgNamesProtocol`.
public func mock(_ type: MockingbirdTestsHost.KeywordArgNamesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> KeywordArgNamesProtocolAbstractMockType {
  return KeywordArgNamesProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.KeywordArgNamesProtocol`.
public func mock<__ReturnType: KeywordArgNamesProtocolAbstractMockType>(_ type: MockingbirdTestsHost.KeywordArgNamesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return KeywordArgNamesProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.KeywordArgNamesProtocol`.
public func dummy(_ type: MockingbirdTestsHost.KeywordArgNamesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> KeywordArgNamesProtocolMock {
  return KeywordArgNamesProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.KeywordArgNamesProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'KeywordArgNamesProtocolMock' or use 'dummy(KeywordArgNamesProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.KeywordArgNamesProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked LineCommentNotDebugCompilationDirectiveProtocol

public final class LineCommentNotDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol, Mockingbird.Mock, LineCommentNotDebugCompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LineCommentNotDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol LineCommentNotDebugCompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> LineCommentNotDebugCompilationDirectiveProtocolAbstractMockType {
  return LineCommentNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol`.
public func mock<__ReturnType: LineCommentNotDebugCompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return LineCommentNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> LineCommentNotDebugCompilationDirectiveProtocolMock {
  return LineCommentNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'LineCommentNotDebugCompilationDirectiveProtocolMock' or use 'dummy(LineCommentNotDebugCompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked LocalPublicExternalProtocol

public final class LocalPublicExternalProtocolMock: MockingbirdTestsHost.LocalPublicExternalProtocol, Mockingbird.Mock, LocalPublicExternalProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LocalPublicExternalProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`()

  public func `method`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol LocalPublicExternalProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.LocalPublicExternalProtocol`.
public func mock(_ type: MockingbirdTestsHost.LocalPublicExternalProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> LocalPublicExternalProtocolAbstractMockType {
  return LocalPublicExternalProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.LocalPublicExternalProtocol`.
public func mock<__ReturnType: LocalPublicExternalProtocolAbstractMockType>(_ type: MockingbirdTestsHost.LocalPublicExternalProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return LocalPublicExternalProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.LocalPublicExternalProtocol`.
public func dummy(_ type: MockingbirdTestsHost.LocalPublicExternalProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> LocalPublicExternalProtocolMock {
  return LocalPublicExternalProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.LocalPublicExternalProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'LocalPublicExternalProtocolMock' or use 'dummy(LocalPublicExternalProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.LocalPublicExternalProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ModuleScopedAssociatedTypeProtocol

public final class ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, Mockingbird.Mock, ModuleScopedAssociatedTypeProtocolAbstractMockType where Data.Element == MockingbirdTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(Data.self)", "\(Element.self)", "\(Subelement.self)"].joined(separator: ",")
    let staticMockIdentifier = "ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ModuleScopedAssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>(_ type: ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> ModuleScopedAssociatedTypeProtocolAbstractMockType {
  return ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, __ReturnType: ModuleScopedAssociatedTypeProtocolAbstractMockType>(_ type: ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol`.
public func dummy<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>(_ type: ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>' or use 'dummy(ModuleScopedAssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, __ReturnType>(_ type: ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ModuleScopedTypealiasedProtocol

public final class ModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol, Mockingbird.Mock, ModuleScopedTypealiasedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?)

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T?) -> T? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T?)()
    }
  }

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T)

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject?)

  public func `request`(`object`: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject?)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject)

  public func `request`(`object`: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdTestsHost.NSObject?)

  public func `request`(`object`: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject?)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdTestsHost.NSObject)

  public func `request`(`object`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject)()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

public protocol ModuleScopedTypealiasedProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedTypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ModuleScopedTypealiasedProtocolAbstractMockType {
  return ModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedTypealiasedProtocol`.
public func mock<__ReturnType: ModuleScopedTypealiasedProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ModuleScopedTypealiasedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ModuleScopedTypealiasedProtocolMock {
  return ModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedTypealiasedProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ModuleScopedTypealiasedProtocolMock' or use 'dummy(ModuleScopedTypealiasedProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked NSObjectProtocolConformingProtocol

public final class NSObjectProtocolConformingProtocolMock: Foundation.NSObject, MockingbirdTestsHost.NSObjectProtocolConformingProtocol, Mockingbird.Mock, NSObjectProtocolConformingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NSObjectProtocolConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol NSObjectProtocolConformingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.NSObjectProtocolConformingProtocol`.
public func mock(_ type: MockingbirdTestsHost.NSObjectProtocolConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NSObjectProtocolConformingProtocolAbstractMockType {
  return NSObjectProtocolConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NSObjectProtocolConformingProtocol`.
public func mock<__ReturnType: NSObjectProtocolConformingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.NSObjectProtocolConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NSObjectProtocolConformingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NSObjectProtocolConformingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.NSObjectProtocolConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NSObjectProtocolConformingProtocolMock {
  return NSObjectProtocolConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NSObjectProtocolConformingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'NSObjectProtocolConformingProtocolMock' or use 'dummy(NSObjectProtocolConformingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NSObjectProtocolConformingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked NSViewInheritingProtocol

public final class NSViewInheritingProtocolMock: AppKit.NSView, MockingbirdTestsHost.NSViewInheritingProtocol, Mockingbird.Mock, NSViewInheritingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NSViewInheritingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> NSViewInheritingProtocolMock? {
        let mock: NSViewInheritingProtocolMock? = NSViewInheritingProtocolMock(coder: `coder`)
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`frame` `frameRect`: NSRect, __file: StaticString = #file, __line: UInt = #line) -> NSViewInheritingProtocolMock {
        let mock: NSViewInheritingProtocolMock = NSViewInheritingProtocolMock(frame: `frameRect`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> NSViewInheritingProtocolAbstractMockType? {
      let mock: NSViewInheritingProtocolMock? = NSViewInheritingProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: NSViewInheritingProtocolAbstractMockType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: NSViewInheritingProtocolMock? = NSViewInheritingProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'NSViewInheritingProtocolMock' or use 'dummy(NSViewInheritingProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }

    public func initialize(`frame` `frameRect`: NSRect, __file: StaticString = #file, __line: UInt = #line) -> NSViewInheritingProtocolAbstractMockType {
      let mock: NSViewInheritingProtocolMock = NSViewInheritingProtocolMock(frame: `frameRect`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: NSViewInheritingProtocolAbstractMockType>(`frame` `frameRect`: NSRect, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: NSViewInheritingProtocolMock = NSViewInheritingProtocolMock(frame: `frameRect`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'NSViewInheritingProtocolMock' or use 'dummy(NSViewInheritingProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`frame` `frameRect`: NSRect, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`frame` `frameRect`: NSRect)

  public required override init(`frame` `frameRect`: NSRect) {
    super.init(frame: `frameRect`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`frame` `frameRect`: NSRect) ", arguments: [Mockingbird.ArgumentMatcher(`frameRect`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol NSViewInheritingProtocolAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.NSViewInheritingProtocol`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(NSViewInheritingProtocolMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.NSViewInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return NSViewInheritingProtocolMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.NSViewInheritingProtocol`.
public func mock<__ReturnType: NSViewInheritingProtocolMock.InitializerProxy>(_ type: MockingbirdTestsHost.NSViewInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NSViewInheritingProtocolMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NSViewInheritingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.NSViewInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NSViewInheritingProtocolMock.InitializerProxy.Dummy {
  return NSViewInheritingProtocolMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.NSViewInheritingProtocol`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(NSViewInheritingProtocolMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NSViewInheritingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked NestedCompilationDirectiveProtocol

#if DEBUG
#if !(!(DEBUG))

public final class NestedCompilationDirectiveProtocolMock: MockingbirdTestsHost.NestedCompilationDirectiveProtocol, Mockingbird.Mock, NestedCompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NestedCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG
  #if !(!(DEBUG))

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif
#endif

#if DEBUG
#if !(!(DEBUG))

public protocol NestedCompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.NestedCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.NestedCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NestedCompilationDirectiveProtocolAbstractMockType {
  return NestedCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NestedCompilationDirectiveProtocol`.
public func mock<__ReturnType: NestedCompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.NestedCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NestedCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NestedCompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.NestedCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NestedCompilationDirectiveProtocolMock {
  return NestedCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NestedCompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'NestedCompilationDirectiveProtocolMock' or use 'dummy(NestedCompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NestedCompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

#endif
#endif

// MARK: - Mocked NoInitializerClass

public final class NoInitializerClassMock: MockingbirdTestsHost.NoInitializerClass, Mockingbird.Mock, NoInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NoInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol NoInitializerClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.NoInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.NoInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> NoInitializerClassAbstractMockType {
  return NoInitializerClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.NoInitializerClass`.
public func mock<__ReturnType: NoInitializerClassAbstractMockType>(_ type: MockingbirdTestsHost.NoInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NoInitializerClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NoInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.NoInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> NoInitializerClassMock {
  return NoInitializerClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.NoInitializerClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'NoInitializerClassMock' or use 'dummy(NoInitializerClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NoInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked NoInitializerProtocol

public final class NoInitializerProtocolMock: MockingbirdTestsHost.NoInitializerProtocol, Mockingbird.Mock, NoInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NoInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol NoInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.NoInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.NoInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NoInitializerProtocolAbstractMockType {
  return NoInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NoInitializerProtocol`.
public func mock<__ReturnType: NoInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.NoInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NoInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NoInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.NoInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NoInitializerProtocolMock {
  return NoInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NoInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'NoInitializerProtocolMock' or use 'dummy(NoInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NoInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked NonExtendableClass

public final class NonExtendableClassMock: MockingbirdTestsHost.NonExtendableClass, Mockingbird.Mock, NonExtendableClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `trivialBaseMethod`()

  public override func `trivialBaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `trivialBaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol NonExtendableClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.NonExtendableClass`.
public func mock(_ type: MockingbirdTestsHost.NonExtendableClass.Type, file: StaticString = #file, line: UInt = #line) -> NonExtendableClassAbstractMockType {
  return NonExtendableClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.NonExtendableClass`.
public func mock<__ReturnType: NonExtendableClassAbstractMockType>(_ type: MockingbirdTestsHost.NonExtendableClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NonExtendableClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NonExtendableClass`.
public func dummy(_ type: MockingbirdTestsHost.NonExtendableClass.Type, file: StaticString = #file, line: UInt = #line) -> NonExtendableClassMock {
  return NonExtendableClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.NonExtendableClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'NonExtendableClassMock' or use 'dummy(NonExtendableClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NonExtendableClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked NotDebugCompilationDirectiveProtocol

#if !(DEBUG)

public final class NotDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol, Mockingbird.Mock, NotDebugCompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NotDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if !(DEBUG)

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if !(DEBUG)

public protocol NotDebugCompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NotDebugCompilationDirectiveProtocolAbstractMockType {
  return NotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol`.
public func mock<__ReturnType: NotDebugCompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return NotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NotDebugCompilationDirectiveProtocolMock {
  return NotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'NotDebugCompilationDirectiveProtocolMock' or use 'dummy(NotDebugCompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.NotDebugCompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

#endif

// MARK: - Mocked ObjectiveCClass

public final class ObjectiveCClassMock: MockingbirdTestsHost.ObjectiveCClass, Mockingbird.Mock, ObjectiveCClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ObjectiveCClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> ObjectiveCClassMock {
        let mock: ObjectiveCClassMock = ObjectiveCClassMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> ObjectiveCClassAbstractMockType {
      let mock: ObjectiveCClassMock = ObjectiveCClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ObjectiveCClassAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ObjectiveCClassMock = ObjectiveCClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ObjectiveCClassMock' or use 'dummy(ObjectiveCClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked nominalObjcVariable

  override public var `nominalObjcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getNominalObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setNominalObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcComputedVariable

  override public var `objcComputedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcComputedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getObjcComputedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcComputedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcVariable

  override public var `objcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `method`()

  public override func `method`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nominalObjcMethod`()

  public override func `nominalObjcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `nominalObjcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `objcMethod`()

  public override func `objcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `objcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol ObjectiveCClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ObjectiveCClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ObjectiveCClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ObjectiveCClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ObjectiveCClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ObjectiveCClass`.
public func mock<__ReturnType: ObjectiveCClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.ObjectiveCClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ObjectiveCClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ObjectiveCClass`.
public func dummy(_ type: MockingbirdTestsHost.ObjectiveCClass.Type, file: StaticString = #file, line: UInt = #line) -> ObjectiveCClassMock.InitializerProxy.Dummy {
  return ObjectiveCClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ObjectiveCClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ObjectiveCClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ObjectiveCClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ObjectiveCProtocolImplementer

public final class ObjectiveCProtocolImplementerMock: MockingbirdTestsHost.ObjectiveCProtocolImplementer, Mockingbird.Mock, ObjectiveCProtocolImplementerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ObjectiveCProtocolImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked nominalObjcVariable

  override public var `nominalObjcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getNominalObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setNominalObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcVariable

  override public var `objcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`()

  public override func `method`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nominalObjcMethod`()

  public override func `nominalObjcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `nominalObjcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `objcMethod`()

  public override func `objcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `objcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol ObjectiveCProtocolImplementerAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ObjectiveCProtocolImplementer`.
public func mock(_ type: MockingbirdTestsHost.ObjectiveCProtocolImplementer.Type, file: StaticString = #file, line: UInt = #line) -> ObjectiveCProtocolImplementerAbstractMockType {
  return ObjectiveCProtocolImplementerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ObjectiveCProtocolImplementer`.
public func mock<__ReturnType: ObjectiveCProtocolImplementerAbstractMockType>(_ type: MockingbirdTestsHost.ObjectiveCProtocolImplementer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ObjectiveCProtocolImplementerMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ObjectiveCProtocolImplementer`.
public func dummy(_ type: MockingbirdTestsHost.ObjectiveCProtocolImplementer.Type, file: StaticString = #file, line: UInt = #line) -> ObjectiveCProtocolImplementerMock {
  return ObjectiveCProtocolImplementerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ObjectiveCProtocolImplementer`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ObjectiveCProtocolImplementerMock' or use 'dummy(ObjectiveCProtocolImplementer.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ObjectiveCProtocolImplementer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ObjectiveCProtocol

public final class ObjectiveCProtocolMock: MockingbirdTestsHost.ObjectiveCProtocol, Mockingbird.Mock, ObjectiveCProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ObjectiveCProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked nominalObjcVariable

  public var `nominalObjcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getNominalObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcVariable

  public var `objcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`()

  public func `method`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nominalObjcMethod`()

  public func `nominalObjcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `nominalObjcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `objcMethod`()

  public func `objcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `objcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol ObjectiveCProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ObjectiveCProtocol`.
public func mock(_ type: MockingbirdTestsHost.ObjectiveCProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ObjectiveCProtocolAbstractMockType {
  return ObjectiveCProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ObjectiveCProtocol`.
public func mock<__ReturnType: ObjectiveCProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ObjectiveCProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ObjectiveCProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ObjectiveCProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ObjectiveCProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ObjectiveCProtocolMock {
  return ObjectiveCProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ObjectiveCProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ObjectiveCProtocolMock' or use 'dummy(ObjectiveCProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ObjectiveCProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked OnlyDebugCompilationDirectiveProtocol

#if DEBUG

public final class OnlyDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol, Mockingbird.Mock, OnlyDebugCompilationDirectiveProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OnlyDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if !(!(DEBUG))

  // MARK: Mocked extensionVariable

  public var `extensionVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extensionVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getExtensionVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extensionVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if DEBUG

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if DEBUG

public protocol OnlyDebugCompilationDirectiveProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OnlyDebugCompilationDirectiveProtocolAbstractMockType {
  return OnlyDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol`.
public func mock<__ReturnType: OnlyDebugCompilationDirectiveProtocolAbstractMockType>(_ type: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OnlyDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol`.
public func dummy(_ type: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OnlyDebugCompilationDirectiveProtocolMock {
  return OnlyDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'OnlyDebugCompilationDirectiveProtocolMock' or use 'dummy(OnlyDebugCompilationDirectiveProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol.Protocol) -> __ReturnType { fatalError() }

#endif

// MARK: - Mocked OpaqueClassSelfConstrainedAssociatedTypeProtocol

public final class OpaqueClassSelfConstrainedAssociatedTypeProtocolMock: AppKit.NSViewController, MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol, Mockingbird.Mock, OpaqueClassSelfConstrainedAssociatedTypeProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolMock? {
        let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock? = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(coder: `coder`)
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolMock {
        let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolAbstractMockType? {
      let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock? = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: OpaqueClassSelfConstrainedAssociatedTypeProtocolAbstractMockType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock? = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'OpaqueClassSelfConstrainedAssociatedTypeProtocolMock' or use 'dummy(OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }

    public func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolAbstractMockType {
      let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: OpaqueClassSelfConstrainedAssociatedTypeProtocolAbstractMockType>(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'OpaqueClassSelfConstrainedAssociatedTypeProtocolMock' or use 'dummy(OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol OpaqueClassSelfConstrainedAssociatedTypeProtocolAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol`.
public func mock<__ReturnType: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy>(_ type: MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol`.
public func dummy(_ type: MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy.Dummy {
  return OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked OpaqueProtocolSelfConstrainedAssociatedTypeProtocol

public final class OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock: MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol, Swift.Hashable, Mockingbird.Mock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked hashValue

  public var `hashValue`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
  }

  public func getHashValue() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock)

  public static func ==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool {
      return concreteImplementation(`lhs`, `rhs`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: @escaping @autoclosure () -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout Hasher) -> Void {
      concreteImplementation(&`hasher`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol OpaqueProtocolSelfConstrainedAssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol`.
public func mock(_ type: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolAbstractMockType {
  return OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol`.
public func mock<__ReturnType: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolAbstractMockType>(_ type: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol`.
public func dummy(_ type: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock {
  return OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock' or use 'dummy(OpaqueProtocolSelfConstrainedAssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked OpaqueViewController

public final class OpaqueViewControllerMock: MockingbirdTestsHost.OpaqueViewController, Mockingbird.Mock, OpaqueViewControllerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OpaqueViewControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> OpaqueViewControllerMock? {
        let mock: OpaqueViewControllerMock? = OpaqueViewControllerMock(coder: `coder`)
        mock?.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> OpaqueViewControllerMock {
        let mock: OpaqueViewControllerMock = OpaqueViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> OpaqueViewControllerAbstractMockType? {
      let mock: OpaqueViewControllerMock? = OpaqueViewControllerMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: OpaqueViewControllerAbstractMockType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? {
      let mock: OpaqueViewControllerMock? = OpaqueViewControllerMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'OpaqueViewControllerMock' or use 'dummy(OpaqueViewControllerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType? { fatalError() }

    public func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> OpaqueViewControllerAbstractMockType {
      let mock: OpaqueViewControllerMock = OpaqueViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: OpaqueViewControllerAbstractMockType>(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: OpaqueViewControllerMock = OpaqueViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'OpaqueViewControllerMock' or use 'dummy(OpaqueViewControllerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol OpaqueViewControllerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueViewController`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(OpaqueViewControllerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.OpaqueViewController.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return OpaqueViewControllerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueViewController`.
public func mock<__ReturnType: OpaqueViewControllerMock.InitializerProxy>(_ type: MockingbirdTestsHost.OpaqueViewController.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OpaqueViewControllerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OpaqueViewController`.
public func dummy(_ type: MockingbirdTestsHost.OpaqueViewController.Type, file: StaticString = #file, line: UInt = #line) -> OpaqueViewControllerMock.InitializerProxy.Dummy {
  return OpaqueViewControllerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueViewController`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(OpaqueViewControllerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OpaqueViewController.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked OptionalsProtocol

public final class OptionalsProtocolMock: MockingbirdTestsHost.OptionalsProtocol, Mockingbird.Mock, OptionalsProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OptionalsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked multiUnwrappedOptionalVariable

  public var `multiUnwrappedOptionalVariable`: Bool???! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multiUnwrappedOptionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool???)()
    }
  }

  public func getMultiUnwrappedOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multiUnwrappedOptionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: Bool? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool?)()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool?, Bool?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool?, Bool?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked unwrappedOptionalVariable

  public var `unwrappedOptionalVariable`: Bool! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "unwrappedOptionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getUnwrappedOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "unwrappedOptionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithMultiOptionalParameter`(`param`: Bool???)

  public func `methodWithMultiOptionalParameter`(`param`: Bool???) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalParameter`(`param`: Bool???) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool???) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithMultiOptionalParameter`(`param`: @escaping @autoclosure () -> Bool???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalParameter`(`param`: Bool???) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiOptionalReturn`()

  public func `methodWithMultiOptionalReturn`() -> Bool??? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalReturn`() -> Bool???", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool??? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool???)()
    }
  }

  public func `methodWithMultiOptionalReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalReturn`() -> Bool???", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiOptionalVariadicParameter`(`param`: Bool???...)

  public func `methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool???]) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithMultiOptionalVariadicParameter`(`param`: @escaping @autoclosure () -> [Bool???]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!)

  public func `methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((Bool?, Int)???) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: @escaping @autoclosure () -> (Bool?, Int)???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalCompoundReturn`()

  public func `methodWithMultiUnwrappedOptionalCompoundReturn`() -> (Bool?, Int)???! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundReturn`() -> (Bool?, Int)???!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Bool?, Int)??? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Bool?, Int)???)()
    }
  }

  public func `methodWithMultiUnwrappedOptionalCompoundReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int)???, (Bool?, Int)???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundReturn`() -> (Bool?, Int)???!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int)???, (Bool?, Int)???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!)

  public func `methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool???) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithMultiUnwrappedOptionalParameter`(`param`: @escaping @autoclosure () -> Bool???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalReturn`()

  public func `methodWithMultiUnwrappedOptionalReturn`() -> Bool???! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalReturn`() -> Bool???!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool??? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool???)()
    }
  }

  public func `methodWithMultiUnwrappedOptionalReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalReturn`() -> Bool???!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalParameter`(`param`: Bool?)

  public func `methodWithOptionalParameter`(`param`: Bool?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalParameter`(`param`: Bool?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool?) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithOptionalParameter`(`param`: @escaping @autoclosure () -> Bool?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalParameter`(`param`: Bool?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalReturn`()

  public func `methodWithOptionalReturn`() -> Bool? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalReturn`() -> Bool?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool?)()
    }
  }

  public func `methodWithOptionalReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool?, Bool?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalReturn`() -> Bool?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool?, Bool?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalVariadicParameter`(`param`: Bool?...)

  public func `methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool?]) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithOptionalVariadicParameter`(`param`: @escaping @autoclosure () -> [Bool?]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!)

  public func `methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((Bool?, Int)) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithUnwrappedCompoundParameter`(`param`: @escaping @autoclosure () -> (Bool?, Int)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedCompoundReturn`()

  public func `methodWithUnwrappedCompoundReturn`() -> (Bool?, Int)! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundReturn`() -> (Bool?, Int)!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Bool?, Int) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Bool?, Int))()
    }
  }

  public func `methodWithUnwrappedCompoundReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int), (Bool?, Int)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundReturn`() -> (Bool?, Int)!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int), (Bool?, Int)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedParameter`(`param`: Bool!)

  public func `methodWithUnwrappedParameter`(`param`: Bool!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedParameter`(`param`: Bool!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `methodWithUnwrappedParameter`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedParameter`(`param`: Bool!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedReturn`()

  public func `methodWithUnwrappedReturn`() -> Bool! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedReturn`() -> Bool!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `methodWithUnwrappedReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedReturn`() -> Bool!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol OptionalsProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.OptionalsProtocol`.
public func mock(_ type: MockingbirdTestsHost.OptionalsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OptionalsProtocolAbstractMockType {
  return OptionalsProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OptionalsProtocol`.
public func mock<__ReturnType: OptionalsProtocolAbstractMockType>(_ type: MockingbirdTestsHost.OptionalsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OptionalsProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OptionalsProtocol`.
public func dummy(_ type: MockingbirdTestsHost.OptionalsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OptionalsProtocolMock {
  return OptionalsProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OptionalsProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'OptionalsProtocolMock' or use 'dummy(OptionalsProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OptionalsProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked OverloadedMethodsClass

public final class OverloadedMethodsClassMock: MockingbirdTestsHost.OverloadedMethodsClass, Mockingbird.Mock, OverloadedMethodsClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `overloadedParameters`<T>(`param1`: T, `param2`: T)

  public override func `overloadedParameters`<T>(`param1`: T, `param2`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T, T) -> T {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `overloadedParameters`<T>(`param1`: @escaping @autoclosure () -> T, `param2`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Bool, `param2`: Bool)

  public override func `overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Bool, `param2`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Int, `param2`: Int)

  public override func `overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Int, `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`<T>()

  public override func `overloadedReturnType`<T>() -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> T {
      return concreteImplementation()
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `overloadedReturnType`<T>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public override func `overloadedReturnType`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public override func `overloadedReturnType`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }
}

public protocol OverloadedMethodsClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.OverloadedMethodsClass`.
public func mock(_ type: MockingbirdTestsHost.OverloadedMethodsClass.Type, file: StaticString = #file, line: UInt = #line) -> OverloadedMethodsClassAbstractMockType {
  return OverloadedMethodsClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.OverloadedMethodsClass`.
public func mock<__ReturnType: OverloadedMethodsClassAbstractMockType>(_ type: MockingbirdTestsHost.OverloadedMethodsClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OverloadedMethodsClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OverloadedMethodsClass`.
public func dummy(_ type: MockingbirdTestsHost.OverloadedMethodsClass.Type, file: StaticString = #file, line: UInt = #line) -> OverloadedMethodsClassMock {
  return OverloadedMethodsClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.OverloadedMethodsClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'OverloadedMethodsClassMock' or use 'dummy(OverloadedMethodsClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OverloadedMethodsClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked OverloadedMethodsProtocol

public final class OverloadedMethodsProtocolMock: MockingbirdTestsHost.OverloadedMethodsProtocol, Mockingbird.Mock, OverloadedMethodsProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `overloadedParameters`<T>(`param1`: T, `param2`: T)

  public func `overloadedParameters`<T>(`param1`: T, `param2`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T, T) -> T {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `overloadedParameters`<T>(`param1`: @escaping @autoclosure () -> T, `param2`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Bool, `param2`: Bool)

  public func `overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Bool, `param2`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Int, `param2`: Int)

  public func `overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Int, `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`<T>()

  public func `overloadedReturnType`<T>() -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> T {
      return concreteImplementation()
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `overloadedReturnType`<T>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public func `overloadedReturnType`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public func `overloadedReturnType`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }
}

public protocol OverloadedMethodsProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverloadedMethodsProtocol`.
public func mock(_ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OverloadedMethodsProtocolAbstractMockType {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverloadedMethodsProtocol`.
public func mock<__ReturnType: OverloadedMethodsProtocolAbstractMockType>(_ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OverloadedMethodsProtocol`.
public func dummy(_ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OverloadedMethodsProtocolMock {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverloadedMethodsProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'OverloadedMethodsProtocolMock' or use 'dummy(OverloadedMethodsProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked OverriddenIncludedSource

public final class OverriddenIncludedSourceMock: MockingbirdTestsHost.OverriddenIncludedSource, Mockingbird.Mock, OverriddenIncludedSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverriddenIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol OverriddenIncludedSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverriddenIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.OverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> OverriddenIncludedSourceAbstractMockType {
  return OverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverriddenIncludedSource`.
public func mock<__ReturnType: OverriddenIncludedSourceAbstractMockType>(_ type: MockingbirdTestsHost.OverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return OverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.OverriddenIncludedSource`.
public func dummy(_ type: MockingbirdTestsHost.OverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> OverriddenIncludedSourceMock {
  return OverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverriddenIncludedSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'OverriddenIncludedSourceMock' or use 'dummy(OverriddenIncludedSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.OverriddenIncludedSource.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ParameterizedInitializerClass

public final class ParameterizedInitializerClassMock: MockingbirdTestsHost.ParameterizedInitializerClass, Mockingbird.Mock, ParameterizedInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> ParameterizedInitializerClassMock {
        let mock: ParameterizedInitializerClassMock = ParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> ParameterizedInitializerClassAbstractMockType {
      let mock: ParameterizedInitializerClassMock = ParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: ParameterizedInitializerClassAbstractMockType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: ParameterizedInitializerClassMock = ParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'ParameterizedInitializerClassMock' or use 'dummy(ParameterizedInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required override init(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ParameterizedInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ParameterizedInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(ParameterizedInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return ParameterizedInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ParameterizedInitializerClass`.
public func mock<__ReturnType: ParameterizedInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ParameterizedInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ParameterizedInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> ParameterizedInitializerClassMock.InitializerProxy.Dummy {
  return ParameterizedInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ParameterizedInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(ParameterizedInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ParameterizedInitializerProtocol

public final class ParameterizedInitializerProtocolMock: MockingbirdTestsHost.ParameterizedInitializerProtocol, Mockingbird.Mock, ParameterizedInitializerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required init(`param1`: Bool, `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol ParameterizedInitializerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParameterizedInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ParameterizedInitializerProtocolAbstractMockType {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParameterizedInitializerProtocol`.
public func mock<__ReturnType: ParameterizedInitializerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ParameterizedInitializerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ParameterizedInitializerProtocolMock {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParameterizedInitializerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ParameterizedInitializerProtocolMock' or use 'dummy(ParameterizedInitializerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, Mockingbird.Mock, ParentProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

public protocol ParentProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParentProtocol`.
public func mock(_ type: MockingbirdTestsHost.ParentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ParentProtocolAbstractMockType {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParentProtocol`.
public func mock<__ReturnType: ParentProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ParentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ParentProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ParentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ParentProtocolMock {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParentProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ParentProtocolMock' or use 'dummy(ParentProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ParentProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, Mockingbird.Mock, ParentAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentClassVariable

  override public class var `parentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentComputedInstanceVariable

  override public var `parentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredFileprivateSetterInstanceVariable

  override public var `parentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredInstanceVariable

  override public var `parentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredPrivateSetterInstanceVariable

  override public var `parentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func `parentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod`()

  public override static func `parentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func `parentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public override func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol ParentAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.Parent`.
public func mock(_ type: MockingbirdTestsHost.Parent.Type, file: StaticString = #file, line: UInt = #line) -> ParentAbstractMockType {
  return ParentMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.Parent`.
public func mock<__ReturnType: ParentAbstractMockType>(_ type: MockingbirdTestsHost.Parent.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ParentMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.Parent`.
public func dummy(_ type: MockingbirdTestsHost.Parent.Type, file: StaticString = #file, line: UInt = #line) -> ParentMock {
  return ParentMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.Parent`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ParentMock' or use 'dummy(Parent.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.Parent.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ReferencedGenericClassWithConstraints

public final class ReferencedGenericClassWithConstraintsMock<S: Sequence>: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>, Mockingbird.Mock, ReferencedGenericClassWithConstraintsAbstractMockType where S.Element: Swift.Hashable {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(S.self)"].joined(separator: ",")
    let staticMockIdentifier = "ReferencedGenericClassWithConstraintsMock<S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ReferencedGenericClassWithConstraintsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ReferencedGenericClassWithConstraintsAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>`.
public func mock<S: Sequence>(_ type: ReferencedGenericClassWithConstraintsMock<S>.Type, file: StaticString = #file, line: UInt = #line) -> ReferencedGenericClassWithConstraintsAbstractMockType {
  return ReferencedGenericClassWithConstraintsMock<S>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>`.
public func mock<S: Sequence, __ReturnType: ReferencedGenericClassWithConstraintsAbstractMockType>(_ type: ReferencedGenericClassWithConstraintsMock<S>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ReferencedGenericClassWithConstraintsMock<S>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>`.
public func dummy<S: Sequence>(_ type: ReferencedGenericClassWithConstraintsMock<S>.Type, file: StaticString = #file, line: UInt = #line) -> ReferencedGenericClassWithConstraintsMock<S> {
  return ReferencedGenericClassWithConstraintsMock<S>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ReferencedGenericClassWithConstraintsMock<S>' or use 'dummy(ReferencedGenericClassWithConstraints<S>.self)' to create a non-mockable dummy object")
public func mock<S: Sequence, __ReturnType>(_ type: ReferencedGenericClassWithConstraintsMock<S>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ReferencedGenericClass

public final class ReferencedGenericClassMock<T>: MockingbirdTestsHost.ReferencedGenericClass<T>, Mockingbird.Mock, ReferencedGenericClassAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "ReferencedGenericClassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ReferencedGenericClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ReferencedGenericClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClass<T>`.
public func mock<T>(_ type: ReferencedGenericClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> ReferencedGenericClassAbstractMockType {
  return ReferencedGenericClassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClass<T>`.
public func mock<T, __ReturnType: ReferencedGenericClassAbstractMockType>(_ type: ReferencedGenericClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ReferencedGenericClassMock<T>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ReferencedGenericClass<T>`.
public func dummy<T>(_ type: ReferencedGenericClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> ReferencedGenericClassMock<T> {
  return ReferencedGenericClassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClass<T>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ReferencedGenericClassMock<T>' or use 'dummy(ReferencedGenericClass<T>.self)' to create a non-mockable dummy object")
public func mock<T, __ReturnType>(_ type: ReferencedGenericClassMock<T>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked RelativeSecondLevelFileIncludedSource

public final class RelativeSecondLevelFileIncludedSourceMock: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource, Mockingbird.Mock, RelativeSecondLevelFileIncludedSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RelativeSecondLevelFileIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol RelativeSecondLevelFileIncludedSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> RelativeSecondLevelFileIncludedSourceAbstractMockType {
  return RelativeSecondLevelFileIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource`.
public func mock<__ReturnType: RelativeSecondLevelFileIncludedSourceAbstractMockType>(_ type: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return RelativeSecondLevelFileIncludedSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource`.
public func dummy(_ type: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> RelativeSecondLevelFileIncludedSourceMock {
  return RelativeSecondLevelFileIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'RelativeSecondLevelFileIncludedSourceMock' or use 'dummy(RelativeSecondLevelFileIncludedSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked RequiredInitializerClass

public final class RequiredInitializerClassMock: MockingbirdTestsHost.RequiredInitializerClass, Mockingbird.Mock, RequiredInitializerClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RequiredInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> RequiredInitializerClassMock {
        let mock: RequiredInitializerClassMock = RequiredInitializerClassMock(param1: `param1`, param2: `param2`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> RequiredInitializerClassAbstractMockType {
      let mock: RequiredInitializerClassMock = RequiredInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: RequiredInitializerClassAbstractMockType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: RequiredInitializerClassMock = RequiredInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'RequiredInitializerClassMock' or use 'dummy(RequiredInitializerClassMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required init(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

public protocol RequiredInitializerClassAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.RequiredInitializerClass`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(RequiredInitializerClassMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.RequiredInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return RequiredInitializerClassMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.RequiredInitializerClass`.
public func mock<__ReturnType: RequiredInitializerClassMock.InitializerProxy>(_ type: MockingbirdTestsHost.RequiredInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return RequiredInitializerClassMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.RequiredInitializerClass`.
public func dummy(_ type: MockingbirdTestsHost.RequiredInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> RequiredInitializerClassMock.InitializerProxy.Dummy {
  return RequiredInitializerClassMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.RequiredInitializerClass`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(RequiredInitializerClassMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.RequiredInitializerClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked RethrowingProtocol

public final class RethrowingProtocolMock: MockingbirdTestsHost.RethrowingProtocol, Mockingbird.Mock, RethrowingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RethrowingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `rethrowingMethod`(`block`: () throws -> Bool)

  public func `rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() throws -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() throws -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `rethrowingMethod`(`block`: @escaping @autoclosure () -> () throws -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `rethrowingMethod`(`block`: () throws -> Bool)

  public func `rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() throws -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (() throws -> Bool) -> Void {
      concreteImplementation(`block`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `rethrowingMethod`(`block`: @escaping @autoclosure () -> () throws -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol RethrowingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.RethrowingProtocol`.
public func mock(_ type: MockingbirdTestsHost.RethrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> RethrowingProtocolAbstractMockType {
  return RethrowingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.RethrowingProtocol`.
public func mock<__ReturnType: RethrowingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.RethrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return RethrowingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.RethrowingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.RethrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> RethrowingProtocolMock {
  return RethrowingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.RethrowingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'RethrowingProtocolMock' or use 'dummy(RethrowingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.RethrowingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked SecondLevelSelfConstrainedAssociatedTypeProtocol

public final class SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol, MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, Mockingbird.Mock, SecondLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(SequenceType.self)"].joined(separator: ",")
    let staticMockIdentifier = "SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SecondLevelSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SequenceType) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock)

  public func `request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol SecondLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable>(_ type: SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> SecondLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType {
  return SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable, __ReturnType: SecondLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType>(_ type: SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol`.
public func dummy<SequenceType: Sequence & Swift.Hashable>(_ type: SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType> {
  return SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>' or use 'dummy(SecondLevelSelfConstrainedAssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<SequenceType: Sequence & Swift.Hashable, __ReturnType>(_ type: SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked ServiceRepository

public final class ServiceRepositoryMock: MockingbirdTestsHost.ServiceRepository, Mockingbird.Mock, ServiceRepositoryAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ServiceRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked testManager

  public var `testManager`: MockingbirdTestsHost.TestManager {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.TestManager)()
    }
  }

  public func getTestManager() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ServiceRepositoryAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ServiceRepository`.
public func mock(_ type: MockingbirdTestsHost.ServiceRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> ServiceRepositoryAbstractMockType {
  return ServiceRepositoryMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ServiceRepository`.
public func mock<__ReturnType: ServiceRepositoryAbstractMockType>(_ type: MockingbirdTestsHost.ServiceRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ServiceRepositoryMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ServiceRepository`.
public func dummy(_ type: MockingbirdTestsHost.ServiceRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> ServiceRepositoryMock {
  return ServiceRepositoryMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ServiceRepository`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ServiceRepositoryMock' or use 'dummy(ServiceRepository.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ServiceRepository.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ShadowedGenericType

public final class ShadowedGenericTypeMock<ShadowedType>: MockingbirdTestsHost.ShadowedGenericType<ShadowedType>, Mockingbird.Mock, ShadowedGenericTypeAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ShadowedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "ShadowedGenericTypeMock<ShadowedType>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ShadowedGenericTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `shadowedClassScope`(`param`: ShadowedType)

  public override func `shadowedClassScope`(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ShadowedType)()
    }
  }

  public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

  public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ShadowedType)()
    }
  }

  public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }

  // MARK: - Mocked NestedShadowedGenericType

  public final class NestedShadowedGenericTypeMock: NestedShadowedGenericType, Mockingbird.Mock, ShadowedGenericTypeAbstractMockType_NestedShadowedGenericTypeAbstractMockType {
    static var staticMock: Mockingbird.StaticMock {
      let runtimeGenericTypeNames = [].joined(separator: ",")
      let staticMockIdentifier = "NestedShadowedGenericTypeMock," + runtimeGenericTypeNames
      if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
      let staticMock = Mockingbird.StaticMock()
      genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
      return staticMock
    }
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        NestedShadowedGenericTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }

    // MARK: Mocked `shadowedClassScope`(`param`: ShadowedType)

    public override func `shadowedClassScope`(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else {
        return (implementation as! () -> ShadowedType)()
      }
    }

    public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }

    // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

    public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else {
        return (implementation as! () -> ShadowedType)()
      }
    }

    public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }
  }

  // MARK: - Mocked NestedDoublyShadowedGenericType

  public final class NestedDoublyShadowedGenericTypeMock<ShadowedType>: NestedDoublyShadowedGenericType<ShadowedType>, Mockingbird.Mock, ShadowedGenericTypeAbstractMockType_NestedDoublyShadowedGenericTypeAbstractMockType {
    static var staticMock: Mockingbird.StaticMock {
      let runtimeGenericTypeNames = ["\(ShadowedType.self)"].joined(separator: ",")
      let staticMockIdentifier = "NestedDoublyShadowedGenericTypeMock<ShadowedType>," + runtimeGenericTypeNames
      if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
      let staticMock = Mockingbird.StaticMock()
      genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
      return staticMock
    }
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        NestedDoublyShadowedGenericTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }

    // MARK: Mocked `shadowedClassScope`(`param`: ShadowedType)

    public override func `shadowedClassScope`(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else {
        return (implementation as! () -> ShadowedType)()
      }
    }

    public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }

    // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

    public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else {
        return (implementation as! () -> ShadowedType)()
      }
    }

    public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }
  }
}

public protocol ShadowedGenericTypeAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.ShadowedGenericType<ShadowedType>`.
public func mock<ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeAbstractMockType {
  return ShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ShadowedGenericType<ShadowedType>`.
public func mock<ShadowedType, __ReturnType: ShadowedGenericTypeAbstractMockType>(_ type: ShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ShadowedGenericType<ShadowedType>`.
public func dummy<ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeMock<ShadowedType> {
  return ShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.ShadowedGenericType<ShadowedType>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ShadowedGenericTypeMock<ShadowedType>' or use 'dummy(ShadowedGenericType<ShadowedType>.self)' to create a non-mockable dummy object")
public func mock<ShadowedType, __ReturnType>(_ type: ShadowedGenericTypeMock<ShadowedType>.Type) -> __ReturnType { fatalError() }

public protocol ShadowedGenericTypeAbstractMockType_NestedShadowedGenericTypeAbstractMockType {}

/// Initialize a class mock of `NestedShadowedGenericType`.
public func mock<ShadowedGenericType_ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeAbstractMockType_NestedShadowedGenericTypeAbstractMockType {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `NestedShadowedGenericType`.
public func mock<ShadowedGenericType_ShadowedType, __ReturnType: ShadowedGenericTypeAbstractMockType_NestedShadowedGenericTypeAbstractMockType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `NestedShadowedGenericType`.
public func dummy<ShadowedGenericType_ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `NestedShadowedGenericType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock' or use 'dummy(ShadowedGenericType<ShadowedGenericType_ShadowedType>.NestedShadowedGenericType.self)' to create a non-mockable dummy object")
public func mock<ShadowedGenericType_ShadowedType, __ReturnType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock.Type) -> __ReturnType { fatalError() }

public protocol ShadowedGenericTypeAbstractMockType_NestedDoublyShadowedGenericTypeAbstractMockType {}

/// Initialize a class mock of `NestedDoublyShadowedGenericType<ShadowedType>`.
public func mock<ShadowedGenericType_ShadowedType, ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeAbstractMockType_NestedDoublyShadowedGenericTypeAbstractMockType {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `NestedDoublyShadowedGenericType<ShadowedType>`.
public func mock<ShadowedGenericType_ShadowedType, ShadowedType, __ReturnType: ShadowedGenericTypeAbstractMockType_NestedDoublyShadowedGenericTypeAbstractMockType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `NestedDoublyShadowedGenericType<ShadowedType>`.
public func dummy<ShadowedGenericType_ShadowedType, ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType> {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `NestedDoublyShadowedGenericType<ShadowedType>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>' or use 'dummy(ShadowedGenericType<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericType<ShadowedType>.self)' to create a non-mockable dummy object")
public func mock<ShadowedGenericType_ShadowedType, ShadowedType, __ReturnType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SpecializedGenericProtocol

public final class SpecializedGenericProtocolMock: MockingbirdTestsHost.GenericBaseClass<Bool>, MockingbirdTestsHost.SpecializedGenericProtocol, Mockingbird.Mock, SpecializedGenericProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedGenericProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: Bool)

  public override func `baseMethod`(`param`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol SpecializedGenericProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedGenericProtocol`.
public func mock(_ type: MockingbirdTestsHost.SpecializedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> SpecializedGenericProtocolAbstractMockType {
  return SpecializedGenericProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedGenericProtocol`.
public func mock<__ReturnType: SpecializedGenericProtocolAbstractMockType>(_ type: MockingbirdTestsHost.SpecializedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SpecializedGenericProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SpecializedGenericProtocol`.
public func dummy(_ type: MockingbirdTestsHost.SpecializedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> SpecializedGenericProtocolMock {
  return SpecializedGenericProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedGenericProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'SpecializedGenericProtocolMock' or use 'dummy(SpecializedGenericProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SpecializedGenericProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked SpecializedGenericSubclass

public final class SpecializedGenericSubclassMock: MockingbirdTestsHost.SpecializedGenericSubclass, Mockingbird.Mock, SpecializedGenericSubclassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: Bool)

  public override func `baseMethod`(`param`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol SpecializedGenericSubclassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedGenericSubclass`.
public func mock(_ type: MockingbirdTestsHost.SpecializedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> SpecializedGenericSubclassAbstractMockType {
  return SpecializedGenericSubclassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedGenericSubclass`.
public func mock<__ReturnType: SpecializedGenericSubclassAbstractMockType>(_ type: MockingbirdTestsHost.SpecializedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SpecializedGenericSubclassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SpecializedGenericSubclass`.
public func dummy(_ type: MockingbirdTestsHost.SpecializedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> SpecializedGenericSubclassMock {
  return SpecializedGenericSubclassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedGenericSubclass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'SpecializedGenericSubclassMock' or use 'dummy(SpecializedGenericSubclass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SpecializedGenericSubclass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SpecializedShadowedGenericProtocol

public final class SpecializedShadowedGenericProtocolMock: MockingbirdTestsHost.ShadowedGenericType<MockingbirdTestsHost.NSObject>, MockingbirdTestsHost.SpecializedShadowedGenericProtocol, Mockingbird.Mock, SpecializedShadowedGenericProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedShadowedGenericProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject)

  public override func `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject)()
    }
  }

  public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

  public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ShadowedType)()
    }
  }

  public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }
}

public protocol SpecializedShadowedGenericProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedShadowedGenericProtocol`.
public func mock(_ type: MockingbirdTestsHost.SpecializedShadowedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> SpecializedShadowedGenericProtocolAbstractMockType {
  return SpecializedShadowedGenericProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedShadowedGenericProtocol`.
public func mock<__ReturnType: SpecializedShadowedGenericProtocolAbstractMockType>(_ type: MockingbirdTestsHost.SpecializedShadowedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SpecializedShadowedGenericProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SpecializedShadowedGenericProtocol`.
public func dummy(_ type: MockingbirdTestsHost.SpecializedShadowedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> SpecializedShadowedGenericProtocolMock {
  return SpecializedShadowedGenericProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedShadowedGenericProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'SpecializedShadowedGenericProtocolMock' or use 'dummy(SpecializedShadowedGenericProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SpecializedShadowedGenericProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked SpecializedShadowedGenericSubclass

public final class SpecializedShadowedGenericSubclassMock: MockingbirdTestsHost.SpecializedShadowedGenericSubclass, Mockingbird.Mock, SpecializedShadowedGenericSubclassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedShadowedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject)

  public override func `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject)()
    }
  }

  public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

  public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ShadowedType)()
    }
  }

  public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }
}

public protocol SpecializedShadowedGenericSubclassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedShadowedGenericSubclass`.
public func mock(_ type: MockingbirdTestsHost.SpecializedShadowedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> SpecializedShadowedGenericSubclassAbstractMockType {
  return SpecializedShadowedGenericSubclassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedShadowedGenericSubclass`.
public func mock<__ReturnType: SpecializedShadowedGenericSubclassAbstractMockType>(_ type: MockingbirdTestsHost.SpecializedShadowedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SpecializedShadowedGenericSubclassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SpecializedShadowedGenericSubclass`.
public func dummy(_ type: MockingbirdTestsHost.SpecializedShadowedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> SpecializedShadowedGenericSubclassMock {
  return SpecializedShadowedGenericSubclassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedShadowedGenericSubclass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'SpecializedShadowedGenericSubclassMock' or use 'dummy(SpecializedShadowedGenericSubclass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SpecializedShadowedGenericSubclass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SubclassingExternalClassWithDesignatedIntializer

public final class SubclassingExternalClassWithDesignatedIntializerMock: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer, Mockingbird.Mock, SubclassingExternalClassWithDesignatedIntializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalClassWithDesignatedIntializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalClassWithDesignatedIntializerMock {
        let mock: SubclassingExternalClassWithDesignatedIntializerMock = SubclassingExternalClassWithDesignatedIntializerMock(param1: `param1`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalClassWithDesignatedIntializerAbstractMockType {
      let mock: SubclassingExternalClassWithDesignatedIntializerMock = SubclassingExternalClassWithDesignatedIntializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: SubclassingExternalClassWithDesignatedIntializerAbstractMockType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: SubclassingExternalClassWithDesignatedIntializerMock = SubclassingExternalClassWithDesignatedIntializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'SubclassingExternalClassWithDesignatedIntializerMock' or use 'dummy(SubclassingExternalClassWithDesignatedIntializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`param1`: Bool)

  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol SubclassingExternalClassWithDesignatedIntializerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(SubclassingExternalClassWithDesignatedIntializerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer`.
public func mock<__ReturnType: SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy>(_ type: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer`.
public func dummy(_ type: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy.Dummy {
  return SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(SubclassingExternalClassWithDesignatedIntializerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SubclassingExternalClassWithInheritedIntializer

public final class SubclassingExternalClassWithInheritedIntializerMock: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer, Mockingbird.Mock, SubclassingExternalClassWithInheritedIntializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalClassWithInheritedIntializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalClassWithInheritedIntializerMock {
        let mock: SubclassingExternalClassWithInheritedIntializerMock = SubclassingExternalClassWithInheritedIntializerMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalClassWithInheritedIntializerAbstractMockType {
      let mock: SubclassingExternalClassWithInheritedIntializerMock = SubclassingExternalClassWithInheritedIntializerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: SubclassingExternalClassWithInheritedIntializerAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: SubclassingExternalClassWithInheritedIntializerMock = SubclassingExternalClassWithInheritedIntializerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'SubclassingExternalClassWithInheritedIntializerMock' or use 'dummy(SubclassingExternalClassWithInheritedIntializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol SubclassingExternalClassWithInheritedIntializerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(SubclassingExternalClassWithInheritedIntializerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer`.
public func mock<__ReturnType: SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy>(_ type: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer`.
public func dummy(_ type: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy.Dummy {
  return SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(SubclassingExternalClassWithInheritedIntializerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SubclassingExternalSubclassWithDesignatedInitializer

public final class SubclassingExternalSubclassWithDesignatedInitializerMock: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer, Mockingbird.Mock, SubclassingExternalSubclassWithDesignatedInitializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalSubclassWithDesignatedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalSubclassWithDesignatedInitializerMock {
        let mock: SubclassingExternalSubclassWithDesignatedInitializerMock = SubclassingExternalSubclassWithDesignatedInitializerMock(param1: `param1`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalSubclassWithDesignatedInitializerAbstractMockType {
      let mock: SubclassingExternalSubclassWithDesignatedInitializerMock = SubclassingExternalSubclassWithDesignatedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: SubclassingExternalSubclassWithDesignatedInitializerAbstractMockType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: SubclassingExternalSubclassWithDesignatedInitializerMock = SubclassingExternalSubclassWithDesignatedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'SubclassingExternalSubclassWithDesignatedInitializerMock' or use 'dummy(SubclassingExternalSubclassWithDesignatedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked baseOpenVariable

  override public var `baseOpenVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getBaseOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setBaseOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `baseOpenMethod`()

  public override func `baseOpenMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `baseOpenMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`param1`: Bool)

  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol SubclassingExternalSubclassWithDesignatedInitializerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(SubclassingExternalSubclassWithDesignatedInitializerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer`.
public func mock<__ReturnType: SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy>(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer`.
public func dummy(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy.Dummy {
  return SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(SubclassingExternalSubclassWithDesignatedInitializerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SubclassingExternalSubclassWithInheritedInitializer

public final class SubclassingExternalSubclassWithInheritedInitializerMock: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer, Mockingbird.Mock, SubclassingExternalSubclassWithInheritedInitializerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalSubclassWithInheritedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalSubclassWithInheritedInitializerMock {
        let mock: SubclassingExternalSubclassWithInheritedInitializerMock = SubclassingExternalSubclassWithInheritedInitializerMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalSubclassWithInheritedInitializerAbstractMockType {
      let mock: SubclassingExternalSubclassWithInheritedInitializerMock = SubclassingExternalSubclassWithInheritedInitializerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: SubclassingExternalSubclassWithInheritedInitializerAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: SubclassingExternalSubclassWithInheritedInitializerMock = SubclassingExternalSubclassWithInheritedInitializerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'SubclassingExternalSubclassWithInheritedInitializerMock' or use 'dummy(SubclassingExternalSubclassWithInheritedInitializerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked baseOpenVariable

  override public var `baseOpenVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getBaseOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setBaseOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `baseOpenMethod`()

  public override func `baseOpenMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `baseOpenMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol SubclassingExternalSubclassWithInheritedInitializerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(SubclassingExternalSubclassWithInheritedInitializerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer`.
public func mock<__ReturnType: SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy>(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer`.
public func dummy(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy.Dummy {
  return SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(SubclassingExternalSubclassWithInheritedInitializerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked SubclassingExternalTopLevelType

public final class SubclassingExternalTopLevelTypeMock: MockingbirdTestsHost.SubclassingExternalTopLevelType, Mockingbird.Mock, SubclassingExternalTopLevelTypeAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalTopLevelTypeMock {
        let mock: SubclassingExternalTopLevelTypeMock = SubclassingExternalTopLevelTypeMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalTopLevelTypeAbstractMockType {
      let mock: SubclassingExternalTopLevelTypeMock = SubclassingExternalTopLevelTypeMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: SubclassingExternalTopLevelTypeAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: SubclassingExternalTopLevelTypeMock = SubclassingExternalTopLevelTypeMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'SubclassingExternalTopLevelTypeMock' or use 'dummy(SubclassingExternalTopLevelTypeMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked secondLevelType

  override public var `secondLevelType`: SecondLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> SecondLevelType)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (SecondLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSecondLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> SecondLevelType, SecondLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> SecondLevelType, SecondLevelType>(mock: self, invocation: invocation)
  }

  public func setSecondLevelType(_ newValue: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (SecondLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (SecondLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol SubclassingExternalTopLevelTypeAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalTopLevelType`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(SubclassingExternalTopLevelTypeMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return SubclassingExternalTopLevelTypeMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalTopLevelType`.
public func mock<__ReturnType: SubclassingExternalTopLevelTypeMock.InitializerProxy>(_ type: MockingbirdTestsHost.SubclassingExternalTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return SubclassingExternalTopLevelTypeMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.SubclassingExternalTopLevelType`.
public func dummy(_ type: MockingbirdTestsHost.SubclassingExternalTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalTopLevelTypeMock.InitializerProxy.Dummy {
  return SubclassingExternalTopLevelTypeMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalTopLevelType`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(SubclassingExternalTopLevelTypeMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.SubclassingExternalTopLevelType.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked TestCase

public final class TestCaseMock: MockingbirdTestsHost.TestCase, Mockingbird.Mock, TestCaseAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestCaseMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `run`(`description`: String)

  public func `run`(`description`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`run`(`description`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`description`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`description`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `run`(`description`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`description`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`run`(`description`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol TestCaseAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestCase`.
public func mock(_ type: MockingbirdTestsHost.TestCase.Protocol, file: StaticString = #file, line: UInt = #line) -> TestCaseAbstractMockType {
  return TestCaseMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestCase`.
public func mock<__ReturnType: TestCaseAbstractMockType>(_ type: MockingbirdTestsHost.TestCase.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TestCaseMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TestCase`.
public func dummy(_ type: MockingbirdTestsHost.TestCase.Protocol, file: StaticString = #file, line: UInt = #line) -> TestCaseMock {
  return TestCaseMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestCase`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TestCaseMock' or use 'dummy(TestCase.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TestCase.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked TestManager

public final class TestManagerMock: MockingbirdTestsHost.TestManager, Mockingbird.Mock, TestManagerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestManagerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked currentTest

  public var `currentTest`: MockingbirdTestsHost.Test {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.Test)()
    }
  }

  public func getCurrentTest() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `stopTests`()

  public func `stopTests`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopTests`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `stopTests`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopTests`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol TestManagerAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestManager`.
public func mock(_ type: MockingbirdTestsHost.TestManager.Protocol, file: StaticString = #file, line: UInt = #line) -> TestManagerAbstractMockType {
  return TestManagerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestManager`.
public func mock<__ReturnType: TestManagerAbstractMockType>(_ type: MockingbirdTestsHost.TestManager.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TestManagerMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TestManager`.
public func dummy(_ type: MockingbirdTestsHost.TestManager.Protocol, file: StaticString = #file, line: UInt = #line) -> TestManagerMock {
  return TestManagerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestManager`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TestManagerMock' or use 'dummy(TestManager.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TestManager.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked Test

public final class TestMock: MockingbirdTestsHost.Test, Mockingbird.Mock, TestAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked testCase

  public var `testCase`: MockingbirdTestsHost.TestCase {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.TestCase)()
    }
  }

  public func getTestCase() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `add`(`testCase`: MockingbirdTestsHost.TestCase)

  public func `add`(`testCase`: MockingbirdTestsHost.TestCase) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`testCase`: MockingbirdTestsHost.TestCase) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`testCase`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TestCase) -> Bool {
      return concreteImplementation(`testCase`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `add`(`testCase`: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TestCase) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`testCase`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`testCase`: MockingbirdTestsHost.TestCase) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TestCase) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol TestAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.Test`.
public func mock(_ type: MockingbirdTestsHost.Test.Protocol, file: StaticString = #file, line: UInt = #line) -> TestAbstractMockType {
  return TestMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.Test`.
public func mock<__ReturnType: TestAbstractMockType>(_ type: MockingbirdTestsHost.Test.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TestMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.Test`.
public func dummy(_ type: MockingbirdTestsHost.Test.Protocol, file: StaticString = #file, line: UInt = #line) -> TestMock {
  return TestMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.Test`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TestMock' or use 'dummy(Test.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.Test.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ThrowingProtocol

public final class ThrowingProtocolMock: MockingbirdTestsHost.ThrowingProtocol, Mockingbird.Mock, ThrowingProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ThrowingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `throwingMethod`()

  public func `throwingMethod`() throws -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () throws -> Bool {
      return try concreteImplementation()
    } else {
      return try (implementation as! () throws -> Bool)()
    }
  }

  public func `throwingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `throwingMethod`()

  public func `throwingMethod`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `throwingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `throwingMethod`(`block`: () throws -> Bool)

  public func `throwingMethod`(`block`: () throws -> Bool) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`(`block`: () throws -> Bool) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() throws -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (() throws -> Bool) throws -> Void {
      try concreteImplementation(`block`)
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `throwingMethod`(`block`: @escaping @autoclosure () -> () throws -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`(`block`: () throws -> Bool) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) throws -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol ThrowingProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ThrowingProtocol`.
public func mock(_ type: MockingbirdTestsHost.ThrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ThrowingProtocolAbstractMockType {
  return ThrowingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ThrowingProtocol`.
public func mock<__ReturnType: ThrowingProtocolAbstractMockType>(_ type: MockingbirdTestsHost.ThrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ThrowingProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ThrowingProtocol`.
public func dummy(_ type: MockingbirdTestsHost.ThrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ThrowingProtocolMock {
  return ThrowingProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ThrowingProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ThrowingProtocolMock' or use 'dummy(ThrowingProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ThrowingProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked TopLevelSelfConstrainedAssociatedTypeProtocol

public final class TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol, MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol, Mockingbird.Mock, TopLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType where Element: Swift.Hashable {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(Element.self)", "\(SequenceType.self)"].joined(separator: ",")
    let staticMockIdentifier = "TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SequenceType) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock)

  public func `request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

public protocol TopLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol`.
public func mock<Element, SequenceType: Sequence & Swift.Hashable>(_ type: TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType {
  return TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol`.
public func mock<Element, SequenceType: Sequence & Swift.Hashable, __ReturnType: TopLevelSelfConstrainedAssociatedTypeProtocolAbstractMockType>(_ type: TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol`.
public func dummy<Element, SequenceType: Sequence & Swift.Hashable>(_ type: TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType> {
  return TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>' or use 'dummy(TopLevelSelfConstrainedAssociatedTypeProtocol.self)' to create a non-mockable dummy object")
public func mock<Element, SequenceType: Sequence & Swift.Hashable, __ReturnType>(_ type: TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked TopLevelType

public final class TopLevelTypeMock: MockingbirdTestsHost.TopLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)

  public override func `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `topLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: - Mocked SecondLevelType

  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }

    // MARK: Mocked `secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)

    public override func `secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else {
        return (implementation as! () -> Bool)()
      }
    }

    public func `secondLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
    }

    // MARK: - Mocked ThirdLevelInheritingTopLevelType

    public final class ThirdLevelInheritingTopLevelTypeMock: ThirdLevelInheritingTopLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingTopLevelTypeAbstractMockType {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> MockingbirdTestsHost.TopLevelType)()
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)

      public override func `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }

      public func `topLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelInheritingThirdLevelType

    public final class ThirdLevelInheritingThirdLevelTypeMock: ThirdLevelInheritingThirdLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingThirdLevelTypeAbstractMockType {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)()
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelInheritingPartiallyQualifiedThirdLevelType

    public final class ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock: ThirdLevelInheritingPartiallyQualifiedThirdLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeAbstractMockType {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)()
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelInheritingFullyQualifiedThirdLevelType

    public final class ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock: ThirdLevelInheritingFullyQualifiedThirdLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingFullyQualifiedThirdLevelTypeAbstractMockType {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)()
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelType

    public final class ThirdLevelTypeMock: ThirdLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelTypeAbstractMockType {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  }

  // MARK: - Mocked InitializableSecondLevelType

  public final class InitializableSecondLevelTypeMock: InitializableSecondLevelType, Mockingbird.Mock, TopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        InitializableSecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    public class InitializerProxy: Mockingbird.Initializable {
      fileprivate init() {}

      public class Dummy: Mockingbird.Initializable {
        public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableSecondLevelTypeMock {
          let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
          mock.sourceLocation = SourceLocation(__file, __line)
          return mock
        }
      }

      public func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> TopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType {
        let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }

      public func initialize<__ReturnType: TopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
        let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return (mock as! __ReturnType)
      }

      @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'InitializableSecondLevelTypeMock' or use 'dummy(InitializableSecondLevelTypeMock.self).initialize(...)' to create a non-mockable dummy object")
      public func initialize<__ReturnType>(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
    }

    // MARK: Mocked init(`param`: Bool)

    public required override init(`param`: Bool) {
      super.init(param: `param`)
      Mockingbird.checkVersion(for: self)
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
    }
  }
}

public protocol TopLevelTypeAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.TopLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType {
  return TopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.TopLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TopLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock {
  return TopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.TopLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock' or use 'dummy(TopLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType {}

/// Initialize a class mock of `SecondLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType {
  return TopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `SecondLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `SecondLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `SecondLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock.SecondLevelTypeMock' or use 'dummy(TopLevelType.SecondLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingTopLevelTypeAbstractMockType {}

/// Initialize a class mock of `ThirdLevelInheritingTopLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingTopLevelTypeAbstractMockType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingTopLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingTopLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `ThirdLevelInheritingTopLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingTopLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock' or use 'dummy(TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingThirdLevelTypeAbstractMockType {}

/// Initialize a class mock of `ThirdLevelInheritingThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingThirdLevelTypeAbstractMockType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingThirdLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingThirdLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `ThirdLevelInheritingThirdLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingThirdLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock' or use 'dummy(TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeAbstractMockType {}

/// Initialize a class mock of `ThirdLevelInheritingPartiallyQualifiedThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeAbstractMockType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingPartiallyQualifiedThirdLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `ThirdLevelInheritingPartiallyQualifiedThirdLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingPartiallyQualifiedThirdLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock' or use 'dummy(TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingFullyQualifiedThirdLevelTypeAbstractMockType {}

/// Initialize a class mock of `ThirdLevelInheritingFullyQualifiedThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingFullyQualifiedThirdLevelTypeAbstractMockType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingFullyQualifiedThirdLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelInheritingFullyQualifiedThirdLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `ThirdLevelInheritingFullyQualifiedThirdLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingFullyQualifiedThirdLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock' or use 'dummy(TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelTypeAbstractMockType {}

/// Initialize a class mock of `ThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelTypeAbstractMockType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelType`.
public func mock<__ReturnType: TopLevelTypeAbstractMockType_SecondLevelTypeAbstractMockType_ThirdLevelTypeAbstractMockType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `ThirdLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelType`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock' or use 'dummy(TopLevelType.SecondLevelType.ThirdLevelType.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType.Type) -> __ReturnType { fatalError() }

public protocol TopLevelTypeAbstractMockType_InitializableSecondLevelTypeAbstractMockType {}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(TopLevelTypeMock.InitializableSecondLevelTypeMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.TopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy()
}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
public func mock<__ReturnType: TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy>(_ type: MockingbirdTestsHost.TopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `InitializableSecondLevelType`.
public func dummy(_ type: MockingbirdTestsHost.TopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.Dummy {
  return TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(TopLevelTypeMock.InitializableSecondLevelTypeMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TopLevelType.InitializableSecondLevelType.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked TrivialIncludedSource

public final class TrivialIncludedSourceMock: MockingbirdTestsHost.TrivialIncludedSource, Mockingbird.Mock, TrivialIncludedSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TrivialIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol TrivialIncludedSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.TrivialIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.TrivialIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> TrivialIncludedSourceAbstractMockType {
  return TrivialIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TrivialIncludedSource`.
public func mock<__ReturnType: TrivialIncludedSourceAbstractMockType>(_ type: MockingbirdTestsHost.TrivialIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TrivialIncludedSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TrivialIncludedSource`.
public func dummy(_ type: MockingbirdTestsHost.TrivialIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> TrivialIncludedSourceMock {
  return TrivialIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TrivialIncludedSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TrivialIncludedSourceMock' or use 'dummy(TrivialIncludedSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TrivialIncludedSource.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked TupleTypes

public final class TupleTypesMock: MockingbirdTestsHost.TupleTypes, Mockingbird.Mock, TupleTypesAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TupleTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherVariable

  public var `anotherVariable`: (Foundation.URL, Foundation.NSObject) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (Foundation.URL, Foundation.NSObject))()
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked labeledAnotherVariable

  public var `labeledAnotherVariable`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func getLabeledAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked labeledVariable

  public var `labeledVariable`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)))()
    }
  }

  public func getLabeledVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalAnotherVariable

  public var `optionalAnotherVariable`: (Foundation.URL?, Foundation.NSObject?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (Foundation.URL?, Foundation.NSObject?))()
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalLabeledAnotherVariable

  public var `optionalLabeledAnotherVariable`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?))()
    }
  }

  public func getOptionalLabeledAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalLabeledVariable

  public var `optionalLabeledVariable`: (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?))()
    }
  }

  public func getOptionalLabeledVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?))()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)))()
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))

  public func `labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `labeledMethod`(`param1`: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethodWithParameterLabels`()

  public func `labeledMethodWithParameterLabels`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethodWithParameterLabels`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  public func `labeledMethodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethodWithParameterLabels`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> (Foundation.URL, Foundation.NSObject) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Foundation.URL, Foundation.NSObject) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Foundation.URL, Foundation.NSObject))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))()
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject))

  public func `method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject)) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject)) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject)) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels`()

  public func `methodWithParameterLabels`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func `methodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }
}

public protocol TupleTypesAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.TupleTypes`.
public func mock(_ type: MockingbirdTestsHost.TupleTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> TupleTypesAbstractMockType {
  return TupleTypesMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TupleTypes`.
public func mock<__ReturnType: TupleTypesAbstractMockType>(_ type: MockingbirdTestsHost.TupleTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TupleTypesMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TupleTypes`.
public func dummy(_ type: MockingbirdTestsHost.TupleTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> TupleTypesMock {
  return TupleTypesMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TupleTypes`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TupleTypesMock' or use 'dummy(TupleTypes.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TupleTypes.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked TypealiasedClass

public final class TypealiasedClassMock: MockingbirdTestsHost.TypealiasedClass, Mockingbird.Mock, TypealiasedClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback)

  public override func `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedClass.IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback)

  public override func `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedClass.IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult)()
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback)

  public override func `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
      return concreteImplementation(`escapingCallback`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult)()
    }
  }

  public func `request`(`escapingCallback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`escapingCallback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult>(mock: self, invocation: invocation)
  }
}

public protocol TypealiasedClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.TypealiasedClass`.
public func mock(_ type: MockingbirdTestsHost.TypealiasedClass.Type, file: StaticString = #file, line: UInt = #line) -> TypealiasedClassAbstractMockType {
  return TypealiasedClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.TypealiasedClass`.
public func mock<__ReturnType: TypealiasedClassAbstractMockType>(_ type: MockingbirdTestsHost.TypealiasedClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TypealiasedClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TypealiasedClass`.
public func dummy(_ type: MockingbirdTestsHost.TypealiasedClass.Type, file: StaticString = #file, line: UInt = #line) -> TypealiasedClassMock {
  return TypealiasedClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.TypealiasedClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TypealiasedClassMock' or use 'dummy(TypealiasedClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TypealiasedClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked TypealiasedProtocol

public final class TypealiasedProtocolMock: MockingbirdTestsHost.TypealiasedProtocol, Mockingbird.Mock, TypealiasedProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback)

  public func `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback)

  public func `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult)()
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback)

  public func `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
      return concreteImplementation(`escapingCallback`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult)()
    }
  }

  public func `request`(`escapingCallback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`escapingCallback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult>(mock: self, invocation: invocation)
  }
}

public protocol TypealiasedProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.TypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> TypealiasedProtocolAbstractMockType {
  return TypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TypealiasedProtocol`.
public func mock<__ReturnType: TypealiasedProtocolAbstractMockType>(_ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return TypealiasedProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.TypealiasedProtocol`.
public func dummy(_ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> TypealiasedProtocolMock {
  return TypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TypealiasedProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'TypealiasedProtocolMock' or use 'dummy(TypealiasedProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked UnalphabetizedGenericClass

public final class UnalphabetizedGenericClassMock<C, B, A>: MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>, Mockingbird.Mock, UnalphabetizedGenericClassAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(A.self)", "\(B.self)", "\(C.self)"].joined(separator: ",")
    let staticMockIdentifier = "UnalphabetizedGenericClassMock<C, B, A>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UnalphabetizedGenericClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z)

  public override func `genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z) -> (X, Y, Z) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z) -> (X, Y, Z)", arguments: [Mockingbird.ArgumentMatcher(`x`), Mockingbird.ArgumentMatcher(`y`), Mockingbird.ArgumentMatcher(`z`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (X, Y, Z) -> (X, Y, Z) {
      return concreteImplementation(`x`, `y`, `z`)
    } else {
      return (implementation as! () -> (X, Y, Z))()
    }
  }

  public func `genericMethod`<Z, Y, X>(`x`: @escaping @autoclosure () -> X, `y`: @escaping @autoclosure () -> Y, `z`: @escaping @autoclosure () -> Z) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (X, Y, Z) -> (X, Y, Z), (X, Y, Z)> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`x`), Mockingbird.resolve(`y`), Mockingbird.resolve(`z`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z) -> (X, Y, Z)", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (X, Y, Z) -> (X, Y, Z), (X, Y, Z)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericReferencingMethod`(`a`: A, `b`: B, `c`: C)

  public override func `genericReferencingMethod`(`a`: A, `b`: B, `c`: C) -> (A, B, C) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericReferencingMethod`(`a`: A, `b`: B, `c`: C) -> (A, B, C)", arguments: [Mockingbird.ArgumentMatcher(`a`), Mockingbird.ArgumentMatcher(`b`), Mockingbird.ArgumentMatcher(`c`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (A, B, C) -> (A, B, C) {
      return concreteImplementation(`a`, `b`, `c`)
    } else {
      return (implementation as! () -> (A, B, C))()
    }
  }

  public func `genericReferencingMethod`(`a`: @escaping @autoclosure () -> A, `b`: @escaping @autoclosure () -> B, `c`: @escaping @autoclosure () -> C) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (A, B, C) -> (A, B, C), (A, B, C)> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`a`), Mockingbird.resolve(`b`), Mockingbird.resolve(`c`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericReferencingMethod`(`a`: A, `b`: B, `c`: C) -> (A, B, C)", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (A, B, C) -> (A, B, C), (A, B, C)>(mock: self, invocation: invocation)
  }
}

public protocol UnalphabetizedGenericClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>`.
public func mock<C, B, A>(_ type: UnalphabetizedGenericClassMock<C, B, A>.Type, file: StaticString = #file, line: UInt = #line) -> UnalphabetizedGenericClassAbstractMockType {
  return UnalphabetizedGenericClassMock<C, B, A>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>`.
public func mock<C, B, A, __ReturnType: UnalphabetizedGenericClassAbstractMockType>(_ type: UnalphabetizedGenericClassMock<C, B, A>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return UnalphabetizedGenericClassMock<C, B, A>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>`.
public func dummy<C, B, A>(_ type: UnalphabetizedGenericClassMock<C, B, A>.Type, file: StaticString = #file, line: UInt = #line) -> UnalphabetizedGenericClassMock<C, B, A> {
  return UnalphabetizedGenericClassMock<C, B, A>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'UnalphabetizedGenericClassMock<C, B, A>' or use 'dummy(UnalphabetizedGenericClass<C, B, A>.self)' to create a non-mockable dummy object")
public func mock<C, B, A, __ReturnType>(_ type: UnalphabetizedGenericClassMock<C, B, A>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked UndefinedArgumentLabels

public final class UndefinedArgumentLabelsMock: MockingbirdTestsHost.UndefinedArgumentLabels, Mockingbird.Mock, UndefinedArgumentLabelsAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UndefinedArgumentLabelsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool)

  public func `method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`), Mockingbird.ArgumentMatcher(`someParam`), Mockingbird.ArgumentMatcher(`param4`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, String, Int, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`, `someParam`, `param4`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `method`(_ `param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> String, _ `someParam`: @escaping @autoclosure () -> Int, _ `param4`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, String, Int, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, String, Int, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol UndefinedArgumentLabelsAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.UndefinedArgumentLabels`.
public func mock(_ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol, file: StaticString = #file, line: UInt = #line) -> UndefinedArgumentLabelsAbstractMockType {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.UndefinedArgumentLabels`.
public func mock<__ReturnType: UndefinedArgumentLabelsAbstractMockType>(_ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.UndefinedArgumentLabels`.
public func dummy(_ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol, file: StaticString = #file, line: UInt = #line) -> UndefinedArgumentLabelsMock {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.UndefinedArgumentLabels`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'UndefinedArgumentLabelsMock' or use 'dummy(UndefinedArgumentLabels.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked UnspecializedGenericSubclass

public final class UnspecializedGenericSubclassMock<T>: MockingbirdTestsHost.UnspecializedGenericSubclass<T>, Mockingbird.Mock, UnspecializedGenericSubclassAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "UnspecializedGenericSubclassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UnspecializedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> T)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

public protocol UnspecializedGenericSubclassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedGenericSubclass<T>`.
public func mock<T>(_ type: UnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> UnspecializedGenericSubclassAbstractMockType {
  return UnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedGenericSubclass<T>`.
public func mock<T, __ReturnType: UnspecializedGenericSubclassAbstractMockType>(_ type: UnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return UnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.UnspecializedGenericSubclass<T>`.
public func dummy<T>(_ type: UnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> UnspecializedGenericSubclassMock<T> {
  return UnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedGenericSubclass<T>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'UnspecializedGenericSubclassMock<T>' or use 'dummy(UnspecializedGenericSubclass<T>.self)' to create a non-mockable dummy object")
public func mock<T, __ReturnType>(_ type: UnspecializedGenericSubclassMock<T>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked UnspecializedMultipleGenericSubclass

public final class UnspecializedMultipleGenericSubclassMock<T, R>: MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>, Mockingbird.Mock, UnspecializedMultipleGenericSubclassAbstractMockType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(R.self)", "\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "UnspecializedMultipleGenericSubclassMock<T, R>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UnspecializedMultipleGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> T)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

public protocol UnspecializedMultipleGenericSubclassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>`.
public func mock<T, R>(_ type: UnspecializedMultipleGenericSubclassMock<T, R>.Type, file: StaticString = #file, line: UInt = #line) -> UnspecializedMultipleGenericSubclassAbstractMockType {
  return UnspecializedMultipleGenericSubclassMock<T, R>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>`.
public func mock<T, R, __ReturnType: UnspecializedMultipleGenericSubclassAbstractMockType>(_ type: UnspecializedMultipleGenericSubclassMock<T, R>.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return UnspecializedMultipleGenericSubclassMock<T, R>(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>`.
public func dummy<T, R>(_ type: UnspecializedMultipleGenericSubclassMock<T, R>.Type, file: StaticString = #file, line: UInt = #line) -> UnspecializedMultipleGenericSubclassMock<T, R> {
  return UnspecializedMultipleGenericSubclassMock<T, R>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'UnspecializedMultipleGenericSubclassMock<T, R>' or use 'dummy(UnspecializedMultipleGenericSubclass<T, R>.self)' to create a non-mockable dummy object")
public func mock<T, R, __ReturnType>(_ type: UnspecializedMultipleGenericSubclassMock<T, R>.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked VariablesContainerProtocol

public final class VariablesContainerProtocolMock: MockingbirdTestsHost.VariablesContainerProtocol, Mockingbird.Mock, VariablesContainerProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked readonlyVariableOverwrittenAsReadwrite

  public var `readonlyVariableOverwrittenAsReadwrite`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getReadonlyVariableOverwrittenAsReadwrite() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol VariablesContainerProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariablesContainerProtocol`.
public func mock(_ type: MockingbirdTestsHost.VariablesContainerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> VariablesContainerProtocolAbstractMockType {
  return VariablesContainerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariablesContainerProtocol`.
public func mock<__ReturnType: VariablesContainerProtocolAbstractMockType>(_ type: MockingbirdTestsHost.VariablesContainerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return VariablesContainerProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.VariablesContainerProtocol`.
public func dummy(_ type: MockingbirdTestsHost.VariablesContainerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> VariablesContainerProtocolMock {
  return VariablesContainerProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariablesContainerProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'VariablesContainerProtocolMock' or use 'dummy(VariablesContainerProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.VariablesContainerProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked VariablesContainer

public final class VariablesContainerMock: MockingbirdTestsHost.VariablesContainer, Mockingbird.Mock, VariablesContainerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public class InitializerProxy: Mockingbird.Initializable {
    fileprivate init() {}

    public class Dummy: Mockingbird.Initializable {
      public func initialize(__file: StaticString = #file, __line: UInt = #line) -> VariablesContainerMock {
        let mock: VariablesContainerMock = VariablesContainerMock()
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    public func initialize(__file: StaticString = #file, __line: UInt = #line) -> VariablesContainerAbstractMockType {
      let mock: VariablesContainerMock = VariablesContainerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public func initialize<__ReturnType: VariablesContainerAbstractMockType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType {
      let mock: VariablesContainerMock = VariablesContainerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return (mock as! __ReturnType)
    }

    @available(swift, obsoleted: 3.0, message: "Store the mock in a variable of type 'VariablesContainerMock' or use 'dummy(VariablesContainerMock.self).initialize(...)' to create a non-mockable dummy object")
    public func initialize<__ReturnType>(__file: StaticString = #file, __line: UInt = #line) -> __ReturnType { fatalError() }
  }

  // MARK: Mocked computedMutableVariable

  override public var `computedMutableVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedMutableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedMutableVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked computedVariableWithDidSetObserver

  override public var `computedVariableWithDidSetObserver`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedVariableWithDidSetObserver() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedVariableWithDidSetObserver(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked computedVariableWithWillSetObserver

  override public var `computedVariableWithWillSetObserver`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedVariableWithWillSetObserver() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedVariableWithWillSetObserver(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked computedVariable

  override public var `computedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getComputedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked lazyVariableWithExplicitType

  override public var `lazyVariableWithExplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLazyVariableWithExplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setLazyVariableWithExplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked lazyVariableWithImplicitType

  override public var `lazyVariableWithImplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLazyVariableWithImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setLazyVariableWithImplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked readonlyVariableOverwrittenAsReadwrite

  override public var `readonlyVariableOverwrittenAsReadwrite`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getReadonlyVariableOverwrittenAsReadwrite() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setReadonlyVariableOverwrittenAsReadwrite(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithExplicitType

  override public var `storedVariableWithExplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithExplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithExplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithImplicitType

  override public var `storedVariableWithImplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithImplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked uninitializedVariable

  override public var `uninitializedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getUninitializedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setUninitializedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked weakVariable

  override public var `weakVariable`: MockingbirdTestsHost.VariablesContainer? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.VariablesContainer?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.VariablesContainer?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWeakVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.VariablesContainer?, MockingbirdTestsHost.VariablesContainer?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.VariablesContainer?, MockingbirdTestsHost.VariablesContainer?>(mock: self, invocation: invocation)
  }

  public func setWeakVariable(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.VariablesContainer?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.VariablesContainer?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.VariablesContainer?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

public protocol VariablesContainerAbstractMockType {}

/// Initialize an initializable class mock of `MockingbirdTestsHost.VariablesContainer`.
@available(*, deprecated, message: "Initialize this class mock using 'mock(VariablesContainerMock.self).initialize(...)'")
public func mock(_ type: MockingbirdTestsHost.VariablesContainer.Type, file: StaticString = #file, line: UInt = #line) -> Mockingbird.Initializable {
  return VariablesContainerMock.InitializerProxy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.VariablesContainer`.
public func mock<__ReturnType: VariablesContainerMock.InitializerProxy>(_ type: MockingbirdTestsHost.VariablesContainer.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return VariablesContainerMock.InitializerProxy() as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.VariablesContainer`.
public func dummy(_ type: MockingbirdTestsHost.VariablesContainer.Type, file: StaticString = #file, line: UInt = #line) -> VariablesContainerMock.InitializerProxy.Dummy {
  return VariablesContainerMock.InitializerProxy.Dummy()
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.VariablesContainer`.
@available(swift, obsoleted: 3.0, message: "Initialize this class mock using 'mock(VariablesContainerMock.self).initialize(...)'")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.VariablesContainer.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked VariadicClass

public final class VariadicClassMock: MockingbirdTestsHost.VariadicClass, Mockingbird.Mock, VariadicClassAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `variadicMethod`(`objects`: Bool..., `param2`: Int)

  public override func `variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethod`(`objects`: String..., `param2`: Int)

  public override func `variadicMethod`(`objects`: String..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [String], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: String..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...)

  public override func `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: String...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicReturningMethod`(`objects`: Bool..., `param2`: Int)

  public override func `variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `variadicReturningMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
  public func `variadicReturningMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol VariadicClassAbstractMockType {}

/// Initialize a class mock of `MockingbirdTestsHost.VariadicClass`.
public func mock(_ type: MockingbirdTestsHost.VariadicClass.Type, file: StaticString = #file, line: UInt = #line) -> VariadicClassAbstractMockType {
  return VariadicClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.VariadicClass`.
public func mock<__ReturnType: VariadicClassAbstractMockType>(_ type: MockingbirdTestsHost.VariadicClass.Type, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return VariadicClassMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.VariadicClass`.
public func dummy(_ type: MockingbirdTestsHost.VariadicClass.Type, file: StaticString = #file, line: UInt = #line) -> VariadicClassMock {
  return VariadicClassMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `MockingbirdTestsHost.VariadicClass`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'VariadicClassMock' or use 'dummy(VariadicClass.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.VariadicClass.Type) -> __ReturnType { fatalError() }

// MARK: - Mocked VariadicProtocol

public final class VariadicProtocolMock: MockingbirdTestsHost.VariadicProtocol, Mockingbird.Mock, VariadicProtocolAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `variadicMethod`(`objects`: Bool..., `param2`: Int)

  public func `variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethod`(`objects`: String..., `param2`: Int)

  public func `variadicMethod`(`objects`: String..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [String], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: String..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...)

  public func `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: String...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicReturningMethod`(`objects`: Bool..., `param2`: Int)

  public func `variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `variadicReturningMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
  public func `variadicReturningMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

public protocol VariadicProtocolAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariadicProtocol`.
public func mock(_ type: MockingbirdTestsHost.VariadicProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> VariadicProtocolAbstractMockType {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariadicProtocol`.
public func mock<__ReturnType: VariadicProtocolAbstractMockType>(_ type: MockingbirdTestsHost.VariadicProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.VariadicProtocol`.
public func dummy(_ type: MockingbirdTestsHost.VariadicProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> VariadicProtocolMock {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariadicProtocol`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'VariadicProtocolMock' or use 'dummy(VariadicProtocol.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.VariadicProtocol.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked ViewControllerExtensionReferencer

public final class ViewControllerExtensionReferencerMock: MockingbirdTestsHost.ViewControllerExtensionReferencer, Mockingbird.Mock, ViewControllerExtensionReferencerAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ViewControllerExtensionReferencerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked extendedClassVariable

  public var `extendedClassVariable`: AppKit.NSViewController.ExtendedClass {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AppKit.NSViewController.ExtendedClass)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedClass) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass, AppKit.NSViewController.ExtendedClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass, AppKit.NSViewController.ExtendedClass>(mock: self, invocation: invocation)
  }

  public func setExtendedClassVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedClass) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedEnumVariable

  public var `extendedEnumVariable`: AppKit.NSViewController.ExtendedEnum {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AppKit.NSViewController.ExtendedEnum)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedEnum) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedEnumVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum, AppKit.NSViewController.ExtendedEnum> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum, AppKit.NSViewController.ExtendedEnum>(mock: self, invocation: invocation)
  }

  public func setExtendedEnumVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedEnum) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedNestedClassVariable

  public var `extendedNestedClassVariable`: AppKit.NSViewController.ExtendedEnum.NestedExtendedClass {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedNestedClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass, AppKit.NSViewController.ExtendedEnum.NestedExtendedClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass, AppKit.NSViewController.ExtendedEnum.NestedExtendedClass>(mock: self, invocation: invocation)
  }

  public func setExtendedNestedClassVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedNestedEnumVariable

  public var `extendedNestedEnumVariable`: AppKit.NSViewController.ExtendedClass.NestedExtendedEnum {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedNestedEnumVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum, AppKit.NSViewController.ExtendedClass.NestedExtendedEnum> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum, AppKit.NSViewController.ExtendedClass.NestedExtendedEnum>(mock: self, invocation: invocation)
  }

  public func setExtendedNestedEnumVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol ViewControllerExtensionReferencerAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.ViewControllerExtensionReferencer`.
public func mock(_ type: MockingbirdTestsHost.ViewControllerExtensionReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> ViewControllerExtensionReferencerAbstractMockType {
  return ViewControllerExtensionReferencerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ViewControllerExtensionReferencer`.
public func mock<__ReturnType: ViewControllerExtensionReferencerAbstractMockType>(_ type: MockingbirdTestsHost.ViewControllerExtensionReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return ViewControllerExtensionReferencerMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.ViewControllerExtensionReferencer`.
public func dummy(_ type: MockingbirdTestsHost.ViewControllerExtensionReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> ViewControllerExtensionReferencerMock {
  return ViewControllerExtensionReferencerMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ViewControllerExtensionReferencer`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'ViewControllerExtensionReferencerMock' or use 'dummy(ViewControllerExtensionReferencer.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.ViewControllerExtensionReferencer.Protocol) -> __ReturnType { fatalError() }

// MARK: - Mocked WildcardFileNonRelativeIgnoredSource

public final class WildcardFileNonRelativeIgnoredSourceMock: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource, Mockingbird.Mock, WildcardFileNonRelativeIgnoredSourceAbstractMockType {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      WildcardFileNonRelativeIgnoredSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

public protocol WildcardFileNonRelativeIgnoredSourceAbstractMockType {}

/// Initialize a protocol mock of `MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource`.
public func mock(_ type: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> WildcardFileNonRelativeIgnoredSourceAbstractMockType {
  return WildcardFileNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource`.
public func mock<__ReturnType: WildcardFileNonRelativeIgnoredSourceAbstractMockType>(_ type: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> __ReturnType {
  return WildcardFileNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line)) as! __ReturnType
}

/// Create a dummy object of `MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource`.
public func dummy(_ type: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> WildcardFileNonRelativeIgnoredSourceMock {
  return WildcardFileNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a protocol mock of `MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource`.
@available(swift, obsoleted: 3.0, renamed: "dummy", message: "Store the mock in a variable of type 'WildcardFileNonRelativeIgnoredSourceMock' or use 'dummy(WildcardFileNonRelativeIgnoredSource.self)' to create a non-mockable dummy object")
public func mock<__ReturnType>(_ type: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource.Protocol) -> __ReturnType { fatalError() }
