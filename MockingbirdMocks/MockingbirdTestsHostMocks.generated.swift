//
//  MockingbirdTestsHostMocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird v0.11.0.
//  DO NOT EDIT
//

@testable import CoreVideo
@testable import Mockingbird
@testable import MockingbirdTestsHost
import AppKit
import CoreAudio
import CoreData
import CoreFoundation
import CoreImage
import CoreML
import CoreText
import CoreVideo
import Foundation
import MockingbirdModuleTestsHost
import ObjectiveC
import Swift
import class CoreFoundation.CFArray
import enum CoreText.CTFontUIFontType

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AbstractSpecializedGenericProtocol

public final class AbstractSpecializedGenericProtocolMock<EquatableType: Swift.Equatable>: MockingbirdTestsHost.GenericBaseClass<Bool>, MockingbirdTestsHost.AbstractSpecializedGenericProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(EquatableType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "AbstractSpecializedGenericProtocolMock<EquatableType: Swift.Equatable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AbstractSpecializedGenericProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: Bool)

  public override func `baseMethod`(`param`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Bool {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AbstractSpecializedGenericProtocol`.
public func mock<EquatableType: Swift.Equatable>(_ type: AbstractSpecializedGenericProtocolMock<EquatableType>.Type, file: StaticString = #file, line: UInt = #line) -> AbstractSpecializedGenericProtocolMock<EquatableType> {
  return AbstractSpecializedGenericProtocolMock<EquatableType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AnotherTopLevelType

public final class AnotherTopLevelTypeMock: MockingbirdTestsHost.AnotherTopLevelType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AnotherTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: - Mocked SecondLevelType

  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }
  }

  // MARK: - Mocked InitializableSecondLevelType

  public final class InitializableSecondLevelTypeMock: InitializableSecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        InitializableSecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    public enum InitializerProxy {
      public static func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableSecondLevelTypeMock {
        let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    // MARK: Mocked init(`param`: Bool)

    public required override init(`param`: Bool) {
      super.init(param: `param`)
      Mockingbird.checkVersion(for: self)
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
    }
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.AnotherTopLevelType`.
public func mock(_ type: MockingbirdTestsHost.AnotherTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeMock {
  return AnotherTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `SecondLevelType`.
public func mock(_ type: MockingbirdTestsHost.AnotherTopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeMock.SecondLevelTypeMock {
  return AnotherTopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
public func mock(_ type: MockingbirdTestsHost.AnotherTopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.Type {
  return AnotherTopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.self
}

// MARK: - Mocked ArgumentMatchingProtocol

public final class ArgumentMatchingProtocolMock: MockingbirdTestsHost.ArgumentMatchingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArgumentMatchingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`anyObjectType`: Swift.AnyObject)

  public func `method`(`anyObjectType`: Swift.AnyObject) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`anyObjectType`: Swift.AnyObject) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`anyObjectType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Swift.AnyObject) -> Bool {
        return concreteImplementation(`anyObjectType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`anyObjectType`: @escaping @autoclosure () -> Swift.AnyObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Swift.AnyObject) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`anyObjectType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`anyObjectType`: Swift.AnyObject) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Swift.AnyObject) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`anyType`: Any)

  public func `method`(`anyType`: Any) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`anyType`: Any) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`anyType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Any) -> Bool {
        return concreteImplementation(`anyType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`anyType`: @escaping @autoclosure () -> Any) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`anyType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`anyType`: Any) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`boolType`: Bool)

  public func `method`(`boolType`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`boolType`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`boolType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Bool {
        return concreteImplementation(`boolType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`boolType`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`boolType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`boolType`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`classType`: MockingbirdTestsHost.ClassType)

  public func `method`(`classType`: MockingbirdTestsHost.ClassType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`classType`: MockingbirdTestsHost.ClassType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`classType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ClassType) -> Bool {
        return concreteImplementation(`classType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`classType`: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClassType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`classType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`classType`: MockingbirdTestsHost.ClassType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClassType) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`enumType`: MockingbirdTestsHost.EnumType)

  public func `method`(`enumType`: MockingbirdTestsHost.EnumType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`enumType`: MockingbirdTestsHost.EnumType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`enumType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.EnumType) -> Bool {
        return concreteImplementation(`enumType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`enumType`: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.EnumType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`enumType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`enumType`: MockingbirdTestsHost.EnumType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.EnumType) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`<T: FloatingPoint>(`floatingPoint`: T)

  public func `method`<T: FloatingPoint>(`floatingPoint`: T) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<T: FloatingPoint>(`floatingPoint`: T) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`floatingPoint`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Bool {
        return concreteImplementation(`floatingPoint`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`<T: FloatingPoint>(`floatingPoint`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`floatingPoint`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<T: FloatingPoint>(`floatingPoint`: T) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`metaType`: ClassType.Type)

  public func `method`(`metaType`: ClassType.Type) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`metaType`: ClassType.Type) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`metaType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ClassType.Type) -> Bool {
        return concreteImplementation(`metaType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`metaType`: @escaping @autoclosure () -> ClassType.Type) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ClassType.Type) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metaType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`metaType`: ClassType.Type) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ClassType.Type) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalAnyObjectType`: Swift.AnyObject?)

  public func `method`(`optionalAnyObjectType`: Swift.AnyObject?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalAnyObjectType`: Swift.AnyObject?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalAnyObjectType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Swift.AnyObject?) -> Bool {
        return concreteImplementation(`optionalAnyObjectType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalAnyObjectType`: @escaping @autoclosure () -> Swift.AnyObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Swift.AnyObject?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalAnyObjectType`: Swift.AnyObject?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Swift.AnyObject?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalAnyType`: Any?)

  public func `method`(`optionalAnyType`: Any?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalAnyType`: Any?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalAnyType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Any?) -> Bool {
        return concreteImplementation(`optionalAnyType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalAnyType`: @escaping @autoclosure () -> Any?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalAnyType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalAnyType`: Any?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalBoolType`: Bool?)

  public func `method`(`optionalBoolType`: Bool?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalBoolType`: Bool?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalBoolType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool?) -> Bool {
        return concreteImplementation(`optionalBoolType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalBoolType`: @escaping @autoclosure () -> Bool?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalBoolType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalBoolType`: Bool?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalClassType`: MockingbirdTestsHost.ClassType?)

  public func `method`(`optionalClassType`: MockingbirdTestsHost.ClassType?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalClassType`: MockingbirdTestsHost.ClassType?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalClassType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ClassType?) -> Bool {
        return concreteImplementation(`optionalClassType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalClassType`: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClassType?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalClassType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalClassType`: MockingbirdTestsHost.ClassType?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClassType?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalEnumType`: MockingbirdTestsHost.EnumType?)

  public func `method`(`optionalEnumType`: MockingbirdTestsHost.EnumType?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalEnumType`: MockingbirdTestsHost.EnumType?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalEnumType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.EnumType?) -> Bool {
        return concreteImplementation(`optionalEnumType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalEnumType`: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.EnumType?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalEnumType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalEnumType`: MockingbirdTestsHost.EnumType?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.EnumType?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalMetaType`: ClassType.Type?)

  public func `method`(`optionalMetaType`: ClassType.Type?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalMetaType`: ClassType.Type?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalMetaType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ClassType.Type?) -> Bool {
        return concreteImplementation(`optionalMetaType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalMetaType`: @escaping @autoclosure () -> ClassType.Type?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ClassType.Type?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalMetaType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalMetaType`: ClassType.Type?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ClassType.Type?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalProtocolType`: P?)

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalProtocolType`: P?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalProtocolType`: P?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalProtocolType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (P?) -> Bool {
        return concreteImplementation(`optionalProtocolType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalProtocolType`: @escaping @autoclosure () -> P?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (P?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalProtocolType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`optionalProtocolType`: P?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (P?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalStringType`: String?)

  public func `method`(`optionalStringType`: String?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalStringType`: String?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalStringType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String?) -> Bool {
        return concreteImplementation(`optionalStringType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalStringType`: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalStringType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalStringType`: String?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`optionalStructType`: MockingbirdTestsHost.StructType?)

  public func `method`(`optionalStructType`: MockingbirdTestsHost.StructType?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalStructType`: MockingbirdTestsHost.StructType?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalStructType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType?) -> Bool {
        return concreteImplementation(`optionalStructType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`optionalStructType`: @escaping @autoclosure () -> MockingbirdTestsHost.StructType?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalStructType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`optionalStructType`: MockingbirdTestsHost.StructType?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`<P: MockingbirdTestsHost.BaseProtocol>(`protocolType`: P)

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`protocolType`: P) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`protocolType`: P) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`protocolType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (P) -> Bool {
        return concreteImplementation(`protocolType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`<P: MockingbirdTestsHost.BaseProtocol>(`protocolType`: @escaping @autoclosure () -> P) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (P) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`protocolType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`<P: MockingbirdTestsHost.BaseProtocol>(`protocolType`: P) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (P) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`stringType`: String)

  public func `method`(`stringType`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`stringType`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`stringType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Bool {
        return concreteImplementation(`stringType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`stringType`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`stringType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`stringType`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`structType`: MockingbirdTestsHost.StructType)

  public func `method`(`structType`: MockingbirdTestsHost.StructType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`structType`: MockingbirdTestsHost.StructType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`structType`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType) -> Bool {
        return concreteImplementation(`structType`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`structType`: @escaping @autoclosure () -> MockingbirdTestsHost.StructType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`structType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`structType`: MockingbirdTestsHost.StructType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArgumentMatchingProtocol`.
public func mock(_ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ArgumentMatchingProtocolMock {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ArrayCollection

public final class ArrayCollectionMock: MockingbirdTestsHost.ArrayCollection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`objects`: [String])

  public func `method`(`objects`: [String]) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String]) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([String]) -> Bool {
        return concreteImplementation(`objects`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`objects`: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String]) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String]) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String]) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayCollection`.
public func mock(_ type: MockingbirdTestsHost.ArrayCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> ArrayCollectionMock {
  return ArrayCollectionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ArrayTypes

public final class ArrayTypesMock: MockingbirdTestsHost.ArrayTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherVariable

  public var `anotherVariable`: [Foundation.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [Foundation.NSObject] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [Foundation.NSObject] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Foundation.NSObject]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitAnotherVariable

  public var `explicitAnotherVariable`: Array<Foundation.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Array<Foundation.NSObject> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<Foundation.NSObject>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitVariable

  public var `explicitVariable`: Array<MockingbirdTestsHost.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Array<MockingbirdTestsHost.NSObject> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<MockingbirdTestsHost.NSObject>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalAnotherVariable

  public var `optionalAnotherVariable`: [Foundation.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [Foundation.NSObject?] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [Foundation.NSObject?] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Foundation.NSObject?]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject?], [Foundation.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject?], [Foundation.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitAnotherVariable

  public var `optionalExplicitAnotherVariable`: Array<Foundation.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Array<Foundation.NSObject?> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject?> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<Foundation.NSObject?>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitVariable

  public var `optionalExplicitVariable`: Array<MockingbirdTestsHost.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Array<MockingbirdTestsHost.NSObject?> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject?> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<MockingbirdTestsHost.NSObject?>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: [MockingbirdTestsHost.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [MockingbirdTestsHost.NSObject?] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject?] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([MockingbirdTestsHost.NSObject?]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: [MockingbirdTestsHost.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [MockingbirdTestsHost.NSObject] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([MockingbirdTestsHost.NSObject]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Array<Foundation.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<Foundation.NSObject>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Array<Foundation.NSObject> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<Foundation.NSObject>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Array<MockingbirdTestsHost.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Array<MockingbirdTestsHost.NSObject> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<MockingbirdTestsHost.NSObject>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>)

  public func `explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `explicitMethod`(`param1`: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>, `param2`: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Array<MockingbirdTestsHost.NSObject>, `param2`: Array<Foundation.NSObject>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethodWithParameterLabels`()

  public func `explicitMethodWithParameterLabels`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (([MockingbirdTestsHost.NSObject], [Foundation.NSObject])).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [Foundation.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.NSObject]", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> [Foundation.NSObject] in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [Foundation.NSObject] {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> [Foundation.NSObject] {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Foundation.NSObject]).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [MockingbirdTestsHost.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> [MockingbirdTestsHost.NSObject] in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject] {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject] {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([MockingbirdTestsHost.NSObject]).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject])

  public func `method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject], `param2`: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.NSObject], `param2`: [Foundation.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels`()

  public func `methodWithParameterLabels`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ArrayTypes`.
public func mock(_ type: MockingbirdTestsHost.ArrayTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> ArrayTypesMock {
  return ArrayTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericConformingConstraintsProtocol

public final class AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>: MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol, Mockingbird.Mock where ConformingType.EquatableType: MockingbirdTestsHost.EquatableConformingProtocol, ConformingType.HashableType: MockingbirdTestsHost.HashableConformingProtocol {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(ConformingType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericConformingConstraintsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`object`: ConformingType)

  public func `request`(`object`: ConformingType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConformingType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ConformingType) -> Bool {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> ConformingType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConformingType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConformingType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConformingType) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConformingConstraintsProtocol`.
public func mock<ConformingType: MockingbirdTestsHost.AssociatedTypeProtocol>(_ type: AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType> {
  return AssociatedTypeGenericConformingConstraintsProtocolMock<ConformingType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericConstraintsProtocol

public final class AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>: MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol, Mockingbird.Mock where ConstrainedType.EquatableType == Int, ConstrainedType.HashableType == String {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(ConstrainedType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericConstraintsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`object`: ConstrainedType)

  public func `request`(`object`: ConstrainedType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConstrainedType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ConstrainedType) -> Bool {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> ConstrainedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConstrainedType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: ConstrainedType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConstrainedType) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol`.
public func mock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>(_ type: AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType> {
  return AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericImplementer

public final class AssociatedTypeGenericImplementerMock<EquatableType: Swift.Equatable, S: Sequence>: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, Mockingbird.Mock where S.Element == EquatableType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(EquatableType.self).debugDescription, ObjectIdentifier(S.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericImplementerMock<EquatableType: Swift.Equatable, S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked equatableTypeVariable

  override public var `equatableTypeVariable`: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> EquatableType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> EquatableType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (EquatableType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodUsingEquatableType`(`equatable`: EquatableType)

  public override func `methodUsingEquatableType`(`equatable`: EquatableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableType) -> Void {
        concreteImplementation(`equatable`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodUsingEquatableType`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType)

  public override func `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    return mockingContext.didInvoke(invocation) { () -> EquatableType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
        return concreteImplementation(`equatable`)
      } else if let concreteImplementation = implementation as? () -> EquatableType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (EquatableType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodUsingEquatableTypeWithReturn`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType)

  public override func `methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void {
        concreteImplementation(`hashable`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodUsingHashableType`(`hashable`: @escaping @autoclosure () -> MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hashable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>.HashableType) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>`.
public func mock<EquatableType: Swift.Equatable, S: Sequence>(_ type: AssociatedTypeGenericImplementerMock<EquatableType, S>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeGenericImplementerMock<EquatableType, S> {
  return AssociatedTypeGenericImplementerMock<EquatableType, S>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeImplementerProtocol

public final class AssociatedTypeImplementerProtocolMock: MockingbirdTestsHost.AssociatedTypeImplementerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T.HashableType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T.HashableType {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T.HashableType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T.HashableType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T.HashableType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T.HashableType {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T.HashableType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T.HashableType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Void {
        concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeImplementerProtocol`.
public func mock(_ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeImplementerProtocolMock {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeImplementer

public final class AssociatedTypeImplementerMock: MockingbirdTestsHost.AssociatedTypeImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  #if swift(>=5.2)

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public override func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.EquatableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.EquatableType where T.EquatableType == Bool, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T.EquatableType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T.EquatableType {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T.EquatableType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T.EquatableType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.EquatableType, T.EquatableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.EquatableType where T.EquatableType == Bool, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.EquatableType, T.EquatableType>(mock: self, invocation: invocation)
  }

  #endif

  #if swift(>=5.2)

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public override func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.EquatableType where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.EquatableType where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T.EquatableType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T.EquatableType {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T.EquatableType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T.EquatableType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.EquatableType, T.EquatableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> T.EquatableType where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.EquatableType, T.EquatableType>(mock: self, invocation: invocation)
  }

  #endif

  // MARK: Mocked `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T)

  public override func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Void {
        concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`object`: T) -> Void where T.EquatableType == Int, T.HashableType == String", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.AssociatedTypeImplementer`.
public func mock(_ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeImplementerMock {
  return AssociatedTypeImplementerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeProtocol

public final class AssociatedTypeProtocolMock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>: MockingbirdTestsHost.AssociatedTypeProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(EquatableType.self).debugDescription, ObjectIdentifier(HashableType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeProtocolMock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked equatableTypeVariable

  public var `equatableTypeVariable`: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> EquatableType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> EquatableType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (EquatableType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked equatableTypeVariable

  public class var `equatableTypeVariable`: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> EquatableType in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> EquatableType {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (EquatableType).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodUsingEquatableType`(`equatable`: EquatableType)

  public func `methodUsingEquatableType`(`equatable`: EquatableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableType) -> Void {
        concreteImplementation(`equatable`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodUsingEquatableType`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableType`(`equatable`: EquatableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType)

  public func `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    return mockingContext.didInvoke(invocation) { () -> EquatableType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
        return concreteImplementation(`equatable`)
      } else if let concreteImplementation = implementation as? () -> EquatableType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (EquatableType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodUsingEquatableTypeWithReturn`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType)

  public static func `methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> EquatableType in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
        return concreteImplementation(`equatable`)
      } else if let concreteImplementation = implementation as? () -> EquatableType {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (EquatableType).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `methodUsingEquatableTypeWithReturn`(`equatable`: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingEquatableTypeWithReturn`(`equatable`: EquatableType) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `methodUsingHashableType`(`hashable`: HashableType)

  public func `methodUsingHashableType`(`hashable`: HashableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: HashableType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (HashableType) -> Void {
        concreteImplementation(`hashable`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodUsingHashableType`(`hashable`: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hashable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodUsingHashableType`(`hashable`: HashableType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeProtocol`.
public func mock<EquatableType: Swift.Equatable, HashableType: Swift.Hashable>(_ type: AssociatedTypeProtocolMock<EquatableType, HashableType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeProtocolMock<EquatableType, HashableType> {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeSelfReferencingProtocol

public final class AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(SequenceType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeSelfReferencingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SequenceType) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: AssociatedTypeSelfReferencingProtocolMock)

  public func `request`(`object`: AssociatedTypeSelfReferencingProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: AssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AssociatedTypeSelfReferencingProtocolMock) -> Void {
        concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> AssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AssociatedTypeSelfReferencingProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: AssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AssociatedTypeSelfReferencingProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable>(_ type: AssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> AssociatedTypeSelfReferencingProtocolMock<SequenceType> {
  return AssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked BaseProtocol

public final class BaseProtocolMock: MockingbirdTestsHost.BaseProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BaseProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock)

  public static func ==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (BaseProtocolMock, BaseProtocolMock) -> Bool {
        return concreteImplementation(`lhs`, `rhs`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> BaseProtocolMock, _ `rhs`: @escaping @autoclosure () -> BaseProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (BaseProtocolMock, BaseProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: BaseProtocolMock, _ `rhs`: BaseProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (BaseProtocolMock, BaseProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.BaseProtocol`.
public func mock(_ type: BaseProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> BaseProtocolMock {
  return BaseProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked CascadingIncludedSource

public final class CascadingIncludedSourceMock: MockingbirdTestsHost.CascadingIncludedSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CascadingIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CascadingIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.CascadingIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> CascadingIncludedSourceMock {
  return CascadingIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ChildProtocol`.
public func mock(_ type: MockingbirdTestsHost.ChildProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ChildProtocolMock {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childClassVariable

  override public class var `childClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getChildClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childComputedInstanceVariable

  override public var `childComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredFileprivateSetterInstanceVariable

  override public var `childStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredInstanceVariable

  override public var `childStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredPrivateSetterInstanceVariable

  override public var `childStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentClassVariable

  override public class var `parentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentComputedInstanceVariable

  override public var `parentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredFileprivateSetterInstanceVariable

  override public var `parentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredInstanceVariable

  override public var `parentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredPrivateSetterInstanceVariable

  override public var `parentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `childParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialClassMethod`()

  public override static func `childTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `childTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public override func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod`()

  public override static func `parentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public override func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.Child`.
public func mock(_ type: MockingbirdTestsHost.Child.Type, file: StaticString = #file, line: UInt = #line) -> ChildMock {
  return ChildMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClassOnlyProtocolWithInheritance

public final class ClassOnlyProtocolWithInheritanceMock: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassOnlyProtocolWithInheritanceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocolWithInheritance`.
public func mock(_ type: MockingbirdTestsHost.ClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> ClassOnlyProtocolWithInheritanceMock {
  return ClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClassOnlyProtocol

public final class ClassOnlyProtocolMock: MockingbirdTestsHost.ClassOnlyProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassOnlyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClassOnlyProtocol`.
public func mock(_ type: MockingbirdTestsHost.ClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ClassOnlyProtocolMock {
  return ClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClassType

public final class ClassTypeMock: MockingbirdTestsHost.ClassType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ClassType`.
public func mock(_ type: MockingbirdTestsHost.ClassType.Type, file: StaticString = #file, line: UInt = #line) -> ClassTypeMock {
  return ClassTypeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClassWithDesignatedInitializer

public final class ClassWithDesignatedInitializerMock: MockingbirdTestsHost.ClassWithDesignatedInitializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassWithDesignatedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    @available(*, deprecated, message: "This class initializer is deprecated")
    public static func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerMock {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerMock {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> ClassWithDesignatedInitializerMock {
      let mock: ClassWithDesignatedInitializerMock = ClassWithDesignatedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param1`: Bool)

  @available(*, deprecated, message: "This class initializer is deprecated")
  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: Bool)

  public required init(`param`: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: Int)

  public required override init(`param`: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ClassWithDesignatedInitializer`.
public func mock(_ type: MockingbirdTestsHost.ClassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> ClassWithDesignatedInitializerMock.InitializerProxy.Type {
  return ClassWithDesignatedInitializerMock.InitializerProxy.self
}

// MARK: - Mocked ClassWithoutDesignatedInitializer

public final class ClassWithoutDesignatedInitializerMock: MockingbirdTestsHost.ClassWithoutDesignatedInitializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassWithoutDesignatedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ClassWithoutDesignatedInitializer`.
public func mock(_ type: MockingbirdTestsHost.ClassWithoutDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> ClassWithoutDesignatedInitializerMock {
  return ClassWithoutDesignatedInitializerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClosureParametersProtocol

public final class ClosureParametersProtocolMock: MockingbirdTestsHost.ClosureParametersProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClosureParametersProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `autoclosureTrivialClosure`(`block`: @autoclosure () -> Void)

  public func `autoclosureTrivialClosure`(`block`: @autoclosure () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialClosure`(`block`: @autoclosure () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@autoclosure () -> Void) -> Bool {
        return concreteImplementation(`block`())
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `autoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialClosure`(`block`: @autoclosure () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool)

  public func `autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Bool>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@autoclosure () -> Bool) -> Bool {
        return concreteImplementation(`block`())
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `autoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`autoclosureTrivialReturningClosure`(`block`: @autoclosure () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void)

  public func `escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Void) -> Bool {
        return concreteImplementation(`block`())
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialClosure`(`block`: @escaping @autoclosure () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool)

  public func `escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Bool) -> Bool {
        return concreteImplementation(`block`())
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingAutoclosureTrivialReturningClosure`(`block`: @escaping @autoclosure () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void)

  public func `escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping (Bool) -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `escapingParameterizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedClosure`(`block`: @escaping (Bool) -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool)

  public func `escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping (Bool) -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `escapingParameterizedReturningClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingParameterizedReturningClosure`(`block`: @escaping (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingTrivialClosure`(`block`: @escaping () -> Void)

  public func `escapingTrivialClosure`(`block`: @escaping () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialClosure`(`block`: @escaping () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping () -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `escapingTrivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialClosure`(`block`: @escaping () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingTrivialReturningClosure`(`block`: @escaping () -> Bool)

  public func `escapingTrivialReturningClosure`(`block`: @escaping () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialReturningClosure`(`block`: @escaping () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping () -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `escapingTrivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`escapingTrivialReturningClosure`(`block`: @escaping () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool))

  public func `implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool)) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool)) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((a: () -> Void, b: (Bool) -> Bool)) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `implicitEscapingMultipleLabeledTupleClosure`(`block`: @escaping @autoclosure () -> (a: () -> Void, b: (Bool) -> Bool)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: () -> Void, b: (Bool) -> Bool)) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleLabeledTupleClosure`(`block`: (a: () -> Void, b: (Bool) -> Bool)) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: () -> Void, b: (Bool) -> Bool)) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool))

  public func `implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool)) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool)) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((() -> Void, (Bool) -> Bool)) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `implicitEscapingMultipleTupleClosure`(`block`: @escaping @autoclosure () -> (() -> Void, (Bool) -> Bool)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void, (Bool) -> Bool)) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingMultipleTupleClosure`(`block`: (() -> Void, (Bool) -> Bool)) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void, (Bool) -> Bool)) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?)

  public func `implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (((Bool) -> Void)?) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `implicitEscapingParameterizedClosure`(`block`: @escaping @autoclosure () -> ((Bool) -> Void)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Void)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedClosure`(`block`: ((Bool) -> Void)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Void)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?)

  public func `implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (((Bool) -> Bool)?) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `implicitEscapingParameterizedReturningClosure`(`block`: @escaping @autoclosure () -> ((Bool) -> Bool)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Bool)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingParameterizedReturningClosure`(`block`: ((Bool) -> Bool)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (((Bool) -> Bool)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingTrivialClosure`(`block`: (() -> Void)?)

  public func `implicitEscapingTrivialClosure`(`block`: (() -> Void)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialClosure`(`block`: (() -> Void)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((() -> Void)?) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `implicitEscapingTrivialClosure`(`block`: @escaping @autoclosure () -> (() -> Void)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialClosure`(`block`: (() -> Void)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?)

  public func `implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((() -> Bool)?) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `implicitEscapingTrivialReturningClosure`(`block`: @escaping @autoclosure () -> (() -> Bool)?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Bool)?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`implicitEscapingTrivialReturningClosure`(`block`: (() -> Bool)?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Bool)?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??)

  public func `nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((() -> Void)??) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `nestedOptionalTrivialParenthesizedClosure`(`block`: @escaping @autoclosure () -> (() -> Void)??) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)??) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedOptionalTrivialParenthesizedClosure`(`block`: (() -> Void)??) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((() -> Void)??) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool)

  public func `nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `nestedParameterizedReturningParenthesizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedParameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedClosure`(`block`: (Bool) -> Void)

  public func `parameterizedClosure`(`block`: (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Void>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parameterizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedParenthesizedClosure`(`block`: (Bool) -> Void)

  public func `parameterizedParenthesizedClosure`(`block`: (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedParenthesizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Void>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parameterizedParenthesizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedParenthesizedClosure`(`block`: (Bool) -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningClosure`(`block`: (Bool) -> Bool)

  public func `parameterizedReturningClosure`(`block`: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parameterizedReturningClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool)

  public func `parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parameterizedReturningParenthesizedClosure`(`block`: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningParenthesizedClosure`(`block`: (Bool) -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialClosure`(`block`: () -> Void)

  public func `trivialClosure`(`block`: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialClosure`(`block`: () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `trivialClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialClosure`(`block`: () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialParenthesizedClosure`(`block`: () -> Void)

  public func `trivialParenthesizedClosure`(`block`: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `trivialParenthesizedClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialReturningClosure`(`block`: () -> Bool)

  public func `trivialReturningClosure`(`block`: () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningClosure`(`block`: () -> Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Bool>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `trivialReturningClosure`(`block`: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningClosure`(`block`: () -> Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialReturningParenthesizedClosure`(`block`: () -> Void)

  public func `trivialReturningParenthesizedClosure`(`block`: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() -> Void) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `trivialReturningParenthesizedClosure`(`block`: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialReturningParenthesizedClosure`(`block`: () -> Void) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper)

  public func `wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ClosureWrapper) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `wrappedClosureParameter`(`block`: @escaping @autoclosure () -> MockingbirdTestsHost.ClosureWrapper) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClosureWrapper) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`wrappedClosureParameter`(`block`: MockingbirdTestsHost.ClosureWrapper) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.ClosureWrapper) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ClosureParametersProtocol`.
public func mock(_ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ClosureParametersProtocolMock {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked CodableConformingClass

public final class CodableConformingClassMock: MockingbirdTestsHost.CodableConformingClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CodableConformingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`from` `decoder`: Decoder, __file: StaticString = #file, __line: UInt = #line) throws -> CodableConformingClassMock {
      let mock: CodableConformingClassMock = try CodableConformingClassMock(from: `decoder`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws {
    try super.init(from: `decoder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`from` `decoder`: Decoder) throws ", arguments: [Mockingbird.ArgumentMatcher(`decoder`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.CodableConformingClass`.
public func mock(_ type: MockingbirdTestsHost.CodableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> CodableConformingClassMock.InitializerProxy.Type {
  return CodableConformingClassMock.InitializerProxy.self
}

// MARK: - Mocked CodableConformingProtocol

public final class CodableConformingProtocolMock: MockingbirdTestsHost.CodableConformingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CodableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `encode`(`to` `encoder`: Encoder)

  public func `encode`(`to` `encoder`: Encoder) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(`encoder`)])
    try mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Encoder) throws -> Void {
        try concreteImplementation(`encoder`)
      } else if let concreteImplementation = implementation as? () throws -> Void {
        try concreteImplementation()
      }
    }
  }

  public func `encode`(`to` `encoder`: @escaping @autoclosure () -> Encoder) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`encoder`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`from` `decoder`: Decoder) throws ", arguments: [Mockingbird.ArgumentMatcher(`decoder`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CodableConformingProtocol`.
public func mock(_ type: MockingbirdTestsHost.CodableConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CodableConformingProtocolMock {
  return CodableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked CommentBlockNotDebugCompilationDirectiveProtocol

public final class CommentBlockNotDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CommentBlockNotDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.CommentBlockNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CommentBlockNotDebugCompilationDirectiveProtocolMock {
  return CommentBlockNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked CompilationDirectiveProtocol

public final class CompilationDirectiveProtocolMock: MockingbirdTestsHost.CompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG

  // MARK: Mocked debugVariable

  public var `debugVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "debugVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getDebugVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "debugVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if !(DEBUG) && !(RELEASE)

  // MARK: Mocked defaultVariable

  public var `defaultVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "defaultVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getDefaultVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "defaultVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if DEBUG
  #if !(!(DEBUG))

  // MARK: Mocked nestedDebugVariable

  public var `nestedDebugVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedDebugVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getNestedDebugVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedDebugVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if DEBUG
  #if !(!(!(DEBUG))) && !(RELEASE)

  // MARK: Mocked nestedDefaultVariable

  public var `nestedDefaultVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedDefaultVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getNestedDefaultVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedDefaultVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if DEBUG
  #if !(!(!(DEBUG))) && RELEASE

  // MARK: Mocked nestedReleaseVariable

  public var `nestedReleaseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedReleaseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getNestedReleaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nestedReleaseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if DEBUG

  // MARK: Mocked onlyDebugVariable

  public var `onlyDebugVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "onlyDebugVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOnlyDebugVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "onlyDebugVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if !(DEBUG) && RELEASE

  // MARK: Mocked releaseVariable

  public var `releaseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "releaseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getReleaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "releaseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  #if DEBUG

  // MARK: Mocked `debugMethod`()

  public func `debugMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debugMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `debugMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debugMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif

  #if !(DEBUG) && !(RELEASE)

  // MARK: Mocked `defaultMethod`()

  public func `defaultMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`defaultMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `defaultMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`defaultMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif

  // MARK: Mocked `method`()

  public func `method`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #if DEBUG
  #if !(!(DEBUG))

  // MARK: Mocked `nestedDebugMethod`()

  public func `nestedDebugMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedDebugMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `nestedDebugMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedDebugMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if DEBUG
  #if !(!(!(DEBUG))) && !(RELEASE)

  // MARK: Mocked `nestedDefaultMethod`()

  public func `nestedDefaultMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedDefaultMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `nestedDefaultMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedDefaultMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if DEBUG
  #if !(!(!(DEBUG))) && RELEASE

  // MARK: Mocked `nestedReleaseMethod`()

  public func `nestedReleaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedReleaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `nestedReleaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nestedReleaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  #if DEBUG

  // MARK: Mocked `onlyDebugMethod`()

  public func `onlyDebugMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onlyDebugMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `onlyDebugMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onlyDebugMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif

  #if !(DEBUG) && RELEASE

  // MARK: Mocked `releaseMethod`()

  public func `releaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`releaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `releaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`releaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  #endif
}

/// Initialize a protocol mock of `MockingbirdTestsHost.CompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.CompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CompilationDirectiveProtocolMock {
  return CompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ConformingExternalClassConstrainedProtocol

public final class ConformingExternalClassConstrainedProtocolMock: AppKit.NSViewController, MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConformingExternalClassConstrainedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> ConformingExternalClassConstrainedProtocolMock? {
      let mock: ConformingExternalClassConstrainedProtocolMock? = ConformingExternalClassConstrainedProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> ConformingExternalClassConstrainedProtocolMock {
      let mock: ConformingExternalClassConstrainedProtocolMock = ConformingExternalClassConstrainedProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ConformingExternalClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ConformingExternalClassConstrainedProtocolMock.InitializerProxy.Type {
  return ConformingExternalClassConstrainedProtocolMock.InitializerProxy.self
}

// MARK: - Mocked ConformingInitializableOpenClassConstrainedProtocol

public final class ConformingInitializableOpenClassConstrainedProtocolMock: MockingbirdModuleTestsHost.InitializableOpenClass, MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConformingInitializableOpenClassConstrainedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> ConformingInitializableOpenClassConstrainedProtocolMock {
      let mock: ConformingInitializableOpenClassConstrainedProtocolMock = ConformingInitializableOpenClassConstrainedProtocolMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ConformingInitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy.Type {
  return ConformingInitializableOpenClassConstrainedProtocolMock.InitializerProxy.self
}

// MARK: - Mocked ConformingUninitializableOpenClassConstrainedProtocol

public final class ConformingUninitializableOpenClassConstrainedProtocolMock: MockingbirdModuleTestsHost.OpenClass, MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConformingUninitializableOpenClassConstrainedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ConformingUninitializableOpenClassConstrainedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy.Type {
  return ConformingUninitializableOpenClassConstrainedProtocolMock.InitializerProxy.self
}

// MARK: - Mocked ConstrainedUnspecializedGenericSubclass

public final class ConstrainedUnspecializedGenericSubclassMock<T: Swift.Equatable>: MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "ConstrainedUnspecializedGenericSubclassMock<T: Swift.Equatable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConstrainedUnspecializedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> T in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> T {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ConstrainedUnspecializedGenericSubclass<T>`.
public func mock<T: Swift.Equatable>(_ type: ConstrainedUnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> ConstrainedUnspecializedGenericSubclassMock<T> {
  return ConstrainedUnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ConvenienceInitializerClass

public final class ConvenienceInitializerClassMock: MockingbirdTestsHost.ConvenienceInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConvenienceInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> ConvenienceInitializerClassMock {
      let mock: ConvenienceInitializerClassMock = ConvenienceInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required override init(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ConvenienceInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> ConvenienceInitializerClassMock.InitializerProxy.Type {
  return ConvenienceInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked DebugCompilationDirectiveProtocol

#if DEBUG

public final class DebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.DebugCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if DEBUG

/// Initialize a protocol mock of `MockingbirdTestsHost.DebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.DebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DebugCompilationDirectiveProtocolMock {
  return DebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif

// MARK: - Mocked DeclarationAttributesClass

public final class DeclarationAttributesClassMock: MockingbirdTestsHost.DeclarationAttributesClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeclarationAttributesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked availableVariable

  @available(iOS 10.0, *)
  override public var `availableVariable`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> String in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> String {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (String).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  @available(iOS 10.0, *)
  public func getAvailableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `availableMethod`(`param`: String)

  @available(iOS 10.0, *)
  public override func `availableMethod`(`param`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Bool {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  @available(iOS 10.0, *)
  public func `availableMethod`(`param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `multipleAttributesMethod`(`param`: String)

  @available(iOS 10.0, *)
  public override func `multipleAttributesMethod`(`param`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`multipleAttributesMethod`(`param`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Bool {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  @available(iOS 10.0, *)
  public func `multipleAttributesMethod`(`param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`multipleAttributesMethod`(`param`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.DeclarationAttributesClass`.
public func mock(_ type: MockingbirdTestsHost.DeclarationAttributesClass.Type, file: StaticString = #file, line: UInt = #line) -> DeclarationAttributesClassMock {
  return DeclarationAttributesClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DeclarationAttributesProtocol

public final class DeclarationAttributesProtocolMock: MockingbirdTestsHost.DeclarationAttributesProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeclarationAttributesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked availableVariable

  @available(iOS 10.0, *)
  public var `availableVariable`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> String in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> String {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (String).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  @available(iOS 10.0, *)
  public func getAvailableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `availableMethod`(`param`: String)

  @available(iOS 10.0, *)
  public func `availableMethod`(`param`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Bool {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  @available(iOS 10.0, *)
  public func `availableMethod`(`param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`availableMethod`(`param`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeclarationAttributesProtocol`.
public func mock(_ type: MockingbirdTestsHost.DeclarationAttributesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DeclarationAttributesProtocolMock {
  return DeclarationAttributesProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DefaultArgumentValuesClass

public final class DefaultArgumentValuesClassMock: MockingbirdTestsHost.DefaultArgumentValuesClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject])

  public override func `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> String, `param2`: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.DefaultArgumentValuesClass`.
public func mock(_ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type, file: StaticString = #file, line: UInt = #line) -> DefaultArgumentValuesClassMock {
  return DefaultArgumentValuesClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DefaultArgumentValuesProtocol

public final class DefaultArgumentValuesProtocolMock: MockingbirdTestsHost.DefaultArgumentValuesProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject])

  public func `method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> String, `param2`: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: String, `param2`: [MockingbirdTestsHost.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DefaultArgumentValuesProtocol`.
public func mock(_ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DefaultArgumentValuesProtocolMock {
  return DefaultArgumentValuesProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DefaultCompilationDirectiveProtocol

#if !(DEBUG) && !(RELEASE)

public final class DefaultCompilationDirectiveProtocolMock: MockingbirdTestsHost.DefaultCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if !(DEBUG) && !(RELEASE)

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if !(DEBUG) && !(RELEASE)

/// Initialize a protocol mock of `MockingbirdTestsHost.DefaultCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.DefaultCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DefaultCompilationDirectiveProtocolMock {
  return DefaultCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif

// MARK: - Mocked DeprecatedClassOnlyProtocolWithInheritance

public final class DeprecatedClassOnlyProtocolWithInheritanceMock: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeprecatedClassOnlyProtocolWithInheritanceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance`.
public func mock(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocolWithInheritance.Protocol, file: StaticString = #file, line: UInt = #line) -> DeprecatedClassOnlyProtocolWithInheritanceMock {
  return DeprecatedClassOnlyProtocolWithInheritanceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DeprecatedClassOnlyProtocol

public final class DeprecatedClassOnlyProtocolMock: MockingbirdTestsHost.DeprecatedClassOnlyProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeprecatedClassOnlyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DeprecatedClassOnlyProtocol`.
public func mock(_ type: MockingbirdTestsHost.DeprecatedClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> DeprecatedClassOnlyProtocolMock {
  return DeprecatedClassOnlyProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DictionaryCollection

public final class DictionaryCollectionMock: MockingbirdTestsHost.DictionaryCollection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(`objects`: [String: String])

  public func `method`(`objects`: [String: String]) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String: String]) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([String: String]) -> Bool {
        return concreteImplementation(`objects`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(`objects`: @escaping @autoclosure () -> [String: String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String: String]) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`objects`: [String: String]) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String: String]) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryCollection`.
public func mock(_ type: MockingbirdTestsHost.DictionaryCollection.Protocol, file: StaticString = #file, line: UInt = #line) -> DictionaryCollectionMock {
  return DictionaryCollectionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DictionaryTypes

public final class DictionaryTypesMock: MockingbirdTestsHost.DictionaryTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherVariable

  public var `anotherVariable`: [Foundation.URL: Foundation.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [Foundation.URL: Foundation.NSObject] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Foundation.URL: Foundation.NSObject]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitAnotherVariable

  public var `explicitAnotherVariable`: Dictionary<Foundation.URL, Foundation.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Dictionary<Foundation.URL, Foundation.NSObject> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<Foundation.URL, Foundation.NSObject>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked explicitVariable

  public var `explicitVariable`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalAnotherVariable

  public var `optionalAnotherVariable`: [Foundation.URL: Foundation.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [Foundation.URL: Foundation.NSObject?] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject?] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Foundation.URL: Foundation.NSObject?]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitAnotherVariable

  public var `optionalExplicitAnotherVariable`: Dictionary<Foundation.URL, Foundation.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Dictionary<Foundation.URL, Foundation.NSObject?> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject?> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<Foundation.URL, Foundation.NSObject?>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalExplicitVariable

  public var `optionalExplicitVariable`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Dictionary<Foundation.URL, Foundation.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Dictionary<Foundation.URL, Foundation.NSObject> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<Foundation.URL, Foundation.NSObject>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`()

  public func `explicitMethod`() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>)

  public func `explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `explicitMethod`(`param1`: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethod`(`param1`: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, `param2`: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethodWithParameterLabels`()

  public func `explicitMethodWithParameterLabels`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `explicitMethodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`explicitMethodWithParameterLabels`() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [Foundation.URL: Foundation.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> [Foundation.URL: Foundation.NSObject] in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject] {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject] {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([Foundation.URL: Foundation.NSObject]).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject])

  public func `method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], `param2`: [Foundation.URL: Foundation.NSObject]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels`()

  public func `methodWithParameterLabels`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DictionaryTypes`.
public func mock(_ type: MockingbirdTestsHost.DictionaryTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> DictionaryTypesMock {
  return DictionaryTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DirectoryNonRelativeIgnoredSource

public final class DirectoryNonRelativeIgnoredSourceMock: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DirectoryNonRelativeIgnoredSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource`.
public func mock(_ type: MockingbirdTestsHost.DirectoryNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> DirectoryNonRelativeIgnoredSourceMock {
  return DirectoryNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyClass

public final class EmptyClassMock: MockingbirdTestsHost.EmptyClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyClass`.
public func mock(_ type: MockingbirdTestsHost.EmptyClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyClassMock {
  return EmptyClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyInheritingClass

public final class EmptyInheritingClassMock: MockingbirdTestsHost.EmptyInheritingClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInheritingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childClassVariable

  override public class var `childClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getChildClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childComputedInstanceVariable

  override public var `childComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredFileprivateSetterInstanceVariable

  override public var `childStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredInstanceVariable

  override public var `childStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childStoredPrivateSetterInstanceVariable

  override public var `childStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentClassVariable

  override public class var `parentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentComputedInstanceVariable

  override public var `parentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredFileprivateSetterInstanceVariable

  override public var `parentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredInstanceVariable

  override public var `parentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredPrivateSetterInstanceVariable

  override public var `parentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `childParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialClassMethod`()

  public override static func `childTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `childTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public override func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod`()

  public override static func `parentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public override func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.EmptyInheritingClass`.
public func mock(_ type: MockingbirdTestsHost.EmptyInheritingClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyInheritingClassMock {
  return EmptyInheritingClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyInheritingProtocol

public final class EmptyInheritingProtocolMock: MockingbirdTestsHost.EmptyInheritingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInheritingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked childInstanceVariable

  public var `childInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterInstanceVariable

  public var `childPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childPrivateSetterStaticVariable

  public class var `childPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked childStaticVariable

  public class var `childStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `childParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `childParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod`()

  public func `childTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `childTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod`()

  public static func `childTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `childTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`childTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInheritingProtocol`.
public func mock(_ type: MockingbirdTestsHost.EmptyInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyInheritingProtocolMock {
  return EmptyInheritingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyInitializerClass

public final class EmptyInitializerClassMock: MockingbirdTestsHost.EmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> EmptyInitializerClassMock {
      let mock: EmptyInitializerClassMock = EmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.EmptyInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.EmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> EmptyInitializerClassMock.InitializerProxy.Type {
  return EmptyInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked EmptyInitializerProtocol

public final class EmptyInitializerProtocolMock: MockingbirdTestsHost.EmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init()

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyInitializerProtocolMock {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyProtocol

public final class EmptyProtocolMock: MockingbirdTestsHost.EmptyProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EmptyProtocol`.
public func mock(_ type: MockingbirdTestsHost.EmptyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> EmptyProtocolMock {
  return EmptyProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EnclosingDirectoryOverriddenIncludedSource

public final class EnclosingDirectoryOverriddenIncludedSourceMock: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EnclosingDirectoryOverriddenIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.EnclosingDirectoryOverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> EnclosingDirectoryOverriddenIncludedSourceMock {
  return EnclosingDirectoryOverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EquatableCodableConformingProtocol

public final class EquatableCodableConformingProtocolMock: MockingbirdTestsHost.EquatableCodableConformingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EquatableCodableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock)

  public static func ==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableCodableConformingProtocolMock, EquatableCodableConformingProtocolMock) -> Bool {
        return concreteImplementation(`lhs`, `rhs`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> EquatableCodableConformingProtocolMock, _ `rhs`: @escaping @autoclosure () -> EquatableCodableConformingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableCodableConformingProtocolMock, EquatableCodableConformingProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableCodableConformingProtocolMock, _ `rhs`: EquatableCodableConformingProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableCodableConformingProtocolMock, EquatableCodableConformingProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `encode`(`to` `encoder`: Encoder)

  public func `encode`(`to` `encoder`: Encoder) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(`encoder`)])
    try mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Encoder) throws -> Void {
        try concreteImplementation(`encoder`)
      } else if let concreteImplementation = implementation as? () throws -> Void {
        try concreteImplementation()
      }
    }
  }

  public func `encode`(`to` `encoder`: @escaping @autoclosure () -> Encoder) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`encoder`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`encode`(`to` `encoder`: Encoder) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Encoder) throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`from` `decoder`: Decoder)

  public required init(`from` `decoder`: Decoder) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`from` `decoder`: Decoder) throws ", arguments: [Mockingbird.ArgumentMatcher(`decoder`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableCodableConformingProtocol`.
public func mock(_ type: EquatableCodableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> EquatableCodableConformingProtocolMock {
  return EquatableCodableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EquatableConformingClass

public final class EquatableConformingClassMock: MockingbirdTestsHost.EquatableConformingClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EquatableConformingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.EquatableConformingClass`.
public func mock(_ type: MockingbirdTestsHost.EquatableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> EquatableConformingClassMock {
  return EquatableConformingClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EquatableConformingProtocol

public final class EquatableConformingProtocolMock: MockingbirdTestsHost.EquatableConformingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EquatableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock)

  public static func ==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (EquatableConformingProtocolMock, EquatableConformingProtocolMock) -> Bool {
        return concreteImplementation(`lhs`, `rhs`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> EquatableConformingProtocolMock, _ `rhs`: @escaping @autoclosure () -> EquatableConformingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableConformingProtocolMock, EquatableConformingProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: EquatableConformingProtocolMock, _ `rhs`: EquatableConformingProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableConformingProtocolMock, EquatableConformingProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.EquatableConformingProtocol`.
public func mock(_ type: EquatableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> EquatableConformingProtocolMock {
  return EquatableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ExtendableProtocol

public final class ExtendableProtocolMock: MockingbirdTestsHost.ExtendableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherExtendedVariable

  public var `anotherExtendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked baseVariable

  public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedVariable

  public var `extendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `anotherTrivialExtendedMethod`()

  public func `anotherTrivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `anotherTrivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedExtendedMethod`(`param1`: Bool)

  public func `parameterizedExtendedMethod`(`param1`: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(`param1`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parameterizedExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningExtendedMethod`(`param1`: Bool)

  public func `parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Bool {
        return concreteImplementation(`param1`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parameterizedReturningExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialBaseMethod`()

  public func `trivialBaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `trivialBaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialExtendedMethod`()

  public func `trivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `trivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ExtendableProtocol`.
public func mock(_ type: MockingbirdTestsHost.ExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ExtendableProtocolMock {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableEmptyInitializerClass

public final class FailableEmptyInitializerClassMock: MockingbirdTestsHost.FailableEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableEmptyInitializerClassMock? {
      let mock: FailableEmptyInitializerClassMock? = FailableEmptyInitializerClassMock()
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init?()

  public required override init?() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableEmptyInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableEmptyInitializerClassMock.InitializerProxy.Type {
  return FailableEmptyInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableEmptyInitializerProtocol

public final class FailableEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init?()

  public required init?() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableEmptyInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableEmptyInitializerProtocolMock {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableParameterizedInitializerClass

public final class FailableParameterizedInitializerClassMock: MockingbirdTestsHost.FailableParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableParameterizedInitializerClassMock? {
      let mock: FailableParameterizedInitializerClassMock? = FailableParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init?(`param1`: Bool, `param2`: Int)

  public required override init?(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableParameterizedInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableParameterizedInitializerClassMock.InitializerProxy.Type {
  return FailableParameterizedInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableParameterizedInitializerProtocol

public final class FailableParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init?(`param1`: Bool, `param2`: Int)

  public required init?(`param1`: Bool, `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableParameterizedInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableParameterizedInitializerProtocolMock {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerClass

public final class FailableUnwrappedEmptyInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedEmptyInitializerClassMock {
      let mock: FailableUnwrappedEmptyInitializerClassMock = FailableUnwrappedEmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init!()

  public required override init!() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedEmptyInitializerClassMock.InitializerProxy.Type {
  return FailableUnwrappedEmptyInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerProtocol

public final class FailableUnwrappedEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init!()

  public required init!() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedEmptyInitializerProtocolMock {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerClass

public final class FailableUnwrappedParameterizedInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedParameterizedInitializerClassMock {
      let mock: FailableUnwrappedParameterizedInitializerClassMock = FailableUnwrappedParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init!(`param1`: Bool, `param2`: Int)

  public required override init!(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy.Type {
  return FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerProtocol

public final class FailableUnwrappedParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init!(`param1`: Bool, `param2`: Int)

  public required init!(`param1`: Bool, `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FailableUnwrappedParameterizedInitializerProtocolMock {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FakeableClass

public final class FakeableClassMock: MockingbirdTestsHost.FakeableClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FakeableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param`: String, __file: StaticString = #file, __line: UInt = #line) -> FakeableClassMock {
      let mock: FakeableClassMock = FakeableClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param`: String)

  public required override init(`param`: String) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FakeableClass`.
public func mock(_ type: MockingbirdTestsHost.FakeableClass.Type, file: StaticString = #file, line: UInt = #line) -> FakeableClassMock.InitializerProxy.Type {
  return FakeableClassMock.InitializerProxy.self
}

// MARK: - Mocked FakeableGenericClass

public final class FakeableGenericClassMock<T>: MockingbirdTestsHost.FakeableGenericClass<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "FakeableGenericClassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FakeableGenericClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param`: T, __file: StaticString = #file, __line: UInt = #line) -> FakeableGenericClassMock<T> {
      let mock: FakeableGenericClassMock<T> = FakeableGenericClassMock<T>(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param`: T)

  public required override init(`param`: T) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.FakeableGenericClass<T>`.
public func mock<T>(_ type: FakeableGenericClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> FakeableGenericClassMock<T>.InitializerProxy.Type {
  return FakeableGenericClassMock<T>.InitializerProxy.self
}

// MARK: - Mocked FakeableProtocol

public final class FakeableProtocolMock: MockingbirdTestsHost.FakeableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FakeableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FakeableProtocol`.
public func mock(_ type: MockingbirdTestsHost.FakeableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> FakeableProtocolMock {
  return FakeableProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FakeableTypeReferencer

public final class FakeableTypeReferencerMock: MockingbirdTestsHost.FakeableTypeReferencer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FakeableTypeReferencerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fakeable2Tuple`()

  public func `fakeable2Tuple`() -> (String, Int) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable2Tuple`() -> (String, Int)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (String, Int) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (String, Int) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (String, Int) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((String, Int)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeable2Tuple`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int), (String, Int)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable2Tuple`() -> (String, Int)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int), (String, Int)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeable3Tuple`()

  public func `fakeable3Tuple`() -> (String, Int, Bool) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable3Tuple`() -> (String, Int, Bool)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (String, Int, Bool) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (String, Int, Bool) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (String, Int, Bool) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((String, Int, Bool)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeable3Tuple`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool), (String, Int, Bool)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable3Tuple`() -> (String, Int, Bool)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool), (String, Int, Bool)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeable4Tuple`()

  public func `fakeable4Tuple`() -> (String, Int, Bool, Double) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable4Tuple`() -> (String, Int, Bool, Double)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (String, Int, Bool, Double) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (String, Int, Bool, Double) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (String, Int, Bool, Double) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((String, Int, Bool, Double)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeable4Tuple`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool, Double), (String, Int, Bool, Double)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable4Tuple`() -> (String, Int, Bool, Double)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool, Double), (String, Int, Bool, Double)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeable5Tuple`()

  public func `fakeable5Tuple`() -> (String, Int, Bool, Double, Float) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable5Tuple`() -> (String, Int, Bool, Double, Float)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (String, Int, Bool, Double, Float) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (String, Int, Bool, Double, Float) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (String, Int, Bool, Double, Float) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((String, Int, Bool, Double, Float)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeable5Tuple`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool, Double, Float), (String, Int, Bool, Double, Float)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable5Tuple`() -> (String, Int, Bool, Double, Float)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool, Double, Float), (String, Int, Bool, Double, Float)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeable6Tuple`()

  public func `fakeable6Tuple`() -> (String, Int, Bool, Double, Float, UInt) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable6Tuple`() -> (String, Int, Bool, Double, Float, UInt)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (String, Int, Bool, Double, Float, UInt) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (String, Int, Bool, Double, Float, UInt) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (String, Int, Bool, Double, Float, UInt) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((String, Int, Bool, Double, Float, UInt)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeable6Tuple`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool, Double, Float, UInt), (String, Int, Bool, Double, Float, UInt)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeable6Tuple`() -> (String, Int, Bool, Double, Float, UInt)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (String, Int, Bool, Double, Float, UInt), (String, Int, Bool, Double, Float, UInt)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableArray`()

  public func `fakeableArray`() -> Array<String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableArray`() -> Array<String>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Array<String> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Array<String> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Array<String> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<String>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableArray`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<String>, Array<String>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableArray`() -> Array<String>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<String>, Array<String>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableBool`()

  public func `fakeableBool`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableBool`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableBool`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableBool`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableCGFloat`()

  public func `fakeableCGFloat`() -> CGFloat {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableCGFloat`() -> CGFloat", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> CGFloat in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> CGFloat {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> CGFloat {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (CGFloat).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableCGFloat`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> CGFloat, CGFloat> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableCGFloat`() -> CGFloat", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> CGFloat, CGFloat>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableCGPoint`()

  public func `fakeableCGPoint`() -> CGPoint {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableCGPoint`() -> CGPoint", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> CGPoint in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> CGPoint {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> CGPoint {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (CGPoint).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableCGPoint`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> CGPoint, CGPoint> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableCGPoint`() -> CGPoint", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> CGPoint, CGPoint>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableClass`()

  public func `fakeableClass`() -> MockingbirdTestsHost.FakeableClass {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableClass`() -> MockingbirdTestsHost.FakeableClass", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.FakeableClass in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableClass {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableClass {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.FakeableClass).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableClass`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableClass`() -> MockingbirdTestsHost.FakeableClass", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableDate`()

  public func `fakeableDate`() -> Date {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableDate`() -> Date", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Date in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Date {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Date {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Date).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableDate`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Date, Date> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableDate`() -> Date", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Date, Date>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableDictionary`()

  public func `fakeableDictionary`() -> Dictionary<String, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableDictionary`() -> Dictionary<String, Int>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Dictionary<String, Int> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Dictionary<String, Int> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Dictionary<String, Int> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Dictionary<String, Int>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableDictionary`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<String, Int>, Dictionary<String, Int>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableDictionary`() -> Dictionary<String, Int>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<String, Int>, Dictionary<String, Int>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableDouble`()

  public func `fakeableDouble`() -> Double {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableDouble`() -> Double", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Double in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Double {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Double {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Double).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableDouble`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Double, Double> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableDouble`() -> Double", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Double, Double>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableEnum`()

  public func `fakeableEnum`() -> MockingbirdTestsHost.FakeableEnum {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableEnum`() -> MockingbirdTestsHost.FakeableEnum", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.FakeableEnum in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableEnum {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableEnum {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.FakeableEnum).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableEnum`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableEnum, MockingbirdTestsHost.FakeableEnum> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableEnum`() -> MockingbirdTestsHost.FakeableEnum", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableEnum, MockingbirdTestsHost.FakeableEnum>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableFloat`()

  public func `fakeableFloat`() -> Float {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableFloat`() -> Float", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Float in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Float {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Float {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Float).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableFloat`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Float, Float> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableFloat`() -> Float", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Float, Float>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableGenericClass`<T>()

  public func `fakeableGenericClass`<T>() -> MockingbirdTestsHost.FakeableGenericClass<T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableGenericClass`<T>() -> MockingbirdTestsHost.FakeableGenericClass<T>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.FakeableGenericClass<T> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableGenericClass<T> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableGenericClass<T> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.FakeableGenericClass<T>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableGenericClass`<T>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableGenericClass<T>, MockingbirdTestsHost.FakeableGenericClass<T>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableGenericClass`<T>() -> MockingbirdTestsHost.FakeableGenericClass<T>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableGenericClass<T>, MockingbirdTestsHost.FakeableGenericClass<T>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableInt`()

  public func `fakeableInt`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableInt`() -> Int", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableInt`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableInt`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableNSCache`()

  public func `fakeableNSCache`() -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableNSCache`() -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableNSCache`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>, NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableNSCache`() -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>, NSCache<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableNSHashTable`()

  public func `fakeableNSHashTable`() -> NSHashTable<MockingbirdTestsHost.FakeableClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableNSHashTable`() -> NSHashTable<MockingbirdTestsHost.FakeableClass>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> NSHashTable<MockingbirdTestsHost.FakeableClass> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> NSHashTable<MockingbirdTestsHost.FakeableClass> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> NSHashTable<MockingbirdTestsHost.FakeableClass> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (NSHashTable<MockingbirdTestsHost.FakeableClass>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableNSHashTable`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> NSHashTable<MockingbirdTestsHost.FakeableClass>, NSHashTable<MockingbirdTestsHost.FakeableClass>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableNSHashTable`() -> NSHashTable<MockingbirdTestsHost.FakeableClass>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> NSHashTable<MockingbirdTestsHost.FakeableClass>, NSHashTable<MockingbirdTestsHost.FakeableClass>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableNSMapTable`()

  public func `fakeableNSMapTable`() -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableNSMapTable`() -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableNSMapTable`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>, NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableNSMapTable`() -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>, NSMapTable<MockingbirdTestsHost.FakeableClass, MockingbirdTestsHost.FakeableClass>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableProtocol`()

  public func `fakeableProtocol`() -> MockingbirdTestsHost.FakeableProtocol {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableProtocol`() -> MockingbirdTestsHost.FakeableProtocol", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.FakeableProtocol in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableProtocol {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableProtocol {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.FakeableProtocol).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableProtocol`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableProtocol, MockingbirdTestsHost.FakeableProtocol> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableProtocol`() -> MockingbirdTestsHost.FakeableProtocol", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableProtocol, MockingbirdTestsHost.FakeableProtocol>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableSet`()

  public func `fakeableSet`() -> Set<String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableSet`() -> Set<String>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Set<String> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Set<String> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Set<String> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Set<String>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableSet`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Set<String>, Set<String>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableSet`() -> Set<String>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Set<String>, Set<String>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableString`()

  public func `fakeableString`() -> String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableString`() -> String", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> String in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> String {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> String {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (String).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableString`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableString`() -> String", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableStruct`()

  public func `fakeableStruct`() -> MockingbirdTestsHost.FakeableStruct {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableStruct`() -> MockingbirdTestsHost.FakeableStruct", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.FakeableStruct in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableStruct {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableStruct {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.FakeableStruct).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableStruct`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableStruct, MockingbirdTestsHost.FakeableStruct> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableStruct`() -> MockingbirdTestsHost.FakeableStruct", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableStruct, MockingbirdTestsHost.FakeableStruct>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableTypealias`()

  public func `fakeableTypealias`() -> MockingbirdTestsHost.FakeableTypealias {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableTypealias`() -> MockingbirdTestsHost.FakeableTypealias", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.FakeableTypealias in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableTypealias {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.FakeableTypealias {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.FakeableTypealias).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableTypealias`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableTypealias, MockingbirdTestsHost.FakeableTypealias> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableTypealias`() -> MockingbirdTestsHost.FakeableTypealias", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.FakeableTypealias, MockingbirdTestsHost.FakeableTypealias>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fakeableUInt`()

  public func `fakeableUInt`() -> UInt {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableUInt`() -> UInt", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> UInt in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> UInt {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> UInt {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (UInt).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `fakeableUInt`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> UInt, UInt> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fakeableUInt`() -> UInt", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> UInt, UInt>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.FakeableTypeReferencer`.
public func mock(_ type: MockingbirdTestsHost.FakeableTypeReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> FakeableTypeReferencerMock {
  return FakeableTypeReferencerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GenericBaseClass

public final class GenericBaseClassMock<T>: MockingbirdTestsHost.GenericBaseClass<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "GenericBaseClassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GenericBaseClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> T in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> T {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.GenericBaseClass<T>`.
public func mock<T>(_ type: GenericBaseClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> GenericBaseClassMock<T> {
  return GenericBaseClassMock<T>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GenericClassReferencer

public final class GenericClassReferencerMock: MockingbirdTestsHost.GenericClassReferencer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GenericClassReferencerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked genericClassVariable

  public var `genericClassVariable`: MockingbirdTestsHost.ReferencedGenericClass<String> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.ReferencedGenericClass<String> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClass<String> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.ReferencedGenericClass<String>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ReferencedGenericClass<String>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGenericClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<String>, MockingbirdTestsHost.ReferencedGenericClass<String>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<String>, MockingbirdTestsHost.ReferencedGenericClass<String>>(mock: self, invocation: invocation)
  }

  public func setGenericClassVariable(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.ReferencedGenericClass<String>) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClass<String>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClass<String>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked genericClassWithConstraintsVariable

  public var `genericClassWithConstraintsVariable`: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGenericClassWithConstraintsVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>>(mock: self, invocation: invocation)
  }

  public func setGenericClassWithConstraintsVariable(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericClassWithConstraintsVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<[String]>) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericClassMethod`<Z>()

  public func `genericClassMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClass<Z> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClass<Z>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.ReferencedGenericClass<Z> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClass<Z> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClass<Z> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.ReferencedGenericClass<Z>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericClassMethod`<Z>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<Z>, MockingbirdTestsHost.ReferencedGenericClass<Z>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClass<Z>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClass<Z>, MockingbirdTestsHost.ReferencedGenericClass<Z>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type)

  public func `genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type) -> Z.Type {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type) -> Z.Type", arguments: [Mockingbird.ArgumentMatcher(`metatype`)])
    return mockingContext.didInvoke(invocation) { () -> Z.Type in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Z.Type) -> Z.Type {
        return concreteImplementation(`metatype`)
      } else if let concreteImplementation = implementation as? () -> Z.Type {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Z.Type).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: @escaping @autoclosure () -> Z.Type) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metatype`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClass<T>>(`metatype`: Z.Type) -> Z.Type", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericClassWithConstraintsMethod`<Z>()

  public func `genericClassWithConstraintsMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z> in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z> {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z> {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericClassWithConstraintsMethod`<Z>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<Z>() -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>, MockingbirdTestsHost.ReferencedGenericClassWithConstraints<Z>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type)

  public func `genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type) -> Z.Type {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type) -> Z.Type", arguments: [Mockingbird.ArgumentMatcher(`metatype`)])
    return mockingContext.didInvoke(invocation) { () -> Z.Type in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Z.Type) -> Z.Type {
        return concreteImplementation(`metatype`)
      } else if let concreteImplementation = implementation as? () -> Z.Type {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Z.Type).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: @escaping @autoclosure () -> Z.Type) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metatype`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericClassWithConstraintsMethod`<T, Z: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<T>>(`metatype`: Z.Type) -> Z.Type", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Z.Type) -> Z.Type, Z.Type>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.GenericClassReferencer`.
public func mock(_ type: MockingbirdTestsHost.GenericClassReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> GenericClassReferencerMock {
  return GenericClassReferencerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.GrandparentProtocol`.
public func mock(_ type: MockingbirdTestsHost.GrandparentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> GrandparentProtocolMock {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.Grandparent`.
public func mock(_ type: MockingbirdTestsHost.Grandparent.Type, file: StaticString = #file, line: UInt = #line) -> GrandparentMock {
  return GrandparentMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HashableConformingClass

public final class HashableConformingClassMock: MockingbirdTestsHost.HashableConformingClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HashableConformingClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public override func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (inout Hasher) -> Void {
        concreteImplementation(&`hasher`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.HashableConformingClass`.
public func mock(_ type: MockingbirdTestsHost.HashableConformingClass.Type, file: StaticString = #file, line: UInt = #line) -> HashableConformingClassMock {
  return HashableConformingClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked HashableConformingProtocol

public final class HashableConformingProtocolMock: MockingbirdTestsHost.HashableConformingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      HashableConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked hashValue

  public var `hashValue`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Int in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Int {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getHashValue() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock)

  public static func ==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (HashableConformingProtocolMock, HashableConformingProtocolMock) -> Bool {
        return concreteImplementation(`lhs`, `rhs`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> HashableConformingProtocolMock, _ `rhs`: @escaping @autoclosure () -> HashableConformingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableConformingProtocolMock, HashableConformingProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: HashableConformingProtocolMock, _ `rhs`: HashableConformingProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableConformingProtocolMock, HashableConformingProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (inout Hasher) -> Void {
        concreteImplementation(&`hasher`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.HashableConformingProtocol`.
public func mock(_ type: HashableConformingProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> HashableConformingProtocolMock {
  return HashableConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ImplementingExternalModuleScopedTypealiasedProtocol

public final class ImplementingExternalModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImplementingExternalModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?)

  public override func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T?) -> T? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T)

  public override func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject?)

  public override func `request`(`object`: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject)

  public override func `request`(`object`: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject?)

  public override func `request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.NSObject? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.NSObject? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.NSObject?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject)

  public override func `request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ImplementingExternalModuleScopedTypealiasedProtocol.Type, file: StaticString = #file, line: UInt = #line) -> ImplementingExternalModuleScopedTypealiasedProtocolMock {
  return ImplementingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ImplementingExternalModuleScoping

public final class ImplementingExternalModuleScopingMock: MockingbirdTestsHost.ImplementingExternalModuleScoping, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImplementingExternalModuleScopingMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> ImplementingExternalModuleScopingMock {
      let mock: ImplementingExternalModuleScopingMock = ImplementingExternalModuleScopingMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked secondLevelType

  override public var `secondLevelType`: MockingbirdModuleTestsHost.TopLevelType.SecondLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSecondLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType>(mock: self, invocation: invocation)
  }

  public func setSecondLevelType(_ newValue: @escaping @autoclosure () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked thirdLevelType

  override public var `thirdLevelType`: MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getThirdLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
  }

  public func setThirdLevelType(_ newValue: @escaping @autoclosure () -> MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked topLevelType

  override public var `topLevelType`: MockingbirdModuleTestsHost.TopLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.TopLevelType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.TopLevelType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.TopLevelType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.TopLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTopLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType, MockingbirdModuleTestsHost.TopLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdModuleTestsHost.TopLevelType, MockingbirdModuleTestsHost.TopLevelType>(mock: self, invocation: invocation)
  }

  public func setTopLevelType(_ newValue: @escaping @autoclosure () -> MockingbirdModuleTestsHost.TopLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdModuleTestsHost.TopLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ImplementingExternalModuleScoping`.
public func mock(_ type: MockingbirdTestsHost.ImplementingExternalModuleScoping.Type, file: StaticString = #file, line: UInt = #line) -> ImplementingExternalModuleScopingMock.InitializerProxy.Type {
  return ImplementingExternalModuleScopingMock.InitializerProxy.self
}

// MARK: - Mocked ImplicitlyImportedExternalObjectiveCType

public final class ImplicitlyImportedExternalObjectiveCTypeMock: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ImplicitlyImportedExternalObjectiveCTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType`.
public func mock(_ type: MockingbirdTestsHost.ImplicitlyImportedExternalObjectiveCType.Protocol, file: StaticString = #file, line: UInt = #line) -> ImplicitlyImportedExternalObjectiveCTypeMock {
  return ImplicitlyImportedExternalObjectiveCTypeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritedTypeQualificationProtocolGenericImplementer

public final class InheritedTypeQualificationProtocolGenericImplementerMock<T>: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolGenericImplementerMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType)

  public override func `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.UnscopedType? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.UnscopedType? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.UnscopedType?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `lessQualifiedImplementation`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType)

  public override func `moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType? {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `moreQualifiedImplementation`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?, MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType) -> MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?, MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>.ScopedType?>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>`.
public func mock<T>(_ type: InheritedTypeQualificationProtocolGenericImplementerMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> InheritedTypeQualificationProtocolGenericImplementerMock<T> {
  return InheritedTypeQualificationProtocolGenericImplementerMock<T>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritedTypeQualificationProtocol

public final class InheritedTypeQualificationProtocolMock<ScopedType>: MockingbirdTestsHost.InheritedTypeQualificationProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(ScopedType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolMock<ScopedType>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType)

  public func `lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.UnscopedType? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.UnscopedType? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.UnscopedType?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `lessQualifiedImplementation`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`lessQualifiedImplementation`(`param`: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation`(`param`: ScopedType)

  public func `moreQualifiedImplementation`(`param`: ScopedType) -> ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: ScopedType) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> ScopedType? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> ScopedType? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ScopedType?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `moreQualifiedImplementation`(`param`: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`moreQualifiedImplementation`(`param`: ScopedType) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritedTypeQualificationProtocol`.
public func mock<ScopedType>(_ type: InheritedTypeQualificationProtocolMock<ScopedType>.Type, file: StaticString = #file, line: UInt = #line) -> InheritedTypeQualificationProtocolMock<ScopedType> {
  return InheritedTypeQualificationProtocolMock<ScopedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritingAssociatedTypeSelfReferencingProtocol

public final class InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(SequenceType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingAssociatedTypeSelfReferencingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == InheritingAssociatedTypeSelfReferencingProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SequenceType) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock)

  public func `request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void {
        concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> InheritingAssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (InheritingAssociatedTypeSelfReferencingProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingAssociatedTypeSelfReferencingProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable>(_ type: InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType> {
  return InheritingAssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritingExternalModuleScopedAssociatedTypeProtocol

public final class InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol, Mockingbird.Mock where Data.Element == MockingbirdModuleTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(Data.self).debugDescription, ObjectIdentifier(Element.self).debugDescription, ObjectIdentifier(Subelement.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingExternalModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdModuleTestsHost.ExternalModuleScopedAssociatedTypeProtocol>(_ type: InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return InheritingExternalModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritingExternalModuleScopedTypealiasedProtocol

public final class InheritingExternalModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingExternalModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?)

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T?) -> T? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T)

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdModuleTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject?)

  public func `request`(`object`: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject)

  public func `request`(`object`: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject?)

  public func `request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.NSObject? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.NSObject? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.NSObject?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject?) -> MockingbirdModuleTestsHost.NSObject?, MockingbirdModuleTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdModuleTestsHost.NSObject)

  public func `request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdModuleTestsHost.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdModuleTestsHost.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdModuleTestsHost.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdModuleTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdModuleTestsHost.NSObject) -> MockingbirdModuleTestsHost.NSObject, MockingbirdModuleTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.InheritingExternalModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InheritingExternalModuleScopedTypealiasedProtocolMock {
  return InheritingExternalModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritingModuleScopedAssociatedTypeProtocol

public final class InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol, Mockingbird.Mock where Data.Element == MockingbirdTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(Data.self).debugDescription, ObjectIdentifier(Element.self).debugDescription, ObjectIdentifier(Subelement.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritingModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritingModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>(_ type: InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return InheritingModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritsExtendableProtocol

public final class InheritsExtendableProtocolMock: MockingbirdTestsHost.InheritsExtendableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritsExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherExtendedVariable

  public var `anotherExtendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked baseVariable

  public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked childVariable

  public var `childVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getChildVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedVariable

  public var `extendedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `anotherTrivialExtendedMethod`()

  public func `anotherTrivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `anotherTrivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`anotherTrivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedExtendedMethod`(`param1`: Bool)

  public func `parameterizedExtendedMethod`(`param1`: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(`param1`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parameterizedExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedExtendedMethod`(`param1`: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningExtendedMethod`(`param1`: Bool)

  public func `parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Bool {
        return concreteImplementation(`param1`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parameterizedReturningExtendedMethod`(`param1`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedReturningExtendedMethod`(`param1`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialBaseMethod`()

  public func `trivialBaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `trivialBaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialChildMethod`()

  public func `trivialChildMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialChildMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `trivialChildMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialChildMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialExtendedMethod`()

  public func `trivialExtendedMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `trivialExtendedMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialExtendedMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InheritsExtendableProtocol`.
public func mock(_ type: MockingbirdTestsHost.InheritsExtendableProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InheritsExtendableProtocolMock {
  return InheritsExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InitializableClassOnlyProtocolWithInheritedInitializer

public final class InitializableClassOnlyProtocolWithInheritedInitializerMock: MockingbirdTestsHost.ClassWithDesignatedInitializer, MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializableClassOnlyProtocolWithInheritedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    @available(*, deprecated, message: "This class initializer is deprecated")
    public static func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock {
      let mock: InitializableClassOnlyProtocolWithInheritedInitializerMock = InitializableClassOnlyProtocolWithInheritedInitializerMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param1`: Bool)

  @available(*, deprecated, message: "This class initializer is deprecated")
  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  @available(*, deprecated, message: "Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  public required init(`param1`: Bool, `param2`: Int) {
    fatalError("Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int, `param3`: String)

  @available(*, deprecated, message: "Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  public required init(`param1`: Bool, `param2`: Int, `param3`: String) {
    fatalError("Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  }

  // MARK: Mocked init(`param2`: Bool, `param3`: Int)

  @available(*, deprecated, message: "This protocol initializer is deprecated")
  @available(*, deprecated, message: "Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  public required init(`param2`: Bool, `param3`: Int) {
    fatalError("Please use 'mock(InitializableClassOnlyProtocolWithInheritedInitializer.self).initialize(...)' to initialize a concrete mock instance")
  }

  // MARK: Mocked init(`param`: Bool)

  public required init(`param`: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: Int)

  public required override init(`param`: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer`.
public func mock(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocolWithInheritedInitializer.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy.Type {
  return InitializableClassOnlyProtocolWithInheritedInitializerMock.InitializerProxy.self
}

// MARK: - Mocked InitializableClassOnlyProtocol

public final class InitializableClassOnlyProtocolMock: MockingbirdTestsHost.ClassWithoutDesignatedInitializer, MockingbirdTestsHost.InitializableClassOnlyProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializableClassOnlyProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializableClassOnlyProtocolMock {
      let mock: InitializableClassOnlyProtocolMock = InitializableClassOnlyProtocolMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required init(`param1`: Bool, `param2`: Int) {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializableClassOnlyProtocol`.
public func mock(_ type: MockingbirdTestsHost.InitializableClassOnlyProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializableClassOnlyProtocolMock.InitializerProxy.Type {
  return InitializableClassOnlyProtocolMock.InitializerProxy.self
}

// MARK: - Mocked InitializerClass

public final class InitializerClassMock: MockingbirdTestsHost.InitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize<T>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize<T>(`param1`: T, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock where T: MockingbirdTestsHost.AssociatedTypeProtocol {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param1`: Bool, _ `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`, `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize<T>(`param2`: T, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassMock where T: MockingbirdTestsHost.AssociatedTypeProtocol {
      let mock: InitializerClassMock = try InitializerClassMock(param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock? {
      let mock: InitializerClassMock? = InitializerClassMock(param: `param`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: String, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassMock {
      let mock: InitializerClassMock = try InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!<T>(`param1`: T)

  public required override init!<T>(`param1`: T) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!<T>(`param1`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param1`: T)

  public required override init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, _ `param2`: Int)

  public required override init(`param1`: Bool, _ `param2`: Int) {
    super.init(param1: `param1`, `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, _ `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param2`: T)

  public required override init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    try super.init(param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  #if swift(>=5.2)

  // MARK: Mocked init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T)

  public required override init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  #endif

  #if swift(>=5.2)

  // MARK: Mocked init?<T>(`param`: T)

  public required override init?<T>(`param`: T) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?<T>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  #endif

  // MARK: Mocked init?(`param`: Bool)

  public required override init?(`param`: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!(`param`: Int)

  public required override init!(`param`: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String?)

  public required init(`param`: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String?) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String)

  public required override init(`param`: String) throws {
    try super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) throws ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerClass`.
public func mock(_ type: MockingbirdTestsHost.InitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> InitializerClassMock.InitializerProxy.Type {
  return InitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked InitializerOverridingProtocol

public final class InitializerOverridingProtocolMock: MockingbirdTestsHost.InitializerOverridingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerOverridingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init()

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param123`: Bool)

  public required init(`param123`: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param123`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param123`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!<T>(`param1`: T)

  public required init!<T>(`param1`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!<T>(`param1`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param1`: T)

  public required init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, _ `param2`: Int)

  public required init(`param1`: Bool, _ `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, _ `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param2`: T)

  public required init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T)

  public required init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?<T>(`param`: T)

  public required init?<T>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?<T>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?(`param`: Bool)

  public required init?(`param`: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!(`param`: Int)

  public required init!(`param`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String)

  public required init(`param`: String) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) throws ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerOverridingProtocol`.
public func mock(_ type: MockingbirdTestsHost.InitializerOverridingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializerOverridingProtocolMock {
  return InitializerOverridingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InitializerOverridingSubclass

public final class InitializerOverridingSubclassMock: MockingbirdTestsHost.InitializerOverridingSubclass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerOverridingSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerOverridingSubclassMock {
      let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerOverridingSubclassMock {
      let mock: InitializerOverridingSubclassMock = InitializerOverridingSubclassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String?)

  public required init(`param`: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String?) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerOverridingSubclass`.
public func mock(_ type: MockingbirdTestsHost.InitializerOverridingSubclass.Type, file: StaticString = #file, line: UInt = #line) -> InitializerOverridingSubclassMock.InitializerProxy.Type {
  return InitializerOverridingSubclassMock.InitializerProxy.self
}

// MARK: - Mocked InitializerProtocol

public final class InitializerProtocolMock: MockingbirdTestsHost.InitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init()

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!<T>(`param1`: T)

  public required init!<T>(`param1`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!<T>(`param1`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param1`: T)

  public required init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param1`: T) where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param1`: Bool, _ `param2`: Int)

  public required init(`param1`: Bool, _ `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, _ `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T>(`param2`: T)

  public required init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T>(`param2`: T) throws where T: MockingbirdTestsHost.AssociatedTypeProtocol ", arguments: [Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T)

  public required init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init<T: MockingbirdTestsHost.AssociatedTypeProtocol>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?<T>(`param`: T)

  public required init?<T>(`param`: T) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?<T>(`param`: T) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init?(`param`: Bool)

  public required init?(`param`: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init!(`param`: Int)

  public required init!(`param`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init!(`param`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String)

  public required init(`param`: String) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String) throws ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.InitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InitializerProtocolMock {
  return InitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InitializerSubclass

public final class InitializerSubclassMock: MockingbirdTestsHost.InitializerSubclass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param99`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerSubclassMock {
      let mock: InitializerSubclassMock = InitializerSubclassMock(param99: `param99`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`param`: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerSubclassMock {
      let mock: InitializerSubclassMock = InitializerSubclassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param99`: Bool)

  public required override init(`param99`: Bool) {
    super.init(param99: `param99`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param99`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param99`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`param`: String?)

  public required init(`param`: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: String?) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.InitializerSubclass`.
public func mock(_ type: MockingbirdTestsHost.InitializerSubclass.Type, file: StaticString = #file, line: UInt = #line) -> InitializerSubclassMock.InitializerProxy.Type {
  return InitializerSubclassMock.InitializerProxy.self
}

// MARK: - Mocked InoutClass

public final class InoutClassMock: MockingbirdTestsHost.InoutClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `parameterizedMethod`(`object`: inout String)

  public override func `parameterizedMethod`(`object`: inout String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (inout String) -> Void {
        concreteImplementation(&`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parameterizedMethod`(`object`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.InoutClass`.
public func mock(_ type: MockingbirdTestsHost.InoutClass.Type, file: StaticString = #file, line: UInt = #line) -> InoutClassMock {
  return InoutClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InoutProtocol

public final class InoutProtocolMock: MockingbirdTestsHost.InoutProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `parameterizedMethod`(`object`: inout String)

  public func `parameterizedMethod`(`object`: inout String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (inout String) -> Void {
        concreteImplementation(&`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parameterizedMethod`(`object`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parameterizedMethod`(`object`: inout String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.InoutProtocol`.
public func mock(_ type: MockingbirdTestsHost.InoutProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> InoutProtocolMock {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked KeywordArgNamesClass

public final class KeywordArgNamesClassMock: MockingbirdTestsHost.KeywordArgNamesClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      KeywordArgNamesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithKeywordParam`(`inout`: String)

  public override func `methodWithKeywordParam`(`inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`inout`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithKeywordParam`(`inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithNamedKeywordParam`(`with` `inout`: String)

  public override func `methodWithNamedKeywordParam`(`with` `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`inout`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithNamedKeywordParam`(`with` `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParamNamedKeyword`(`inout` `param`: String)

  public override func `methodWithParamNamedKeyword`(`inout` `param`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithParamNamedKeyword`(`inout` `param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnnamedKeywordParam`(_ `inout`: String)

  public override func `methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`inout`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithUnnamedKeywordParam`(_ `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.KeywordArgNamesClass`.
public func mock(_ type: MockingbirdTestsHost.KeywordArgNamesClass.Type, file: StaticString = #file, line: UInt = #line) -> KeywordArgNamesClassMock {
  return KeywordArgNamesClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked KeywordArgNamesProtocol

public final class KeywordArgNamesProtocolMock: MockingbirdTestsHost.KeywordArgNamesProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      KeywordArgNamesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithKeywordParam`(`inout`: String)

  public func `methodWithKeywordParam`(`inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`inout`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithKeywordParam`(`inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithKeywordParam`(`inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithNamedKeywordParam`(`with` `inout`: String)

  public func `methodWithNamedKeywordParam`(`with` `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`inout`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithNamedKeywordParam`(`with` `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithNamedKeywordParam`(`with` `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParamNamedKeyword`(`inout` `param`: String)

  public func `methodWithParamNamedKeyword`(`inout` `param`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithParamNamedKeyword`(`inout` `param`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParamNamedKeyword`(`inout` `param`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnnamedKeywordParam`(_ `inout`: String)

  public func `methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`inout`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Void {
        concreteImplementation(`inout`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithUnnamedKeywordParam`(_ `inout`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`inout`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnnamedKeywordParam`(_ `inout`: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.KeywordArgNamesProtocol`.
public func mock(_ type: MockingbirdTestsHost.KeywordArgNamesProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> KeywordArgNamesProtocolMock {
  return KeywordArgNamesProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked LineCommentNotDebugCompilationDirectiveProtocol

public final class LineCommentNotDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LineCommentNotDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.LineCommentNotDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> LineCommentNotDebugCompilationDirectiveProtocolMock {
  return LineCommentNotDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked LocalPublicExternalProtocol

public final class LocalPublicExternalProtocolMock: MockingbirdTestsHost.LocalPublicExternalProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LocalPublicExternalProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`()

  public func `method`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.LocalPublicExternalProtocol`.
public func mock(_ type: MockingbirdTestsHost.LocalPublicExternalProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> LocalPublicExternalProtocolMock {
  return LocalPublicExternalProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ModuleScopedAssociatedTypeProtocol

public final class ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, Mockingbird.Mock where Data.Element == MockingbirdTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(Data.self).debugDescription, ObjectIdentifier(Element.self).debugDescription, ObjectIdentifier(Subelement.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol`.
public func mock<Element, Subelement, Data: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol>(_ type: ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>.Type, file: StaticString = #file, line: UInt = #line) -> ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ModuleScopedTypealiasedProtocol

public final class ModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?)

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T?) -> T? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T)

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericRequest`<T: MockingbirdTestsHost.NSObjectProtocol>(`object`: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject?)

  public func `request`(`object`: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject?) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: Foundation.NSObject)

  public func `request`(`object`: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: Foundation.NSObject) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdTestsHost.NSObject?)

  public func `request`(`object`: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.NSObject? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.NSObject? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.NSObject?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: MockingbirdTestsHost.NSObject)

  public func `request`(`object`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
        return concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ModuleScopedTypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ModuleScopedTypealiasedProtocolMock {
  return ModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NSObjectProtocolConformingProtocol

public final class NSObjectProtocolConformingProtocolMock: Foundation.NSObject, MockingbirdTestsHost.NSObjectProtocolConformingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NSObjectProtocolConformingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NSObjectProtocolConformingProtocol`.
public func mock(_ type: MockingbirdTestsHost.NSObjectProtocolConformingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NSObjectProtocolConformingProtocolMock {
  return NSObjectProtocolConformingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NSViewInheritingProtocol

public final class NSViewInheritingProtocolMock: AppKit.NSView, MockingbirdTestsHost.NSViewInheritingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NSViewInheritingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> NSViewInheritingProtocolMock? {
      let mock: NSViewInheritingProtocolMock? = NSViewInheritingProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`frame` `frameRect`: NSRect, __file: StaticString = #file, __line: UInt = #line) -> NSViewInheritingProtocolMock {
      let mock: NSViewInheritingProtocolMock = NSViewInheritingProtocolMock(frame: `frameRect`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`frame` `frameRect`: NSRect)

  public required override init(`frame` `frameRect`: NSRect) {
    super.init(frame: `frameRect`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`frame` `frameRect`: NSRect) ", arguments: [Mockingbird.ArgumentMatcher(`frameRect`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.NSViewInheritingProtocol`.
public func mock(_ type: MockingbirdTestsHost.NSViewInheritingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NSViewInheritingProtocolMock.InitializerProxy.Type {
  return NSViewInheritingProtocolMock.InitializerProxy.self
}

// MARK: - Mocked NestedDebugCompilationDirectiveProtocol

#if DEBUG
#if !(!(DEBUG))

public final class NestedDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.NestedDebugCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NestedDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG
  #if !(!(DEBUG))

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif
#endif

#if DEBUG
#if !(!(DEBUG))

/// Initialize a protocol mock of `MockingbirdTestsHost.NestedDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.NestedDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NestedDebugCompilationDirectiveProtocolMock {
  return NestedDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif
#endif

// MARK: - Mocked NestedDefaultCompilationDirectiveProtocol

#if DEBUG
#if !(!(!(DEBUG))) && !(RELEASE)

public final class NestedDefaultCompilationDirectiveProtocolMock: MockingbirdTestsHost.NestedDefaultCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NestedDefaultCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG
  #if !(!(!(DEBUG))) && !(RELEASE)

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif
#endif

#if DEBUG
#if !(!(!(DEBUG))) && !(RELEASE)

/// Initialize a protocol mock of `MockingbirdTestsHost.NestedDefaultCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.NestedDefaultCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NestedDefaultCompilationDirectiveProtocolMock {
  return NestedDefaultCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif
#endif

// MARK: - Mocked NestedReleaseCompilationDirectiveProtocol

#if DEBUG
#if !(!(!(DEBUG))) && RELEASE

public final class NestedReleaseCompilationDirectiveProtocolMock: MockingbirdTestsHost.NestedReleaseCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NestedReleaseCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if DEBUG
  #if !(!(!(DEBUG))) && RELEASE

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif
  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif
#endif

#if DEBUG
#if !(!(!(DEBUG))) && RELEASE

/// Initialize a protocol mock of `MockingbirdTestsHost.NestedReleaseCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.NestedReleaseCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NestedReleaseCompilationDirectiveProtocolMock {
  return NestedReleaseCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif
#endif

// MARK: - Mocked NoInitializerClass

public final class NoInitializerClassMock: MockingbirdTestsHost.NoInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NoInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.NoInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.NoInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> NoInitializerClassMock {
  return NoInitializerClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NoInitializerProtocol

public final class NoInitializerProtocolMock: MockingbirdTestsHost.NoInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NoInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.NoInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.NoInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> NoInitializerProtocolMock {
  return NoInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NonExtendableClass

public final class NonExtendableClassMock: MockingbirdTestsHost.NonExtendableClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `trivialBaseMethod`()

  public override func `trivialBaseMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `trivialBaseMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`trivialBaseMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.NonExtendableClass`.
public func mock(_ type: MockingbirdTestsHost.NonExtendableClass.Type, file: StaticString = #file, line: UInt = #line) -> NonExtendableClassMock {
  return NonExtendableClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ObjectiveCClass

public final class ObjectiveCClassMock: MockingbirdTestsHost.ObjectiveCClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ObjectiveCClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> ObjectiveCClassMock {
      let mock: ObjectiveCClassMock = ObjectiveCClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked nominalObjcVariable

  override public var `nominalObjcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getNominalObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setNominalObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcComputedVariable

  override public var `objcComputedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcComputedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getObjcComputedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcComputedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcVariable

  override public var `objcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `method`()

  public override func `method`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nominalObjcMethod`()

  public override func `nominalObjcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `nominalObjcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `objcMethod`()

  public override func `objcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `objcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ObjectiveCClass`.
public func mock(_ type: MockingbirdTestsHost.ObjectiveCClass.Type, file: StaticString = #file, line: UInt = #line) -> ObjectiveCClassMock.InitializerProxy.Type {
  return ObjectiveCClassMock.InitializerProxy.self
}

// MARK: - Mocked ObjectiveCProtocolImplementer

public final class ObjectiveCProtocolImplementerMock: MockingbirdTestsHost.ObjectiveCProtocolImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ObjectiveCProtocolImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked nominalObjcVariable

  override public var `nominalObjcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getNominalObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setNominalObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcVariable

  override public var `objcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setObjcVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  override public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`()

  public override func `method`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nominalObjcMethod`()

  public override func `nominalObjcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `nominalObjcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `objcMethod`()

  public override func `objcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `objcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ObjectiveCProtocolImplementer`.
public func mock(_ type: MockingbirdTestsHost.ObjectiveCProtocolImplementer.Type, file: StaticString = #file, line: UInt = #line) -> ObjectiveCProtocolImplementerMock {
  return ObjectiveCProtocolImplementerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ObjectiveCProtocol

public final class ObjectiveCProtocolMock: MockingbirdTestsHost.ObjectiveCProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ObjectiveCProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked nominalObjcVariable

  public var `nominalObjcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getNominalObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "nominalObjcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked objcVariable

  public var `objcVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getObjcVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "objcVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`()

  public func `method`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `nominalObjcMethod`()

  public func `nominalObjcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `nominalObjcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`nominalObjcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `objcMethod`()

  public func `objcMethod`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `objcMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`objcMethod`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ObjectiveCProtocol`.
public func mock(_ type: MockingbirdTestsHost.ObjectiveCProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ObjectiveCProtocolMock {
  return ObjectiveCProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OnlyDebugCompilationDirectiveProtocol

#if DEBUG

public final class OnlyDebugCompilationDirectiveProtocolMock: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OnlyDebugCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if !(!(DEBUG))

  // MARK: Mocked extensionVariable

  public var `extensionVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extensionVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getExtensionVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extensionVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  #if DEBUG

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if DEBUG

/// Initialize a protocol mock of `MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.OnlyDebugCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OnlyDebugCompilationDirectiveProtocolMock {
  return OnlyDebugCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif

// MARK: - Mocked OpaqueClassSelfConstrainedAssociatedTypeProtocol

public final class OpaqueClassSelfConstrainedAssociatedTypeProtocolMock: AppKit.NSViewController, MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolMock? {
      let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock? = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolMock {
      let mock: OpaqueClassSelfConstrainedAssociatedTypeProtocolMock = OpaqueClassSelfConstrainedAssociatedTypeProtocolMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol`.
public func mock(_ type: MockingbirdTestsHost.OpaqueClassSelfConstrainedAssociatedTypeProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy.Type {
  return OpaqueClassSelfConstrainedAssociatedTypeProtocolMock.InitializerProxy.self
}

// MARK: - Mocked OpaqueProtocolSelfConstrainedAssociatedTypeProtocol

public final class OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock: MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol, Swift.Hashable, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked hashValue

  public var `hashValue`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Int in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Int {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getHashValue() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hashValue.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked ==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock)

  public static func ==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`lhs`), Mockingbird.ArgumentMatcher(`rhs`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool {
        return concreteImplementation(`lhs`, `rhs`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func _equalTo(_ `lhs`: @escaping @autoclosure () -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: @escaping @autoclosure () -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`lhs`), Mockingbird.resolve(`rhs`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "==(_ `lhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, _ `rhs`: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock, OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `hash`(`into` `hasher`: inout Hasher)

  public func `hash`(`into` `hasher`: inout Hasher) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasher`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (inout Hasher) -> Void {
        concreteImplementation(&`hasher`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `hash`(`into` `hasher`: @escaping @autoclosure () -> Hasher) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasher`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hash`(`into` `hasher`: inout Hasher) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout Hasher) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OpaqueProtocolSelfConstrainedAssociatedTypeProtocol`.
public func mock(_ type: OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock.Type, file: StaticString = #file, line: UInt = #line) -> OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock {
  return OpaqueProtocolSelfConstrainedAssociatedTypeProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OpaqueViewController

public final class OpaqueViewControllerMock: MockingbirdTestsHost.OpaqueViewController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OpaqueViewControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`coder`: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> OpaqueViewControllerMock? {
      let mock: OpaqueViewControllerMock? = OpaqueViewControllerMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?, __file: StaticString = #file, __line: UInt = #line) -> OpaqueViewControllerMock {
      let mock: OpaqueViewControllerMock = OpaqueViewControllerMock(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init?(`coder`: NSCoder)

  public required init?(`coder`: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(`coder`: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?)

  public required override init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) {
    super.init(nibName: `nibNameOrNil`, bundle: `nibBundleOrNil`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`nibName` `nibNameOrNil`: NSNib.Name?, `bundle` `nibBundleOrNil`: Bundle?) ", arguments: [Mockingbird.ArgumentMatcher(`nibNameOrNil`), Mockingbird.ArgumentMatcher(`nibBundleOrNil`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.OpaqueViewController`.
public func mock(_ type: MockingbirdTestsHost.OpaqueViewController.Type, file: StaticString = #file, line: UInt = #line) -> OpaqueViewControllerMock.InitializerProxy.Type {
  return OpaqueViewControllerMock.InitializerProxy.self
}

// MARK: - Mocked OptionalsProtocol

public final class OptionalsProtocolMock: MockingbirdTestsHost.OptionalsProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OptionalsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked multiUnwrappedOptionalVariable

  public var `multiUnwrappedOptionalVariable`: Bool???! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multiUnwrappedOptionalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool??? in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool??? {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool???).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getMultiUnwrappedOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multiUnwrappedOptionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: Bool? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool? in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool? {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool?).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool?, Bool?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool?, Bool?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked unwrappedOptionalVariable

  public var `unwrappedOptionalVariable`: Bool! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "unwrappedOptionalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getUnwrappedOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "unwrappedOptionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithMultiOptionalParameter`(`param`: Bool???)

  public func `methodWithMultiOptionalParameter`(`param`: Bool???) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalParameter`(`param`: Bool???) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool???) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithMultiOptionalParameter`(`param`: @escaping @autoclosure () -> Bool???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalParameter`(`param`: Bool???) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiOptionalReturn`()

  public func `methodWithMultiOptionalReturn`() -> Bool??? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalReturn`() -> Bool???", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool??? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool??? {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool??? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool???).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithMultiOptionalReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalReturn`() -> Bool???", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiOptionalVariadicParameter`(`param`: Bool???...)

  public func `methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Bool???]) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithMultiOptionalVariadicParameter`(`param`: @escaping @autoclosure () -> [Bool???]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiOptionalVariadicParameter`(`param`: Bool???...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!)

  public func `methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool?, Int)???) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: @escaping @autoclosure () -> (Bool?, Int)???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundParameter`(`param`: (Bool?, Int)???!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalCompoundReturn`()

  public func `methodWithMultiUnwrappedOptionalCompoundReturn`() -> (Bool?, Int)???! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundReturn`() -> (Bool?, Int)???!", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Bool?, Int)??? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Bool?, Int)??? {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Bool?, Int)??? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Bool?, Int)???).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithMultiUnwrappedOptionalCompoundReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int)???, (Bool?, Int)???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalCompoundReturn`() -> (Bool?, Int)???!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int)???, (Bool?, Int)???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!)

  public func `methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool???) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithMultiUnwrappedOptionalParameter`(`param`: @escaping @autoclosure () -> Bool???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalParameter`(`param`: Bool???!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalReturn`()

  public func `methodWithMultiUnwrappedOptionalReturn`() -> Bool???! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalReturn`() -> Bool???!", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool??? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool??? {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool??? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool???).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithMultiUnwrappedOptionalReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithMultiUnwrappedOptionalReturn`() -> Bool???!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalParameter`(`param`: Bool?)

  public func `methodWithOptionalParameter`(`param`: Bool?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalParameter`(`param`: Bool?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool?) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithOptionalParameter`(`param`: @escaping @autoclosure () -> Bool?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalParameter`(`param`: Bool?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalReturn`()

  public func `methodWithOptionalReturn`() -> Bool? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalReturn`() -> Bool?", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool? in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool? {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool? {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool?).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithOptionalReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool?, Bool?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalReturn`() -> Bool?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool?, Bool?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalVariadicParameter`(`param`: Bool?...)

  public func `methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Bool?]) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithOptionalVariadicParameter`(`param`: @escaping @autoclosure () -> [Bool?]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithOptionalVariadicParameter`(`param`: Bool?...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!)

  public func `methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool?, Int)) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithUnwrappedCompoundParameter`(`param`: @escaping @autoclosure () -> (Bool?, Int)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundParameter`(`param`: (Bool?, Int)!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedCompoundReturn`()

  public func `methodWithUnwrappedCompoundReturn`() -> (Bool?, Int)! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundReturn`() -> (Bool?, Int)!", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Bool?, Int) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Bool?, Int) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Bool?, Int) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Bool?, Int)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithUnwrappedCompoundReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int), (Bool?, Int)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedCompoundReturn`() -> (Bool?, Int)!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int), (Bool?, Int)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedParameter`(`param`: Bool!)

  public func `methodWithUnwrappedParameter`(`param`: Bool!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedParameter`(`param`: Bool!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `methodWithUnwrappedParameter`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedParameter`(`param`: Bool!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedReturn`()

  public func `methodWithUnwrappedReturn`() -> Bool! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedReturn`() -> Bool!", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithUnwrappedReturn`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithUnwrappedReturn`() -> Bool!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OptionalsProtocol`.
public func mock(_ type: MockingbirdTestsHost.OptionalsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OptionalsProtocolMock {
  return OptionalsProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OverloadedMethodsClass

public final class OverloadedMethodsClassMock: MockingbirdTestsHost.OverloadedMethodsClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `overloadedParameters`<T>(`param1`: T, `param2`: T)

  public override func `overloadedParameters`<T>(`param1`: T, `param2`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T, T) -> T {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedParameters`<T>(`param1`: @escaping @autoclosure () -> T, `param2`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Bool, `param2`: Bool)

  public override func `overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Bool, `param2`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Int, `param2`: Int)

  public override func `overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Int, `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`<T>()

  public override func `overloadedReturnType`<T>() -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedReturnType`<T>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public override func `overloadedReturnType`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public override func `overloadedReturnType`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.OverloadedMethodsClass`.
public func mock(_ type: MockingbirdTestsHost.OverloadedMethodsClass.Type, file: StaticString = #file, line: UInt = #line) -> OverloadedMethodsClassMock {
  return OverloadedMethodsClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OverloadedMethodsProtocol

public final class OverloadedMethodsProtocolMock: MockingbirdTestsHost.OverloadedMethodsProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `overloadedParameters`<T>(`param1`: T, `param2`: T)

  public func `overloadedParameters`<T>(`param1`: T, `param2`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T, T) -> T {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedParameters`<T>(`param1`: @escaping @autoclosure () -> T, `param2`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`<T>(`param1`: T, `param2`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T, T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Bool, `param2`: Bool)

  public func `overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Bool, `param2`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Bool, `param2`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters`(`param1`: Int, `param2`: Int)

  public func `overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedParameters`(`param1`: @escaping @autoclosure () -> Int, `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedParameters`(`param1`: Int, `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`<T>()

  public func `overloadedReturnType`<T>() -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedReturnType`<T>() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`<T>() -> T", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public func `overloadedReturnType`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType`()

  public func `overloadedReturnType`() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Int in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Int {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Int).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `overloadedReturnType`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`overloadedReturnType`() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverloadedMethodsProtocol`.
public func mock(_ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> OverloadedMethodsProtocolMock {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OverriddenIncludedSource

public final class OverriddenIncludedSourceMock: MockingbirdTestsHost.OverriddenIncludedSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverriddenIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.OverriddenIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.OverriddenIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> OverriddenIncludedSourceMock {
  return OverriddenIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParameterizedInitializerClass

public final class ParameterizedInitializerClassMock: MockingbirdTestsHost.ParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> ParameterizedInitializerClassMock {
      let mock: ParameterizedInitializerClassMock = ParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required override init(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.ParameterizedInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> ParameterizedInitializerClassMock.InitializerProxy.Type {
  return ParameterizedInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked ParameterizedInitializerProtocol

public final class ParameterizedInitializerProtocolMock: MockingbirdTestsHost.ParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required init(`param1`: Bool, `param2`: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParameterizedInitializerProtocol`.
public func mock(_ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ParameterizedInitializerProtocolMock {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentInstanceVariable

  public var `grandparentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterInstanceVariable

  public var `grandparentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentPrivateSetterStaticVariable

  public class var `grandparentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentStaticVariable

  public class var `grandparentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentInstanceVariable

  public var `parentInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterInstanceVariable

  public var `parentPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentPrivateSetterStaticVariable

  public class var `parentPrivateSetterStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentStaticVariable

  public class var `parentStaticVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod`()

  public static func `grandparentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int)

  public static func `parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedStaticMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedStaticMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod`()

  public static func `parentTrivialStaticMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialStaticMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialStaticMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ParentProtocol`.
public func mock(_ type: MockingbirdTestsHost.ParentProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ParentProtocolMock {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked grandparentClassVariable

  override public class var `grandparentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked grandparentComputedInstanceVariable

  override public var `grandparentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredFileprivateSetterInstanceVariable

  override public var `grandparentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredInstanceVariable

  override public var `grandparentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked grandparentStoredPrivateSetterInstanceVariable

  override public var `grandparentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentClassVariable

  override public class var `parentClassVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = staticMock.stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(staticMock.stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked parentComputedInstanceVariable

  override public var `parentComputedInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredFileprivateSetterInstanceVariable

  override public var `parentStoredFileprivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredInstanceVariable

  override public var `parentStoredInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked parentStoredPrivateSetterInstanceVariable

  override public var `parentStoredPrivateSetterInstanceVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `grandparentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `grandparentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod`()

  public override static func `grandparentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `grandparentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod`()

  public override func `grandparentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `grandparentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`grandparentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int)

  public override static func `parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return staticMock.mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = staticMock.stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(staticMock.stubbingContext.failTest(for: invocation))
      }
    }
  }

  public static func `parentParameterizedClassMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedClassMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int)

  public override func `parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `parentParameterizedInstanceMethod`(`param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentParameterizedInstanceMethod`(`param1`: Bool, _ `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod`()

  public override static func `parentTrivialClassMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = staticMock.stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public static func `parentTrivialClassMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialClassMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod`()

  public override func `parentTrivialInstanceMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `parentTrivialInstanceMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`parentTrivialInstanceMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.Parent`.
public func mock(_ type: MockingbirdTestsHost.Parent.Type, file: StaticString = #file, line: UInt = #line) -> ParentMock {
  return ParentMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ReferencedGenericClassWithConstraints

public final class ReferencedGenericClassWithConstraintsMock<S: Sequence>: MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>, Mockingbird.Mock where S.Element: Swift.Hashable {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(S.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "ReferencedGenericClassWithConstraintsMock<S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ReferencedGenericClassWithConstraintsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClassWithConstraints<S>`.
public func mock<S: Sequence>(_ type: ReferencedGenericClassWithConstraintsMock<S>.Type, file: StaticString = #file, line: UInt = #line) -> ReferencedGenericClassWithConstraintsMock<S> {
  return ReferencedGenericClassWithConstraintsMock<S>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ReferencedGenericClass

public final class ReferencedGenericClassMock<T>: MockingbirdTestsHost.ReferencedGenericClass<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "ReferencedGenericClassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ReferencedGenericClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ReferencedGenericClass<T>`.
public func mock<T>(_ type: ReferencedGenericClassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> ReferencedGenericClassMock<T> {
  return ReferencedGenericClassMock<T>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked RelativeSecondLevelFileIncludedSource

public final class RelativeSecondLevelFileIncludedSourceMock: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RelativeSecondLevelFileIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.RelativeSecondLevelFileIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> RelativeSecondLevelFileIncludedSourceMock {
  return RelativeSecondLevelFileIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ReleaseCompilationDirectiveProtocol

#if !(DEBUG) && RELEASE

public final class ReleaseCompilationDirectiveProtocolMock: MockingbirdTestsHost.ReleaseCompilationDirectiveProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ReleaseCompilationDirectiveProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  #if !(DEBUG) && RELEASE

  // MARK: Mocked variable

  public var `variable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  #endif

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

#endif

#if !(DEBUG) && RELEASE

/// Initialize a protocol mock of `MockingbirdTestsHost.ReleaseCompilationDirectiveProtocol`.
public func mock(_ type: MockingbirdTestsHost.ReleaseCompilationDirectiveProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ReleaseCompilationDirectiveProtocolMock {
  return ReleaseCompilationDirectiveProtocolMock(sourceLocation: SourceLocation(file, line))
}

#endif

// MARK: - Mocked RequiredInitializerClass

public final class RequiredInitializerClassMock: MockingbirdTestsHost.RequiredInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RequiredInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, `param2`: Int, __file: StaticString = #file, __line: UInt = #line) -> RequiredInitializerClassMock {
      let mock: RequiredInitializerClassMock = RequiredInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(`param1`: Bool, `param2`: Int)

  public required init(`param1`: Bool, `param2`: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool, `param2`: Int) ", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.RequiredInitializerClass`.
public func mock(_ type: MockingbirdTestsHost.RequiredInitializerClass.Type, file: StaticString = #file, line: UInt = #line) -> RequiredInitializerClassMock.InitializerProxy.Type {
  return RequiredInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked RethrowingProtocol

public final class RethrowingProtocolMock: MockingbirdTestsHost.RethrowingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RethrowingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `rethrowingMethod`(`block`: () throws -> Bool)

  public func `rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() throws -> Bool>())])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() throws -> Bool) -> Bool {
        return concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `rethrowingMethod`(`block`: @escaping @autoclosure () -> () throws -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `rethrowingMethod`(`block`: () throws -> Bool)

  public func `rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() throws -> Bool>())])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() throws -> Bool) -> Void {
        concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `rethrowingMethod`(`block`: @escaping @autoclosure () -> () throws -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`rethrowingMethod`(`block`: () throws -> Bool) rethrows -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.RethrowingProtocol`.
public func mock(_ type: MockingbirdTestsHost.RethrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> RethrowingProtocolMock {
  return RethrowingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SecondLevelSelfConstrainedAssociatedTypeProtocol

public final class SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol, MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(SequenceType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SecondLevelSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == SecondLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SequenceType) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock)

  public func `request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
        concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol`.
public func mock<SequenceType: Sequence & Swift.Hashable>(_ type: SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType> {
  return SecondLevelSelfConstrainedAssociatedTypeProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ServiceRepository

public final class ServiceRepositoryMock: MockingbirdTestsHost.ServiceRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ServiceRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked testManager

  public var `testManager`: MockingbirdTestsHost.TestManager {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TestManager in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TestManager {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TestManager).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getTestManager() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ServiceRepository`.
public func mock(_ type: MockingbirdTestsHost.ServiceRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> ServiceRepositoryMock {
  return ServiceRepositoryMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ShadowedGenericType

public final class ShadowedGenericTypeMock<ShadowedType>: MockingbirdTestsHost.ShadowedGenericType<ShadowedType>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(ShadowedType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "ShadowedGenericTypeMock<ShadowedType>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ShadowedGenericTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `shadowedClassScope`(`param`: ShadowedType)

  public override func `shadowedClassScope`(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> ShadowedType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> ShadowedType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

  public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> ShadowedType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> ShadowedType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }

  // MARK: - Mocked NestedShadowedGenericType

  public final class NestedShadowedGenericTypeMock: NestedShadowedGenericType, Mockingbird.Mock {
    static var staticMock: Mockingbird.StaticMock {
      let runtimeGenericTypeNames = [].joined(separator: ",")
      let staticMockIdentifier = "NestedShadowedGenericTypeMock," + runtimeGenericTypeNames
      if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
      let staticMock = Mockingbird.StaticMock()
      genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
      return staticMock
    }
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        NestedShadowedGenericTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }

    // MARK: Mocked `shadowedClassScope`(`param`: ShadowedType)

    public override func `shadowedClassScope`(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      return mockingContext.didInvoke(invocation) { () -> ShadowedType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
          return concreteImplementation(`param`)
        } else if let concreteImplementation = implementation as? () -> ShadowedType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }

    public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }

    // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

    public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      return mockingContext.didInvoke(invocation) { () -> ShadowedType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
          return concreteImplementation(`param`)
        } else if let concreteImplementation = implementation as? () -> ShadowedType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }

    public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }
  }

  // MARK: - Mocked NestedDoublyShadowedGenericType

  public final class NestedDoublyShadowedGenericTypeMock<ShadowedType>: NestedDoublyShadowedGenericType<ShadowedType>, Mockingbird.Mock {
    static var staticMock: Mockingbird.StaticMock {
      let runtimeGenericTypeNames = [ObjectIdentifier(ShadowedType.self).debugDescription].joined(separator: ",")
      let staticMockIdentifier = "NestedDoublyShadowedGenericTypeMock<ShadowedType>," + runtimeGenericTypeNames
      if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
      let staticMock = Mockingbird.StaticMock()
      genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
      return staticMock
    }
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        NestedDoublyShadowedGenericTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }

    // MARK: Mocked `shadowedClassScope`(`param`: ShadowedType)

    public override func `shadowedClassScope`(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      return mockingContext.didInvoke(invocation) { () -> ShadowedType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
          return concreteImplementation(`param`)
        } else if let concreteImplementation = implementation as? () -> ShadowedType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }

    public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }

    // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

    public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      return mockingContext.didInvoke(invocation) { () -> ShadowedType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
          return concreteImplementation(`param`)
        } else if let concreteImplementation = implementation as? () -> ShadowedType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }

    public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
    }
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.ShadowedGenericType<ShadowedType>`.
public func mock<ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeMock<ShadowedType> {
  return ShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `NestedShadowedGenericType`.
public func mock<ShadowedGenericType_ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedShadowedGenericTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `NestedDoublyShadowedGenericType<ShadowedType>`.
public func mock<ShadowedGenericType_ShadowedType, ShadowedType>(_ type: ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>.Type, file: StaticString = #file, line: UInt = #line) -> ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType> {
  return ShadowedGenericTypeMock<ShadowedGenericType_ShadowedType>.NestedDoublyShadowedGenericTypeMock<ShadowedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SpecializedGenericProtocol

public final class SpecializedGenericProtocolMock: MockingbirdTestsHost.GenericBaseClass<Bool>, MockingbirdTestsHost.SpecializedGenericProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedGenericProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: Bool)

  public override func `baseMethod`(`param`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Bool {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedGenericProtocol`.
public func mock(_ type: MockingbirdTestsHost.SpecializedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> SpecializedGenericProtocolMock {
  return SpecializedGenericProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SpecializedGenericSubclass

public final class SpecializedGenericSubclassMock: MockingbirdTestsHost.SpecializedGenericSubclass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: Bool)

  public override func `baseMethod`(`param`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Bool {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedGenericSubclass`.
public func mock(_ type: MockingbirdTestsHost.SpecializedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> SpecializedGenericSubclassMock {
  return SpecializedGenericSubclassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SpecializedShadowedGenericProtocol

public final class SpecializedShadowedGenericProtocolMock: MockingbirdTestsHost.ShadowedGenericType<MockingbirdTestsHost.NSObject>, MockingbirdTestsHost.SpecializedShadowedGenericProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedShadowedGenericProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject)

  public override func `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

  public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> ShadowedType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> ShadowedType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.SpecializedShadowedGenericProtocol`.
public func mock(_ type: MockingbirdTestsHost.SpecializedShadowedGenericProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> SpecializedShadowedGenericProtocolMock {
  return SpecializedShadowedGenericProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SpecializedShadowedGenericSubclass

public final class SpecializedShadowedGenericSubclassMock: MockingbirdTestsHost.SpecializedShadowedGenericSubclass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SpecializedShadowedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject)

  public override func `shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `shadowedClassScope`(`param`: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedClassScope`(`param`: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType)

  public override func `shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> ShadowedType in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (ShadowedType) -> ShadowedType {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> ShadowedType {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (ShadowedType).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `shadowedFunctionScope`<ShadowedType>(`param`: @escaping @autoclosure () -> ShadowedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`shadowedFunctionScope`<ShadowedType>(`param`: ShadowedType) -> ShadowedType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ShadowedType) -> ShadowedType, ShadowedType>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.SpecializedShadowedGenericSubclass`.
public func mock(_ type: MockingbirdTestsHost.SpecializedShadowedGenericSubclass.Type, file: StaticString = #file, line: UInt = #line) -> SpecializedShadowedGenericSubclassMock {
  return SpecializedShadowedGenericSubclassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SubclassingExternalClassWithDesignatedIntializer

public final class SubclassingExternalClassWithDesignatedIntializerMock: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalClassWithDesignatedIntializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalClassWithDesignatedIntializerMock {
      let mock: SubclassingExternalClassWithDesignatedIntializerMock = SubclassingExternalClassWithDesignatedIntializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`param1`: Bool)

  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer`.
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalClassWithDesignatedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy.Type {
  return SubclassingExternalClassWithDesignatedIntializerMock.InitializerProxy.self
}

// MARK: - Mocked SubclassingExternalClassWithInheritedIntializer

public final class SubclassingExternalClassWithInheritedIntializerMock: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalClassWithInheritedIntializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalClassWithInheritedIntializerMock {
      let mock: SubclassingExternalClassWithInheritedIntializerMock = SubclassingExternalClassWithInheritedIntializerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer`.
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalClassWithInheritedIntializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy.Type {
  return SubclassingExternalClassWithInheritedIntializerMock.InitializerProxy.self
}

// MARK: - Mocked SubclassingExternalSubclassWithDesignatedInitializer

public final class SubclassingExternalSubclassWithDesignatedInitializerMock: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalSubclassWithDesignatedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(`param1`: Bool, __file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalSubclassWithDesignatedInitializerMock {
      let mock: SubclassingExternalSubclassWithDesignatedInitializerMock = SubclassingExternalSubclassWithDesignatedInitializerMock(param1: `param1`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked baseOpenVariable

  override public var `baseOpenVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getBaseOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setBaseOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `baseOpenMethod`()

  public override func `baseOpenMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `baseOpenMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(`param1`: Bool)

  public required override init(`param1`: Bool) {
    super.init(param1: `param1`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param1`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer`.
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithDesignatedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy.Type {
  return SubclassingExternalSubclassWithDesignatedInitializerMock.InitializerProxy.self
}

// MARK: - Mocked SubclassingExternalSubclassWithInheritedInitializer

public final class SubclassingExternalSubclassWithInheritedInitializerMock: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalSubclassWithInheritedInitializerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalSubclassWithInheritedInitializerMock {
      let mock: SubclassingExternalSubclassWithInheritedInitializerMock = SubclassingExternalSubclassWithInheritedInitializerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked baseOpenVariable

  override public var `baseOpenVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getBaseOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setBaseOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseOpenVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked internalVariable

  override public var `internalVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getInternalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setInternalVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "internalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked openVariable

  override public var `openVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getOpenVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setOpenVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "openVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `baseOpenMethod`()

  public override func `baseOpenMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `baseOpenMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseOpenMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `internalMethod`()

  public override func `internalMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `internalMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`internalMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `openMethod`()

  public override func `openMethod`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `openMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`openMethod`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer`.
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalSubclassWithInheritedInitializer.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy.Type {
  return SubclassingExternalSubclassWithInheritedInitializerMock.InitializerProxy.self
}

// MARK: - Mocked SubclassingExternalTopLevelType

public final class SubclassingExternalTopLevelTypeMock: MockingbirdTestsHost.SubclassingExternalTopLevelType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SubclassingExternalTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> SubclassingExternalTopLevelTypeMock {
      let mock: SubclassingExternalTopLevelTypeMock = SubclassingExternalTopLevelTypeMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked secondLevelType

  override public var `secondLevelType`: SecondLevelType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> SecondLevelType in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> SecondLevelType {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (SecondLevelType).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SecondLevelType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSecondLevelType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> SecondLevelType, SecondLevelType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> SecondLevelType, SecondLevelType>(mock: self, invocation: invocation)
  }

  public func setSecondLevelType(_ newValue: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (SecondLevelType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (SecondLevelType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.SubclassingExternalTopLevelType`.
public func mock(_ type: MockingbirdTestsHost.SubclassingExternalTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> SubclassingExternalTopLevelTypeMock.InitializerProxy.Type {
  return SubclassingExternalTopLevelTypeMock.InitializerProxy.self
}

// MARK: - Mocked TestCase

public final class TestCaseMock: MockingbirdTestsHost.TestCase, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestCaseMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `run`(`description`: String)

  public func `run`(`description`: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`run`(`description`: String) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`description`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (String) -> Bool {
        return concreteImplementation(`description`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `run`(`description`: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`description`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`run`(`description`: String) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestCase`.
public func mock(_ type: MockingbirdTestsHost.TestCase.Protocol, file: StaticString = #file, line: UInt = #line) -> TestCaseMock {
  return TestCaseMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TestManager

public final class TestManagerMock: MockingbirdTestsHost.TestManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestManagerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked currentTest

  public var `currentTest`: MockingbirdTestsHost.Test {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.Test in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.Test {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.Test).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getCurrentTest() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `stopTests`()

  public func `stopTests`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopTests`() -> Bool", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `stopTests`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopTests`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TestManager`.
public func mock(_ type: MockingbirdTestsHost.TestManager.Protocol, file: StaticString = #file, line: UInt = #line) -> TestManagerMock {
  return TestManagerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Test

public final class TestMock: MockingbirdTestsHost.Test, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked testCase

  public var `testCase`: MockingbirdTestsHost.TestCase {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TestCase in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TestCase {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TestCase).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getTestCase() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `add`(`testCase`: MockingbirdTestsHost.TestCase)

  public func `add`(`testCase`: MockingbirdTestsHost.TestCase) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`testCase`: MockingbirdTestsHost.TestCase) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`testCase`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TestCase) -> Bool {
        return concreteImplementation(`testCase`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `add`(`testCase`: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TestCase) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`testCase`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`add`(`testCase`: MockingbirdTestsHost.TestCase) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TestCase) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.Test`.
public func mock(_ type: MockingbirdTestsHost.Test.Protocol, file: StaticString = #file, line: UInt = #line) -> TestMock {
  return TestMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ThrowingProtocol

public final class ThrowingProtocolMock: MockingbirdTestsHost.ThrowingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ThrowingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `throwingMethod`()

  public func `throwingMethod`() throws -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Bool", arguments: [])
    return try mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () throws -> Bool {
        return try concreteImplementation()
      } else if let concreteImplementation = implementation as? () throws -> Bool {
        return try concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `throwingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `throwingMethod`()

  public func `throwingMethod`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Void", arguments: [])
    try mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () throws -> Void {
        try concreteImplementation()
      } else if let concreteImplementation = implementation as? () throws -> Void {
        try concreteImplementation()
      }
    }
  }

  public func `throwingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `throwingMethod`(`block`: () throws -> Bool)

  public func `throwingMethod`(`block`: () throws -> Bool) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`(`block`: () throws -> Bool) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() throws -> Bool>())])
    try mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (() throws -> Bool) throws -> Void {
        try concreteImplementation(`block`)
      } else if let concreteImplementation = implementation as? () throws -> Void {
        try concreteImplementation()
      }
    }
  }

  public func `throwingMethod`(`block`: @escaping @autoclosure () -> () throws -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`throwingMethod`(`block`: () throws -> Bool) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() throws -> Bool) throws -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ThrowingProtocol`.
public func mock(_ type: MockingbirdTestsHost.ThrowingProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ThrowingProtocolMock {
  return ThrowingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TopLevelSelfConstrainedAssociatedTypeProtocol

public final class TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType: Sequence & Swift.Hashable>: MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol, MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, MockingbirdTestsHost.SecondLevelSelfConstrainedAssociatedTypeProtocol, Mockingbird.Mock where Element: Swift.Hashable {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(Element.self).debugDescription, ObjectIdentifier(SequenceType.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType: Sequence & Swift.Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelSelfConstrainedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`<T: Sequence>(`array`: T)

  public func `request`<T: Sequence>(`array`: T) -> Void where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`<T: Sequence>(`array`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`<T: Sequence>(`array`: T) -> Void where T.Element == TopLevelSelfConstrainedAssociatedTypeProtocolMock", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`array`: SequenceType)

  public func `request`(`array`: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (SequenceType) -> Void {
        concreteImplementation(`array`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`array`: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`array`: SequenceType) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock)

  public func `request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void {
        concreteImplementation(`object`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `request`(`object`: @escaping @autoclosure () -> TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`object`: TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelSelfConstrainedAssociatedTypeProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TopLevelSelfConstrainedAssociatedTypeProtocol`.
public func mock<Element, SequenceType: Sequence & Swift.Hashable>(_ type: TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType> {
  return TopLevelSelfConstrainedAssociatedTypeProtocolMock<Element, SequenceType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TopLevelType

public final class TopLevelTypeMock: MockingbirdTestsHost.TopLevelType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)

  public override func `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `topLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: - Mocked SecondLevelType

  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }

    // MARK: Mocked `secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)

    public override func `secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }

    public func `secondLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`secondLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
    }

    // MARK: - Mocked ThirdLevelInheritingTopLevelType

    public final class ThirdLevelInheritingTopLevelTypeMock: ThirdLevelInheritingTopLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType", arguments: [])
        return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TopLevelType in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType {
            return concreteImplementation()
          } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TopLevelType).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType)

      public override func `topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        return mockingContext.didInvoke(invocation) { () -> Bool in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool {
            return concreteImplementation(`param1`, `param2`)
          } else if let concreteImplementation = implementation as? () -> Bool {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `topLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`topLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType.SecondLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType.SecondLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelInheritingThirdLevelType

    public final class ThirdLevelInheritingThirdLevelTypeMock: ThirdLevelInheritingThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
            return concreteImplementation()
          } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        return mockingContext.didInvoke(invocation) { () -> Bool in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
            return concreteImplementation(`param1`, `param2`)
          } else if let concreteImplementation = implementation as? () -> Bool {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelInheritingPartiallyQualifiedThirdLevelType

    public final class ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock: ThirdLevelInheritingPartiallyQualifiedThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
            return concreteImplementation()
          } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        return mockingContext.didInvoke(invocation) { () -> Bool in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
            return concreteImplementation(`param1`, `param2`)
          } else if let concreteImplementation = implementation as? () -> Bool {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelInheritingFullyQualifiedThirdLevelType

    public final class ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock: ThirdLevelInheritingFullyQualifiedThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelInheritingMethod`()

      public override func `thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
            return concreteImplementation()
          } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelInheritingMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelInheritingMethod`() -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType>(mock: self, invocation: invocation)
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        return mockingContext.didInvoke(invocation) { () -> Bool in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
            return concreteImplementation(`param1`, `param2`)
          } else if let concreteImplementation = implementation as? () -> Bool {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }

    // MARK: - Mocked ThirdLevelType

    public final class ThirdLevelTypeMock: ThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }

      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }

      // MARK: Mocked `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType)

      public override func `thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        return mockingContext.didInvoke(invocation) { () -> Bool in
          let implementation = stubbingContext.implementation(for: invocation)
          if let concreteImplementation = implementation as? (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool {
            return concreteImplementation(`param1`, `param2`)
          } else if let concreteImplementation = implementation as? () -> Bool {
            return concreteImplementation()
          } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
            return defaultValue
          } else {
            fatalError(stubbingContext.failTest(for: invocation))
          }
        }
      }

      public func `thirdLevelMethod`(`param1`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType, `param2`: @escaping @autoclosure () -> MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`thirdLevelMethod`(`param1`: MockingbirdTestsHost.TopLevelType, `param2`: MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TopLevelType, MockingbirdTestsHost.TopLevelType.SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  }

  // MARK: - Mocked InitializableSecondLevelType

  public final class InitializableSecondLevelTypeMock: InitializableSecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        InitializableSecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }

    public enum InitializerProxy {
      public static func initialize(`param`: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializableSecondLevelTypeMock {
        let mock: InitializableSecondLevelTypeMock = InitializableSecondLevelTypeMock(param: `param`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }

    // MARK: Mocked init(`param`: Bool)

    public required override init(`param`: Bool) {
      super.init(param: `param`)
      Mockingbird.checkVersion(for: self)
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(`param`: Bool) ", arguments: [Mockingbird.ArgumentMatcher(`param`)])
      mockingContext.didInvoke(invocation)
    }
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.TopLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock {
  return TopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `SecondLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingTopLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingPartiallyQualifiedThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelInheritingFullyQualifiedThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize a class mock of `ThirdLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Initialize an initializable class mock of `InitializableSecondLevelType`.
public func mock(_ type: MockingbirdTestsHost.TopLevelType.InitializableSecondLevelType.Type, file: StaticString = #file, line: UInt = #line) -> TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.Type {
  return TopLevelTypeMock.InitializableSecondLevelTypeMock.InitializerProxy.self
}

// MARK: - Mocked TrivialIncludedSource

public final class TrivialIncludedSourceMock: MockingbirdTestsHost.TrivialIncludedSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TrivialIncludedSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TrivialIncludedSource`.
public func mock(_ type: MockingbirdTestsHost.TrivialIncludedSource.Protocol, file: StaticString = #file, line: UInt = #line) -> TrivialIncludedSourceMock {
  return TrivialIncludedSourceMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TupleTypes

public final class TupleTypesMock: MockingbirdTestsHost.TupleTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TupleTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked anotherVariable

  public var `anotherVariable`: (Foundation.URL, Foundation.NSObject) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (Foundation.URL, Foundation.NSObject) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (Foundation.URL, Foundation.NSObject) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Foundation.URL, Foundation.NSObject)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked labeledAnotherVariable

  public var `labeledAnotherVariable`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getLabeledAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked labeledVariable

  public var `labeledVariable`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getLabeledVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalAnotherVariable

  public var `optionalAnotherVariable`: (Foundation.URL?, Foundation.NSObject?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (Foundation.URL?, Foundation.NSObject?) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (Foundation.URL?, Foundation.NSObject?) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Foundation.URL?, Foundation.NSObject?)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalLabeledAnotherVariable

  public var `optionalLabeledAnotherVariable`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalLabeledAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalLabeledVariable

  public var `optionalLabeledVariable`: (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalLabeledVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked optionalVariable

  public var `optionalVariable`: (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked variable

  public var `variable`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`()

  public func `labeledMethod`() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `labeledMethod`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))

  public func `labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `labeledMethod`(`param1`: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethod`(`param1`: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), `param2`: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethodWithParameterLabels`()

  public func `labeledMethodWithParameterLabels`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethodWithParameterLabels`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `labeledMethodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`labeledMethodWithParameterLabels`() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> (Foundation.URL, Foundation.NSObject) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (Foundation.URL, Foundation.NSObject) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (Foundation.URL, Foundation.NSObject) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (Foundation.URL, Foundation.NSObject) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Foundation.URL, Foundation.NSObject)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`()

  public func `method`() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject))

  public func `method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject)) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject)) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void {
        concreteImplementation(`param1`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `method`(`param1`: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(`param1`: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), `param2`: (Foundation.URL, Foundation.NSObject)) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels`()

  public func `methodWithParameterLabels`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return mockingContext.didInvoke(invocation) { () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `methodWithParameterLabels`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`methodWithParameterLabels`() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TupleTypes`.
public func mock(_ type: MockingbirdTestsHost.TupleTypes.Protocol, file: StaticString = #file, line: UInt = #line) -> TupleTypesMock {
  return TupleTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TypealiasedClass

public final class TypealiasedClassMock: MockingbirdTestsHost.TypealiasedClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback)

  public override func `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedClass.IndirectCallback>())])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject {
        return concreteImplementation(`callback`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback)

  public override func `request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedClass.IndirectCallback>())])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
        return concreteImplementation(`callback`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback)

  public override func `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
        return concreteImplementation(`escapingCallback`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`escapingCallback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`escapingCallback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedClass.IndirectCallback) -> MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult, MockingbirdTestsHost.TypealiasedClass.IndirectRequestResult>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.TypealiasedClass`.
public func mock(_ type: MockingbirdTestsHost.TypealiasedClass.Type, file: StaticString = #file, line: UInt = #line) -> TypealiasedClassMock {
  return TypealiasedClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TypealiasedProtocol

public final class TypealiasedProtocolMock: MockingbirdTestsHost.TypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback)

  public func `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback>())])
    return mockingContext.didInvoke(invocation) { () -> Foundation.NSObject in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject {
        return concreteImplementation(`callback`)
      } else if let concreteImplementation = implementation as? () -> Foundation.NSObject {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Foundation.NSObject).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback)

  public func `request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback>())])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
        return concreteImplementation(`callback`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`callback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`callback`: MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback)

  public func `request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (@escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
        return concreteImplementation(`escapingCallback`)
      } else if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `request`(`escapingCallback`: @escaping @autoclosure () -> MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`escapingCallback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`request`(`escapingCallback`: @escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping MockingbirdTestsHost.TypealiasedProtocol.IndirectCallback) -> MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult, MockingbirdTestsHost.TypealiasedProtocol.IndirectRequestResult>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.TypealiasedProtocol`.
public func mock(_ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> TypealiasedProtocolMock {
  return TypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UnalphabetizedGenericClass

public final class UnalphabetizedGenericClassMock<C, B, A>: MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(A.self).debugDescription, ObjectIdentifier(B.self).debugDescription, ObjectIdentifier(C.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "UnalphabetizedGenericClassMock<C, B, A>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UnalphabetizedGenericClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z)

  public override func `genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z) -> (X, Y, Z) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z) -> (X, Y, Z)", arguments: [Mockingbird.ArgumentMatcher(`x`), Mockingbird.ArgumentMatcher(`y`), Mockingbird.ArgumentMatcher(`z`)])
    return mockingContext.didInvoke(invocation) { () -> (X, Y, Z) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (X, Y, Z) -> (X, Y, Z) {
        return concreteImplementation(`x`, `y`, `z`)
      } else if let concreteImplementation = implementation as? () -> (X, Y, Z) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((X, Y, Z)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericMethod`<Z, Y, X>(`x`: @escaping @autoclosure () -> X, `y`: @escaping @autoclosure () -> Y, `z`: @escaping @autoclosure () -> Z) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (X, Y, Z) -> (X, Y, Z), (X, Y, Z)> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`x`), Mockingbird.resolve(`y`), Mockingbird.resolve(`z`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericMethod`<Z, Y, X>(`x`: X, `y`: Y, `z`: Z) -> (X, Y, Z)", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (X, Y, Z) -> (X, Y, Z), (X, Y, Z)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericReferencingMethod`(`a`: A, `b`: B, `c`: C)

  public override func `genericReferencingMethod`(`a`: A, `b`: B, `c`: C) -> (A, B, C) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericReferencingMethod`(`a`: A, `b`: B, `c`: C) -> (A, B, C)", arguments: [Mockingbird.ArgumentMatcher(`a`), Mockingbird.ArgumentMatcher(`b`), Mockingbird.ArgumentMatcher(`c`)])
    return mockingContext.didInvoke(invocation) { () -> (A, B, C) in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (A, B, C) -> (A, B, C) {
        return concreteImplementation(`a`, `b`, `c`)
      } else if let concreteImplementation = implementation as? () -> (A, B, C) {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((A, B, C)).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `genericReferencingMethod`(`a`: @escaping @autoclosure () -> A, `b`: @escaping @autoclosure () -> B, `c`: @escaping @autoclosure () -> C) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (A, B, C) -> (A, B, C), (A, B, C)> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`a`), Mockingbird.resolve(`b`), Mockingbird.resolve(`c`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`genericReferencingMethod`(`a`: A, `b`: B, `c`: C) -> (A, B, C)", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (A, B, C) -> (A, B, C), (A, B, C)>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.UnalphabetizedGenericClass<C, B, A>`.
public func mock<C, B, A>(_ type: UnalphabetizedGenericClassMock<C, B, A>.Type, file: StaticString = #file, line: UInt = #line) -> UnalphabetizedGenericClassMock<C, B, A> {
  return UnalphabetizedGenericClassMock<C, B, A>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UndefinedArgumentLabels

public final class UndefinedArgumentLabelsMock: MockingbirdTestsHost.UndefinedArgumentLabels, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UndefinedArgumentLabelsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool)

  public func `method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`), Mockingbird.ArgumentMatcher(`someParam`), Mockingbird.ArgumentMatcher(`param4`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool, String, Int, Bool) -> Bool {
        return concreteImplementation(`param1`, `param2`, `someParam`, `param4`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `method`(_ `param1`: @escaping @autoclosure () -> Bool, _ `param2`: @escaping @autoclosure () -> String, _ `someParam`: @escaping @autoclosure () -> Int, _ `param4`: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, String, Int, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`method`(_ `param1`: Bool, _ `param2`: String, _ `someParam`: Int, _ `param4`: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, String, Int, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.UndefinedArgumentLabels`.
public func mock(_ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol, file: StaticString = #file, line: UInt = #line) -> UndefinedArgumentLabelsMock {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UnspecializedGenericSubclass

public final class UnspecializedGenericSubclassMock<T>: MockingbirdTestsHost.UnspecializedGenericSubclass<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "UnspecializedGenericSubclassMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UnspecializedGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> T in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> T {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedGenericSubclass<T>`.
public func mock<T>(_ type: UnspecializedGenericSubclassMock<T>.Type, file: StaticString = #file, line: UInt = #line) -> UnspecializedGenericSubclassMock<T> {
  return UnspecializedGenericSubclassMock<T>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UnspecializedMultipleGenericSubclass

public final class UnspecializedMultipleGenericSubclassMock<T, R>: MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = [ObjectIdentifier(R.self).debugDescription, ObjectIdentifier(T.self).debugDescription].joined(separator: ",")
    let staticMockIdentifier = "UnspecializedMultipleGenericSubclassMock<T, R>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] { return staticMock }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UnspecializedMultipleGenericSubclassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked baseVariable

  override public var `baseVariable`: T {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> T in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> T {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> T, T>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `baseMethod`(`param`: T)

  public override func `baseMethod`(`param`: T) -> T {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    return mockingContext.didInvoke(invocation) { () -> T in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (T) -> T {
        return concreteImplementation(`param`)
      } else if let concreteImplementation = implementation as? () -> T {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (T).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `baseMethod`(`param`: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`baseMethod`(`param`: T) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.UnspecializedMultipleGenericSubclass<T, R>`.
public func mock<T, R>(_ type: UnspecializedMultipleGenericSubclassMock<T, R>.Type, file: StaticString = #file, line: UInt = #line) -> UnspecializedMultipleGenericSubclassMock<T, R> {
  return UnspecializedMultipleGenericSubclassMock<T, R>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariablesContainerProtocol

public final class VariablesContainerProtocolMock: MockingbirdTestsHost.VariablesContainerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked readonlyVariableOverwrittenAsReadwrite

  public var `readonlyVariableOverwrittenAsReadwrite`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getReadonlyVariableOverwrittenAsReadwrite() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariablesContainerProtocol`.
public func mock(_ type: MockingbirdTestsHost.VariablesContainerProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> VariablesContainerProtocolMock {
  return VariablesContainerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariablesContainer

public final class VariablesContainerMock: MockingbirdTestsHost.VariablesContainer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> VariablesContainerMock {
      let mock: VariablesContainerMock = VariablesContainerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked computedMutableVariable

  override public var `computedMutableVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedMutableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedMutableVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked computedVariableWithDidSetObserver

  override public var `computedVariableWithDidSetObserver`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedVariableWithDidSetObserver() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedVariableWithDidSetObserver(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked computedVariableWithWillSetObserver

  override public var `computedVariableWithWillSetObserver`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedVariableWithWillSetObserver() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedVariableWithWillSetObserver(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked computedVariable

  override public var `computedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
  }

  public func getComputedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked lazyVariableWithExplicitType

  override public var `lazyVariableWithExplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLazyVariableWithExplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setLazyVariableWithExplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithExplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked lazyVariableWithImplicitType

  override public var `lazyVariableWithImplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLazyVariableWithImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setLazyVariableWithImplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lazyVariableWithImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked readonlyVariableOverwrittenAsReadwrite

  override public var `readonlyVariableOverwrittenAsReadwrite`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getReadonlyVariableOverwrittenAsReadwrite() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setReadonlyVariableOverwrittenAsReadwrite(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithComplexConstructedImplicitType

  override public var `storedVariableWithComplexConstructedImplicitType`: Array<(String, String)> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithComplexConstructedImplicitType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Array<(String, String)> in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Array<(String, String)> {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Array<(String, String)>).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithComplexConstructedImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Array<(String, String)>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithComplexConstructedImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<(String, String)>, Array<(String, String)>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithComplexConstructedImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<(String, String)>, Array<(String, String)>>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithComplexConstructedImplicitType(_ newValue: @escaping @autoclosure () -> Array<(String, String)>) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Array<(String, String)>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithComplexConstructedImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Array<(String, String)>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithConstructedImplicitType

  override public var `storedVariableWithConstructedImplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithConstructedImplicitType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithConstructedImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithConstructedImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithConstructedImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithConstructedImplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithConstructedImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithExplicitType

  override public var `storedVariableWithExplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithExplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithExplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithImplicitTupleType

  override public var `storedVariableWithImplicitTupleType`: (Bool, Bool) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitTupleType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> (Bool, Bool) in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> (Bool, Bool) {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: ((Bool, Bool)).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitTupleType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ((Bool, Bool)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithImplicitTupleType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Bool, Bool), (Bool, Bool)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitTupleType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Bool, Bool), (Bool, Bool)>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithImplicitTupleType(_ newValue: @escaping @autoclosure () -> (Bool, Bool)) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, ((Bool, Bool)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitTupleType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, ((Bool, Bool)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked storedVariableWithImplicitType

  override public var `storedVariableWithImplicitType`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithImplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked uninitializedVariable

  override public var `uninitializedVariable`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> Bool in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getUninitializedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setUninitializedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked weakVariable

  override public var `weakVariable`: MockingbirdTestsHost.VariablesContainer? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> MockingbirdTestsHost.VariablesContainer? in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> MockingbirdTestsHost.VariablesContainer? {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (MockingbirdTestsHost.VariablesContainer?).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.VariablesContainer?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getWeakVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.VariablesContainer?, MockingbirdTestsHost.VariablesContainer?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.VariablesContainer?, MockingbirdTestsHost.VariablesContainer?>(mock: self, invocation: invocation)
  }

  public func setWeakVariable(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.VariablesContainer?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.VariablesContainer?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "weakVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (MockingbirdTestsHost.VariablesContainer?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init()

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() ", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Initialize an initializable class mock of `MockingbirdTestsHost.VariablesContainer`.
public func mock(_ type: MockingbirdTestsHost.VariablesContainer.Type, file: StaticString = #file, line: UInt = #line) -> VariablesContainerMock.InitializerProxy.Type {
  return VariablesContainerMock.InitializerProxy.self
}

// MARK: - Mocked VariadicClass

public final class VariadicClassMock: MockingbirdTestsHost.VariadicClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `variadicMethod`(`objects`: Bool..., `param2`: Int)

  public override func `variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
        concreteImplementation(`objects`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethod`(`objects`: String..., `param2`: Int)

  public override func `variadicMethod`(`objects`: String..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([String], Int) -> Void {
        concreteImplementation(`objects`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [String], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: String..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...)

  public override func `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, [String]) -> Void {
        concreteImplementation(`param1`, `objects`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: String...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicReturningMethod`(`objects`: Bool..., `param2`: Int)

  public override func `variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
        return concreteImplementation(`objects`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `variadicReturningMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
  public func `variadicReturningMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a class mock of `MockingbirdTestsHost.VariadicClass`.
public func mock(_ type: MockingbirdTestsHost.VariadicClass.Type, file: StaticString = #file, line: UInt = #line) -> VariadicClassMock {
  return VariadicClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariadicProtocol

public final class VariadicProtocolMock: MockingbirdTestsHost.VariadicProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `variadicMethod`(`objects`: Bool..., `param2`: Int)

  public func `variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
        concreteImplementation(`objects`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: Bool..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethod`(`objects`: String..., `param2`: Int)

  public func `variadicMethod`(`objects`: String..., `param2`: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([String], Int) -> Void {
        concreteImplementation(`objects`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `variadicMethod`(`objects`: @escaping @autoclosure () -> [String], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethod`(`objects`: String..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethod`(`objects`: String..., `param2`: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...)

  public func `variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation) { () -> Void in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (Int, [String]) -> Void {
        concreteImplementation(`param1`, `objects`)
      } else if let concreteImplementation = implementation as? () -> Void {
        concreteImplementation()
      }
    }
  }

  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func `variadicMethodAsFinalParam`(`param1`: @escaping @autoclosure () -> Int, `objects`: String...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicMethodAsFinalParam`(`param1`: Int, `objects`: String...) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicReturningMethod`(`objects`: Bool..., `param2`: Int)

  public func `variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    return mockingContext.didInvoke(invocation) { () -> Bool in
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
        return concreteImplementation(`objects`, `param2`)
      } else if let concreteImplementation = implementation as? () -> Bool {
        return concreteImplementation()
      } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (Bool).self) {
        return defaultValue
      } else {
        fatalError(stubbingContext.failTest(for: invocation))
      }
    }
  }

  public func `variadicReturningMethod`(`objects`: @escaping @autoclosure () -> [Bool], `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
  public func `variadicReturningMethod`(`objects`: Bool..., `param2`: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`variadicReturningMethod`(`objects`: Bool..., `param2`: Int) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.VariadicProtocol`.
public func mock(_ type: MockingbirdTestsHost.VariadicProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> VariadicProtocolMock {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ViewControllerExtensionReferencer

public final class ViewControllerExtensionReferencerMock: MockingbirdTestsHost.ViewControllerExtensionReferencer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ViewControllerExtensionReferencerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked extendedClassVariable

  public var `extendedClassVariable`: AppKit.NSViewController.ExtendedClass {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> AppKit.NSViewController.ExtendedClass in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AppKit.NSViewController.ExtendedClass {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (AppKit.NSViewController.ExtendedClass).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedClass) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass, AppKit.NSViewController.ExtendedClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass, AppKit.NSViewController.ExtendedClass>(mock: self, invocation: invocation)
  }

  public func setExtendedClassVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedClass) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedEnumVariable

  public var `extendedEnumVariable`: AppKit.NSViewController.ExtendedEnum {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> AppKit.NSViewController.ExtendedEnum in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AppKit.NSViewController.ExtendedEnum {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (AppKit.NSViewController.ExtendedEnum).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedEnum) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedEnumVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum, AppKit.NSViewController.ExtendedEnum> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum, AppKit.NSViewController.ExtendedEnum>(mock: self, invocation: invocation)
  }

  public func setExtendedEnumVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedEnum) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedEnumVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedNestedClassVariable

  public var `extendedNestedClassVariable`: AppKit.NSViewController.ExtendedEnum.NestedExtendedClass {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedNestedClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass, AppKit.NSViewController.ExtendedEnum.NestedExtendedClass> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass, AppKit.NSViewController.ExtendedEnum.NestedExtendedClass>(mock: self, invocation: invocation)
  }

  public func setExtendedNestedClassVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedEnum.NestedExtendedClass) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked extendedNestedEnumVariable

  public var `extendedNestedEnumVariable`: AppKit.NSViewController.ExtendedClass.NestedExtendedEnum {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.get", arguments: [])
      return mockingContext.didInvoke(invocation) { () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum in
        let implementation = stubbingContext.implementation(for: invocation)
        if let concreteImplementation = implementation as? () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum {
          return concreteImplementation()
        } else if let defaultValue = stubbingContext.defaultValueProvider.provideValue(for: (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum).self) {
          return defaultValue
        } else {
          fatalError(stubbingContext.failTest(for: invocation))
        }
      }
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation)
      if let concreteImplementation = implementation as? (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getExtendedNestedEnumVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum, AppKit.NSViewController.ExtendedClass.NestedExtendedEnum> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum, AppKit.NSViewController.ExtendedClass.NestedExtendedEnum>(mock: self, invocation: invocation)
  }

  public func setExtendedNestedEnumVariable(_ newValue: @escaping @autoclosure () -> AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedNestedEnumVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AppKit.NSViewController.ExtendedClass.NestedExtendedEnum) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.ViewControllerExtensionReferencer`.
public func mock(_ type: MockingbirdTestsHost.ViewControllerExtensionReferencer.Protocol, file: StaticString = #file, line: UInt = #line) -> ViewControllerExtensionReferencerMock {
  return ViewControllerExtensionReferencerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked WildcardFileNonRelativeIgnoredSource

public final class WildcardFileNonRelativeIgnoredSourceMock: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.11.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      WildcardFileNonRelativeIgnoredSourceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Initialize a protocol mock of `MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource`.
public func mock(_ type: MockingbirdTestsHost.WildcardFileNonRelativeIgnoredSource.Protocol, file: StaticString = #file, line: UInt = #line) -> WildcardFileNonRelativeIgnoredSourceMock {
  return WildcardFileNonRelativeIgnoredSourceMock(sourceLocation: SourceLocation(file, line))
}
